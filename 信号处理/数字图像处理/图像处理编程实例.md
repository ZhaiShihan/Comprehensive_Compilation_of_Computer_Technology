### 壹  均值滤波

```C++
// 对给定灰度图像 src，按照给定的滤波器大小进行均值滤波，输出图像滤波结果 dst

// 要求：

// 1. 对图像边界处的运算，在范围外的图像，内容按零处理

// 2. 运算结束需要四舍五入，按整型数输出结果，不用对数据范围进行处理，即输出可以大于255
// 滤波器大小为奇数

// vector<vector<int>> blur(vector<vector<int>>src,  
    // int height_filter,
    // int width_filter)

// src：待处理的图像 int[]
// dst：处理结果
// height_src：输入图像的高，即 src.size()
// width_src：输入图像的宽，即 src[0].size()
// height_filter：滤波器的高
// width_filter：滤波器的宽

// 1 <= src.size() <= 10000
// 1 <= src[0].size() <= 10000
// 1 <= height_filter <= 10000
// 1 <= width_filter <= 10000

// 输入：

// height_src,
// width_src,
// heiht_filter,
// width_filter,
// height_src 行 width_src 列的图像矩阵数据

// 输出:
// height_src行 width_src列的均值滤波结果（空格相隔）

#include <iostream>
#include <vector>
#include <cmath>
using namespace std;

// 实现均值滤波：
vector<vector<int>> blur(vector<vector<int>> src, int height_filter, int width_filter)
{
	int height_src = src.size();  //图高
	int width_src = src[0].size();  //图宽
	int r_h = height_filter/2;  //滤波器高半径
	int r_w = width_filter/2;  //滤波器宽半径
	//条件：“滤波器大小为奇数”
	
	//dst 用于存储结果矩阵，它的大小为 height_src 行，每行 width_src 列，且初始值全部为 0
	vector<vector<int>> dst(height_src, vector<int>(width_src, 0));
	
	//遍历图像 src 每一个像素
	for(int i=0; i<height_src; i++)
	{
		for(int j=0; j<width_src; j++)
		{
			double sum=0;    //用于采集滤波器中所有的像素值
			for(int h=-r_h; h<=r_h; h++)
			{
				for(int w=-r_w; w<=r_w; w++)
				{
					if(i+h>=0 && j+w>=0 && i+h<height_src && j+w<width_src) sum+=src[i+h][j+w];
					else sum+=0;
				}
			}
			dst[i][j]=(int)(sum/(height_filter*width_filter)+0.5);  //四舍五入法（加 0.5 再取整）
		}
	}
	
	return dst;
}

int main()
{
	int height_src=0;  //图高
	int width_src=0;  //图宽
	int height_filter=0;  //滤波器高
	int width_filter=0;  //滤波器宽
	
	//输入：
	cin>>height_src>>width_src;
	cin>>height_filter>>width_filter;
	
	vector<vector<int>> src(height_src, vector<int>(width_src, 0));  //源图像
	
	for(int i=0; i<height_src; i++)
	{
		for(int j=0; j<width_src; j++) cin>>src[i][j];
	}
	
	vector<vector<int>> dst=blur(src, height_filter, width_filter);  //输出图像
	
	//输出：
	for(int i=0; i<height_src; i++)
	{
		for(int j=0; j<width_src; j++) cout<<dst[i][j]<<' ';
		cout<<endl;
	}
	
	return 0;
}
```


### 贰  直方图均衡化

```C++
// 本次作业需要你设计一个程序对一个8×8，8灰度级的灰度图像进行直方图均衡化，并按从0到7的顺序输出直方图均衡化后的灰度映射。

// 输入：

//8×8，8灰度级的灰度图像

// 输出：

// 输出灰度值

#include <iostream>
#include <vector>
#include <cmath>
using namespace std;

int main()
{
	vector<vector<int>> src(8, vector<int>(8,0));  //源图像
	vector<int> histogram(8,0);  //直方图
	vector<int> cdf(8,0);  //累积分布函数
	vector<int> equalized(8,0);  //均衡化后的灰度值
	
	//输入：
	for(int i=0; i<=7; i++)
	{
		for(int j=0; j<=7; j++)
		{
			cin>>src[i][j];
			histogram[src[i][j]]+=1;  //统计每个灰度级的频率
		}
	}
	
	//累积分布值：
	cdf[0]=histogram[0];
	for(int k=1; k<=7; k++) cdf[k]=cdf[k-1]+histogram[k];
	
	//均衡化后灰度映射：
	for(int i=0; i<=7; i++) equalized[i]=(int)((double)cdf[i]/(double)cdf[7]*7.0+0.5);
	
	//输出：
	for(int i=0; i<=6; i++) cout<<equalized[i]<<' ';
	cout<<equalized[7]<<endl;
	
	return 0;
}
```


### 叁  图像卷积操作

```C++
// 对给定灰度图像（以矩阵形式输入，整型数，灰度取值范围[0,255]）
// 按照给定的卷积核（以矩阵形式输入，浮点数）进行卷积
// 卷积核不需要翻转，输出图像卷积结果（以矩阵形式输出）

// 要求：

// 对图像边界处的卷积运算，在卷积核超出图像边界的地方，图像内容按零处理
// 卷积运算完需要四舍五入，按整型数输出结果，不用对数据范围进行处理，即输出数据可以大于255

// 输入：

// 图像行数：0<m<101 图像列数：0<n<101

// 卷积核行数：0<u<101 卷积核列数：0<v<101（u、v 一定是奇数）

// 图像矩阵：src m 行 n列的灰度图像矩阵 卷积核：kernel u 行 v 列的浮点数矩阵

// 输出：

// result：m 行 n 列的整形矩阵数据

#include <iostream>
#include <vector>
#include <cmath>
using namespace std;

//二维离散卷积函数
vector<vector<int>> convolve(vector<vector<int>> src, vector<vector<double>> kernel)
{
	int m=src.size();
	int n=src[0].size();
	int u=kernel.size();
	int v=kernel[0].size();
	
	int r_u = u/2;  //卷积核行半径
	int r_v = v/2;  //卷积核列半径
	//“u、v 一定是奇数”
	
	vector<vector<int>> result(m, vector<int>(n,0));
	
	//遍历结果矩阵像素点
	for(int i=0; i<m; i++)
	{
		for(int j=0; j<n; j++)
		{
			double sum=0;  //卷积和
			
			for(int k=-r_u; k<=r_u; k++)
			{
				for(int l=-r_v; l<=r_v; l++)
				{
					int ai = i+k;  //源图像上行
					int aj = j+l;  //源图像上列
					
					if(ai>=0 && ai<m && aj>=0 && aj<n) sum+=src[ai][aj]*kernel[k+r_u][l+r_v];		
				}
			}
			result[i][j] = round(sum);  // 四舍五入并存储卷积结果
		}
	}
	return result;
}

int main()
{
	int m, n, u, v;
	// m×n 的图像，u×v 的卷积核
	
	cin>>m>>n;
	cin>>u>>v;
	vector<vector<int>> src(m, vector<int>(n,0));
	
	//输入：
	for(int i=0; i<m; i++)
	{
		for(int j=0; j<n; j++) cin>>src[i][j];
	}
	
	vector<vector<double>> kernel(u, vector<double>(v,0));
	
	for(int i=0; i<u; i++)
	{
		for(int j=0; j<v; j++) cin>>kernel[i][j];
	}
	
	vector<vector<int>> result=convolve(src, kernel);  //卷积
	
	//输出：
	for(int i=0; i<m; i++)
	{
		for(int j=0; j<n; j++) cout<<result[i][j]<<' ';
		cout<<endl;
	}
	
	return 0;
}
```


### 肆  连通域检测

```C++
// 读入一幅黑白图像，按要求对白色区域进行连通域检测，输出每个连通域内的像素坐标。

// 输入：

// w h k

// h 行 w 列的图像矩阵数据（数值只有 0 或者 1）

// 输出:
// i-th component:
// 像素坐标 x y
// 像素坐标 x y
// ……

// 要求：

// 1. 图像处理顺序，按照 y 坐标从小到大、x 坐标从小到大进行，对找到的连通域进行顺序编号（从 1 开始）

// 2. 按照输入的 k（4/8）值进行 4 邻域或 8 邻域连通域检测

// 3. 不需要考虑图像边界条件，即图像边界处，像素值不会出现 1

// 4. 输出连通域的像素坐标时，也是按照y 坐标从小到大、x 坐标从小到大进行，像素坐标从 0 开始

// 5. 图像大小不超过 100*100

#include <iostream>
#include <vector>
#include <stack>
#include <algorithm>
using namespace std;

const int dir4[4][2] = {{-1,0}, {1,0}, {0,-1}, {0,1}};    // 4 邻域方向
const int dir8[8][2] = {{-1,-1}, {-1,0}, {-1,1}, {0,-1}, {0,1}, {1,-1}, {1,0}, {1,1}};    // 8 邻域方向

void dfs(int x, int y,
		vector<vector<int>>& image,
		vector<vector<bool>>& visited,
		vector<pair<int, int>>& component,
		const int dir[8][2],
		int dirs)
{
	stack<pair<int, int>> s;
	s.push({x, y});
	visited[y][x] = true;
	
	while(!s.empty())
	{
		int cx = s.top().first;
		int cy = s.top().second;
		s.pop();
		component.push_back({cy, cx});    // 存储坐标，按 y，x 的顺序
		
		for(int i=0; i<dirs; i++)
		{
			int nx = cx+dir[i][0];
			int ny = cy+dir[i][1];
			
			if(nx>=0 && ny>=0 && nx<(int)image[0].size() && ny<(int)image.size() && !visited[ny][nx] && image[ny][nx]==1)
			{
				visited[ny][nx] = true;
				s.push({nx, ny});
			}
		}
	}
}

int main()
{
	int w, h, k;
	cin>>w>>h>>k;
	
	// 读取图像矩阵
	vector<vector<int>> image(h, vector<int>(w));
	for(int i=0; i<h; i++) for(int j=0; j<w; j++) cin>>image[i][j];
	
	// 根据 k 选择邻域方向
	const int (*directions)[2];
	int numDirs;
	if(k==4) directions = dir4, numDirs = 4;
	else if(k==8) directions = dir8, numDirs = 8;
	else {cout<<"k 值无效，只能取 4，8！"<<endl; return -1;}
	
	vector<vector<bool>> visited(h, vector<bool>(w, false));
	vector<vector<pair<int, int>>> components;
	
	// 查找所有连通域
	for(int y=0; y<h; y++)
	{
		for(int x=0; x<w; x++)
		{
			if(image[y][x]==1 && !visited[y][x])
			{
				vector<pair<int, int>> component;
				dfs(x, y, image, visited, component, directions, numDirs);
				// 对每个连通域中的坐标进行排序
				sort(component.begin(), component.end());
				components.push_back(component);
			}
		}
	}
	
	// 输出结果：
	for(int i=0; i<(int)components.size(); i++)
	{
		cout<<i+1<<"-th component:"<<endl;
		for(int j=0; j<(int)components[i].size(); j++)
		{
			cout<<components[i][j].second<<" "<<components[i][j].first<<endl;    // 输出结果
		}
	}
	
	return 0;
}
```


### 伍  双线性插值缩放图像

```C++
#include <iostream>
#include <vector>
#include <cmath>
using namespace std;

void bilinearInterpolationResize(int height_src, int width_src, int height_dst, int width_dst,
                                 vector<vector<int>>& src,
                                 vector<vector<int>>& dst)
{
    // 计算缩放比例
    double scale_x = static_cast<double>(width_src) / width_dst;
    double scale_y = static_cast<double>(height_src) / height_dst;

    // 源图像中心坐标
    double center_src_x = (width_src - 1) / 2.0;
    double center_src_y = (height_src - 1) / 2.0;

    // 目标图像中心坐标
    double center_dst_x = (width_dst - 1) / 2.0;
    double center_dst_y = (height_dst - 1) / 2.0;

    // 双线性插值计算每个目标图像位置的值
    for (int y_dst = 0; y_dst < height_dst; y_dst++)
    {
        for (int x_dst = 0; x_dst < width_dst; x_dst++)
        {
            // 中心对齐映射到源图像中的浮动坐标
            double x_src = (x_dst - center_dst_x) * scale_x + center_src_x;
            double y_src = (y_dst - center_dst_y) * scale_y + center_src_y;

            // 计算 x_src, y_src 的四个邻居的坐标
            int x1 = static_cast<int>(floor(x_src)); // 左邻点
            int y1 = static_cast<int>(floor(y_src)); // 上邻点
            int x2 = min(x1 + 1, width_src - 1);     // 右邻点（防止越界）
            int y2 = min(y1 + 1, height_src - 1);    // 下邻点（防止越界）

            // 计算四个邻居的灰度值
            double Q11 = src[y1][x1]; // 左上
            double Q21 = src[y1][x2]; // 右上
            double Q12 = src[y2][x1]; // 左下
            double Q22 = src[y2][x2]; // 右下

            // 计算水平和垂直偏移量
            double dx = x_src - x1;
            double dy = y_src - y1;

            // 双线性插值公式
            double interpolated_value = Q11 * (1.0 - dx) * (1.0 - dy) +
                                         Q21 * dx * (1.0 - dy) +
                                         Q12 * (1.0 - dx) * dy +
                                         Q22 * dx * dy;

            // 四舍五入并赋值给目标图像
            dst[y_dst][x_dst] = static_cast<int>(round(interpolated_value));
        }
    }
}

int main()
{
    // 输入源图像尺寸和目标图像尺寸：
    int height_src, width_src, height_dst, width_dst;
    cin >> height_src >> width_src >> height_dst >> width_dst;

    // 输入源图像数据：
    vector<vector<int>> src(height_src, vector<int>(width_src));
    for (int i = 0; i < height_src; i++)
        for (int j = 0; j < width_src; j++)
            cin >> src[i][j];

    // 初始化目标图像
    vector<vector<int>> dst(height_dst, vector<int>(width_dst));

    // 调用双线性插值函数进行图像缩放
    bilinearInterpolationResize(height_src, width_src, height_dst, width_dst, src, dst);

    // 输出目标图像：
    for (int i = 0; i < height_dst; i++)
    {
        for (int j = 0; j < width_dst; j++)
        {
            cout << dst[i][j];
            if (j != width_dst - 1)
                cout << ' ';
        }
        cout << endl;
    }

    return 0;
}
```


### 陆  LZW 编码

```C++
// Lempel-Ziv-Welch（LZW）编码算法是一种无误差压缩算法，将定长码字分配给变长信源符号序列
// 现请尝试对输入单张灰度图像进行 LZW 编码
// 读取数据时要求以行优先的方式读取
// 灰度取值范围 [0,255]

#include <iostream>
#include <vector>
#include <unordered_map>
#include <deque>

using namespace std;

// LZW编码
vector<int> LZWEncode(const vector<vector<int>>& image, int maxDictSize=4096)
{
    // 初始化字典
    unordered_map<string, int> dictionary;
    int dictSize = 256;  // 初始字典大小，256个灰度值对应的字符

    // 将灰度值0-255直接映射到字典
    for (int i = 0; i < 256; ++i) dictionary[string(1, char(i))] = i;

    vector<int> output;  // 编码结果
    string currentSeq = "";  // 当前的符号序列

    for (const auto& row : image) {
        for (int pixel : row)
		{
            string currentPixel(1, char(pixel));  // 当前灰度值转为字符
            string newSeq = currentSeq + currentPixel;

            // 如果新序列在字典中，继续扩展
            if (dictionary.find(newSeq) != dictionary.end()) currentSeq = newSeq;
            else
			{
                // 如果新序列不在字典中，输出当前序列的编码并添加新序列到字典
                output.push_back(dictionary[currentSeq]);
                if ((int)dictionary.size() < (int)maxDictSize) {
                    dictionary[newSeq] = dictSize++;
                }
                currentSeq = currentPixel;  // 以当前灰度值开始新的序列
            }
        }
    }

    // 输出最后的符号序列
    if (!currentSeq.empty()) output.push_back(dictionary[currentSeq]);
    return output;
}

int main() {
    // 读取图像的尺寸
    int height, width;
    cin>>height>>width;

    // 读取图像数据
    vector<vector<int>> image(height, vector<int>(width));
    for (int i=0; i<height; i++)
	{
        for (int j = 0; j < width; ++j)
		{
            cin>>image[i][j];
        }
    }

    // 对图像进行LZW编码
    vector<int> encoded = LZWEncode(image);

    // 输出LZW编码的结果
    for (int c=0; c<(int)encoded.size(); c++)
	{
        cout<<encoded[c];
        if(c!=(int)encoded.size()-1) cout<<' ';
    }
    cout << endl;

    return 0;
}
```

