#### 1. 根的圈定：

##### 根的存在定理：

- 对于区间 $[a,b]$ 上的连续单值函数 $f(x)$，如果 $f(a)\cdot f(b)\textless0$，则 $[a,b]$ 上至少一个实根，如果 $f(x)$ 在 $[a,b]$ 单调，则仅有一个实根

##### 圈定根的交点法：

- 对于方程 $f(x)=0$，可以将其分解成 $\varphi_1(x)=\varphi_2(x)$，在平面直角坐标系中根据函数性质画出图像，确定交点范围


- 例 1：圈定方程根的范围至区间长度为 $1$：$$x\cdot\lg{x}-1=0$$

- 解法：将方程分解成：$$\lg{x}=\frac{1}{x}$$通过描点画图可以看到：交点的横坐标位于区间 $[2,3]$ 内


- 系数扩大增长率法：对于 $f(x)=0$，当函数的根看不清时，可以在 $f(x)$ 上乘一个系数 $k$，零点不改变（通过系数 $k$，使得当 $x$ 变化很小时，$f(x)$ 的变化很大，从而易于辨根）

##### 圈定根的扫描法：

- 扫描法的关键步骤是确定步长 $h=\frac{b-a}{n}$，$n\in N^*$（ $h$ 过大时可能漏根；$h$ 过小时扫描次数较多，工作量大）

- 确定步长后从左到右每一个区间检查端点 $f(x)$ 的符号


- 例 2：编程扫描 $f(x)=x^4-3x^3+4x^2-2x-1=0$ 在 $[1,2]$ 的根所在区间（区间长度精确到 $0.1$）

- 解法：
```C++
#include<iostream>
using namespace std;

double f(double x) {return x*x*x*x -3*x*x*x +4*x*x -2*x -1;}

int main()
{
	int k=1;
	for(double i=1.0; i<=1.9; i+=0.1)
	{
		if(f(i)*f(i+0.1)<0)
		{
			cout<<"含根区间 "<<k++<<"：["<<i<<", "<<i+0.1<<"]"<<endl;
		}
	}
	return 0;
}
```
~~~
输出：
含根区间 1：[1.5, 1.6]
~~~

- 上述方程在 $[1.5,\ 1.6]$ 的解为 $1.5188$（可以将步长设为 $0.00001$ 得到根的范围为 $[1.51879,\ 1.51880]$）


- 理论上，当步长小到一定程度时，可以得到非常精确的解，但求解复杂度会随之变得非常高

##### 圈定根的对分法：

- 对分法：取 $[a,b]$ 中点 $r=\frac{a+b}{2}$，若 $f(a)\cdot f(r)\textless0$ 则令 $b=r$；若 $f(a)\cdot f(r)\textgreater0$ 则令 $a=r$；循环上述过程直到满足精度要求：$b-a\leq\epsilon$

- 假定对分次数为 $n$，则有：$$\frac{b-a}{2^n}\textless\epsilon\ \Rightarrow\ n\textgreater\frac{\ln{(b-a)-\ln{\epsilon}}}{\ln{2}}$$由此可以预估为了达到精度范围至少要多分多少次


- 例 3：编程用对分法求解 $f(x)=x^3-x^2+x-2=0$ 在 $[1,2]$ 的根，精确到小数点后第 $2$ 位

- 解法：精确小数点后第二位需要满足 $\epsilon\textless0.005$，故 $n\textgreater\frac{-\ln{0.005}}{\ln{2}}=7.6439$
```C++
#include<iostream>
using namespace std;

double f(double x) {return x*x*x -x*x +x -2;}

int main()
{
	double a=1.0, b=2.0;
	
	for(int i=1; i<=8; i++)
	{
		double r=(a+b)/2.0; 
		if(f(a)*f(r)<0) a=r;
		else if(f(a)*f(r)>0) b=r;
		else
		{
			cout<<"x="<<r<<endl;
			return 0;
		}
	}
	cout<<"含根区间：["<<a<<", "<<b<<"]"<<endl;
	return 0;
}
```
~~~
输出：
含根区间：[1.35156, 1.35547]
~~~

- 将迭代次数改为 $20$，得到方程在 $[1,2]$ 的解为 $1.3532$


- 对分法的缺点：难求重根和复根，且收敛速率很慢


#### 2. 迭代解法：

##### 迭代解法的本质：

- 方程的迭代解法即使用方程的残差通过迭代过程求取方程的根

- 对于 $f(x)=0$，可以将其变形成 $x=\varphi(x)$ 形式，令 $x_n=\varphi(x_n)$ 并解出 $x_n$ 的近似值，近似值 $x_n$ 与精确值之差即为残差（截断误差）：$$\Delta x_n=\varphi(x_n)-x_n$$故在 $x_n$ 基础上，将误差再加回来重新解方程：$$x_{n+1}=x_n+\Delta x_n=\varphi(x_n)$$根据这个迭代公式进行层层迭代即可逐渐逼近更精确的解

- 迭代解法最关键步骤的是：
	- 1. 构造迭代格式
	- 2. 收敛性分析
	- 3. 收敛速度与误差分析

- 建立迭代公式的过程是一个 $f(x)=0$ 向 $x=\varphi(x)$ 等级变化的过程，迭代公式为：$$x_{n+1}=\varphi(x_n)$$$x_0,\ x_1,\ x_2,\cdots$ 为迭代序列，若迭代序列收敛于 $\alpha$，则 $\alpha=\varphi(\alpha)$

##### 迭代法的收敛性：

- 影响迭代法收敛性的要素有二：根近旁函数形态与初值选取

- 迭代法的收敛类型：
	- 1. 大范围收敛：选取任何初始值均收敛
	- 2. 局部收敛：初值充分接近要求的根才能保证收敛性，局部收敛更快

- 收敛充分条件定理：若 $\alpha$ 为方程 $f(x)=0$ 的真解且在区间 $[a,b]$ 上，若迭代格式中的 $\varphi(x)$ 可微且 $\vert \varphi^{'}(x)\vert\leq q\textless1$，则在 $[a,b]$ 上取任何初值 $x_0$ 都必收敛，其中 $\varphi^{'}(x)$ 是 $\varphi(x)$ 的一阶导数，$q$ 是新旧迭代值的误差之比

- 新旧迭代值误差比 $q$ 的大小反映收敛快慢，$q$ 越小收敛越快，$q\textless\frac{1}{10}$ 认为收敛快，$q\textgreater\frac{1}{2}$ 认为收敛慢

- 注意：迭代法收敛不能说明 $\vert \varphi^{'}(x)\vert\leq q\textless1$，注意收敛条件是充分不必要的

- 由上述定理可知：若$$\lim_{n\to\infty}\frac{\vert x_{n+1}-\alpha\vert}{\vert x_n-\alpha\vert^r}=C$$成立 $\Rightarrow$ 该迭代序列 $r$ 阶收敛，$r$ 和 $C$ 是正数，$r$ 是收敛的阶，$C$ 为渐进误差常数；$r$ 越大，绝对误差缩减得越快

- $r=1$ 为线性收敛，$r\textgreater1$ 为超线性收敛，$r=2$ 为平方收敛

- 测定收敛阶：若 $\varphi^{'}(\alpha)=\varphi^{''}(\alpha)=\cdots=\varphi^{(r-1)}(\alpha)=0$，$\varphi^{(r)}(\alpha)\neq0$ 则迭代序列 $r$ 阶收敛；此条件等同于：$$\lim_{n\to\infty}{\frac{\vert x_{n+1}-\alpha\vert}{\vert x_n-\alpha\vert^r}}=\frac{\varphi^{(r)}(\alpha)}{r!}=C_r，\ \ \ \ C_r 是非零常数$$该式能说明迭代序列 $r$ 阶收敛


- 例 4：求解方程 $x+\frac{2}{x^2+6}-5=0$ 的实根，并讨论迭代序列的收敛阶

- 解法：将方程变为迭代格式：$$x=5-\frac{2}{x^2+6}$$则：$\varphi(x)=5-\frac{2}{x^2+6}$，测定收敛阶：$$\varphi^{'}(x)=\frac{4x}{(x^2+6)^2},\ \ \ \ \varphi^{''}(x)=\frac{24-12x^2}{(x^2+6)^3}$$$$\varphi^{'}(\alpha)=\frac{4\alpha}{(\alpha^2+6)^2},\ \ 由于\ (\alpha^2+6)=\frac{2}{5-\alpha},\ \ 得\ \varphi^{'}(\alpha)=\frac{2\alpha(5-\alpha)}{(\alpha^2+6)}\neq0$$由此可知迭代序列线性收敛（$r=1$）；再讨论收敛区间：$$取\ \varphi{''}(x)\textless0\ \Rightarrow\ \vert x\vert\textgreater\sqrt{2}\ \Rightarrow\ \varphi^{'}(x)\ 在\ [\sqrt{2},+\infty]\ 上单调递减$$$$\varphi^{'}(\sqrt{2})=\frac{\sqrt{2}}{16}\textless0.1\ \Rightarrow\ 当\ x\in[\sqrt{2},+\infty]\ 时\ q=\varphi^{'}(x)\textless0.1\ 恒成立$$由此可知，迭代方法 $x_{n+1}=5-\frac{2}{x_n^2+6}$ 在 $[\sqrt{2},+\infty]$ 是快速收敛的；取迭代初值 $x_0=2$ 进行 $6$ 次迭代：
~~~
第 1 次迭代结果：4.8
第 2 次迭代结果：4.93113
第 3 次迭代结果：4.93403
第 4 次迭代结果：4.93409
第 5 次迭代结果：4.93409
第 6 次迭代结果：4.93409
~~~
由此得到该方程的一个根为：$x=4.9341$，又 $f(x)=x+\frac{2}{x^2+6}-5$ 单调递增，故 $x=4.9341$ 是唯一实根


##### 迭代的终止：

- 若要求精度为 $\epsilon$，则当 $\vert x_{n+1}-\alpha\vert\textless\epsilon$ 时，$x_{n+1}$ 为所求近似解，由于 $\vert x_{n+1}-\alpha\vert$ 不可知，故以上界公式来替代

- 上界公式 1：$$\vert x_{n+1}-\alpha\vert\leq\frac{q}{1-q}\vert x_{n+1}-x_n\vert\leq\epsilon$$① 当 $0\textless q\leq\frac{1}{2}$ 时，可用 $\vert x_{n+1}-x_n\vert\textless\epsilon$ 来判定；② 当 $\frac{1}{2}\textless q\textless1$ 时，可用 $\vert x_{n+1}-x_n\vert\textless\frac{1-q}{q}\cdot\epsilon$ 来判定；③ 按相对误差限 $\eta$ 来控制：$\vert\frac{x_{n+1}-\alpha}{x_{n+1}}\vert\leq\vert\frac{x_{n+1}-x_n}{x_{n+1}}\vert\leq\eta$

- 上界公式 2：$$\vert x_n-\alpha\vert\leq\frac{q^n}{1-q}\vert x_1-x_0\vert\leq\epsilon$$预估迭代次数：$$\frac{q^n}{1-q}\vert x_1-x_0\vert\leq\epsilon\ \Rightarrow\ n\textgreater\frac{\ln{\frac{\epsilon(1-q)}{\vert x_1-x_0\vert}}}{\ln{q}}$$

- 上界公式 3：$$\vert x_n-\alpha\vert\leq\frac{\vert f(x_n)\vert}{m},\ \ \ \ m\leq\vert f^{'}(x)\vert,\ \ \ \ x\in[a,v]$$当 $\vert f(x_n)\vert\textless m\cdot\epsilon$ 时（$m\leq\vert f^{'}(x)\vert$），既有 $\vert x_n-\alpha\vert\textless\epsilon$ 成立


##### 迭代的过程：

- 例 5：用三种不同的迭代方法求解方程 $f(x)=x^3-x-1=0$ 在区间 $(1,1.5)$ 内的根

- 解法一：将方程写成迭代形式：$$x_{n+1}=\sqrt[3]{x_n+1},\ \ \ \ 取\ x_0=1.25$$
```C++
#include<iostream>
#include<cmath>
using namespace std;

int main()
{
	double x=1.25;
	for(int i=1; i<=12; i++)
	{
		x=pow(x+1, 1.0/3);
		cout<<"第 "<<i<<" 次迭代结果："<<x<<endl;
	}
	return 0;
}
```
~~~
输出：
第 1 次迭代结果：1.31037
第 2 次迭代结果：1.32199
第 3 次迭代结果：1.3242
第 4 次迭代结果：1.32462
第 5 次迭代结果：1.3247
第 6 次迭代结果：1.32471
第 7 次迭代结果：1.32472
第 8 次迭代结果：1.32472
第 9 次迭代结果：1.32472
第 10 次迭代结果：1.32472
第 11 次迭代结果：1.32472
第 12 次迭代结果：1.32472
~~~


- 解法二：将方程写成迭代形式：$$x_{n+1}=\sqrt{1+\frac{1}{x_n}},\ \ \ \ 取\ x_0=1.25$$
```C++
#include<iostream>
#include<cmath>
using namespace std;

int main()
{
	double x=1.25;
	for(int i=1; i<=12; i++)
	{
		x=sqrt(1.0+1.0/x);
		cout<<"第 "<<i<<" 次迭代结果："<<x<<endl;
	}
	return 0;
}
```
~~~
输出：
第 1 次迭代结果：1.34164
第 2 次迭代结果：1.32112
第 3 次迭代结果：1.32549
第 4 次迭代结果：1.32455
第 5 次迭代结果：1.32475
第 6 次迭代结果：1.32471
第 7 次迭代结果：1.32472
第 8 次迭代结果：1.32472
第 9 次迭代结果：1.32472
第 10 次迭代结果：1.32472
第 11 次迭代结果：1.32472
第 12 次迭代结果：1.32472
~~~


- 解法三：将方程写在迭代形式：$$x_{n+1}=\frac{1}{x_n^2+x_n}+1,\ \ \ \ 取\ x_0=1.25$$
```C++
#include<iostream>
using namespace std;

int main()
{
	double x=1.25;
	for(int i=1; i<=12; i++)
	{
		x=1.0/(x*x+x)+1.0;
		cout<<"第 "<<i<<" 次迭代结果："<<x<<endl;
	}
	return 0;
}
```
~~~
输出：
第 1 次迭代结果：1.35556
第 2 次迭代结果：1.31318
第 3 次迭代结果：1.32921
第 4 次迭代结果：1.323
第 5 次迭代结果：1.32538
第 6 次迭代结果：1.32446
第 7 次迭代结果：1.32482
第 8 次迭代结果：1.32468
第 9 次迭代结果：1.32473
第 10 次迭代结果：1.32471
第 11 次迭代结果：1.32472
第 12 次迭代结果：1.32472
~~~


- 例 6：若用下述迭代方法求解方程 $f(x)=x^3-x-1=0$ 在区间 $(1,1.5)$ 内的根，讨论其收敛性：$$x_{n+1}=\frac{x_n+1}{x_n^2}$$

- 解法：设函数 $\varphi(x)=\frac{x+1}{x^2}$，则对其求一阶导数：$$\varphi^{'}(x)=-(\frac{1}{x^2}+\frac{2}{x^3})$$$\varphi^{'}(x)$ 在 $(1,1.5)$ 区间上单调递增且恒负，故区间上 $\vert\varphi^{'}(x)\vert$ 最小值为：$$\vert\varphi^{'}(x)\vert_{min_{in(1,1.5)}}=-\varphi^{'}(1.5)=1.0370\textgreater1$$由此可知迭代方法 $x_{n+1}=\frac{x_n+1}{x_n^2}$ 在 $(1,1.5)$ 上不收敛


- 例 7：对方程 $x-\sin{x}-0.25=0$ 迭代，取三位小数，计算解的近似值，并估计误差

- 解法：改写方程为迭代格式：$$x_{n+1}=\sin{x_n}+0.25$$由交点法圈定根：$\alpha\in[0.9,\ 1.5]$，此时：$$\vert\varphi^{'}(x)\vert=\cos{x}\leq\cos{0.9}=0.62\textless1$$因此可知迭代过程收敛，取 $x_0=1.2$，往复迭代：$$x_1=\sin{1.2}+0.250=1.182$$$$x_2=\sin{1.182}+0.250=1.175$$$$x_3=\sin{1.175}+0.250=1.173$$$$x_4=\sin{1.173}+0.250=1.172$$有 $\vert x_4-x_3\vert=0.001$，故：$$R=\vert x_4-\alpha\vert\leq\frac{0.62}{1-0.62}\vert x_4-x_3\vert=0.0016$$又：$$\epsilon=\epsilon_{sin}+\epsilon_{0.25}=2\times(0.5\times10^{-3})=0.001$$（这里认为 $0.250$ 是测量值），则总误差为：$$E=R+\epsilon=0.0026\textless0.5\times10^{-2}$$因此迭代 $4$ 次的结果已经可以满足三位小数精确，故取方程解为 $x=1.172$


#### 3. 改进迭代公式：

##### 改进迭代公式的思路：

- 改进迭代公式的思路：
	- 1. 提高初值的精度以减少迭代的次数
	- 2. 减小迭代误差比 $q$ 的值
	- 3. 提高收敛的阶数 $r$

##### 第一类引入参数法：

- 由 $x=\varphi(x)$ 出发使用与 $\varphi(x)$ 有关的信息构建新迭代函数，加快收敛

- 由 $x=\varphi(x)$ 可以推出 $x-\theta x=\varphi(x)-\theta x$，进而推出：$$x=\frac{1}{1-\theta}[\varphi(x)-\theta x]=\psi(x)$$$$\psi^{'}(x)=\frac{1}{1-\theta}[\varphi^{'}(x)-\theta]$$
为了使 $\vert\psi^{'}(x)\vert$ 尽可能小，宜取 $\theta=\varphi^{'}(x)$，$x\approx\alpha$

- 引入可选参数法的迭代公式为：$$x_{n+1}=\frac{1}{1-\theta}[\varphi(x_n)-\theta\cdot x_n]$$


- 例 8：用下述迭代格式引入可选参数，求解方程 $f(x)=x^3-x-1=0$ 在区间 $(1,1.5)$ 内的根：$$x=\frac{x+1}{x^2}$$

- 解法：迭代格式为：$$x_{n+1}=\frac{1}{1-\theta}[\varphi(x_n)-\theta\cdot x_n]$$$$\varphi^{'}(x)=-(\frac{1}{x^2}+\frac{2}{x^3})$$则在区间 $(1,1.5)$ 上 $\varphi^{'}(x)$ 的范围为：$-3.000\textless\varphi^{'}(x)\textless-1.037$，固取 $\theta=-2.000$：$$x_{n+1}=\frac{1}{3}[\varphi(x_n)+2x_n]=\frac{2x_n^3+x_n+1}{3x_n^2}$$选取初值为 $x=1.25$ 进行迭代：
```C++
#include<iostream>
#include<cmath>
using namespace std;

int main()
{
	double x=1.25;
	for(int i=1; i<=8; i++)
	{
		x=(2*x*x*x+x+1)/(3*x*x);
		cout<<"第 "<<i<<" 次迭代结果："<<x<<endl;
	}
	return 0;
}
```
~~~
输出：
第 1 次迭代结果：1.31333
第 2 次迭代结果：1.32262
第 3 次迭代结果：1.32432
第 4 次迭代结果：1.32464
第 5 次迭代结果：1.3247
第 6 次迭代结果：1.32472
第 7 次迭代结果：1.32472
第 8 次迭代结果：1.32472
~~~


##### 埃特肯加速法 Aitken's Method：

- 在第一类引入参数法的基础上，取初值 $x_0$，令 $y_1=\varphi(x_0)$，$z_1=\varphi(y_1)$，用差分代替求最优参数的求导：$$\theta_0=\frac{\varphi(y_1)-\varphi(x_0)}{y_1-x_0}=\frac{z_1-y_1}{y_1-x_0}$$则：$$x_1=\frac{1}{1-\theta_0}[\varphi(x_0)-\frac{z_1-y_1}{y_1-x_0}\cdot x_0]=\frac{x_0\cdot z_1-y_1^2}{x_0-2y_1+z_1}$$同理推得迭代公式：$$x_{n+1}=\frac{x_n\cdot z_{n+1}-y_{n+1}^2}{x_n+z_{n+1}-2y_{n+1}}=\psi(x_n)$$$$\psi(x)=\frac{x\cdot\psi[\psi(x)]-[\psi(x)]^2}{x-2\psi(x)+\psi[\psi(x)]}$$

- 埃特肯法的收敛阶数为 $r=2$，可以实现大范围快速收敛


- 例 9：用埃特肯法求方程 $f(x)=x^3-2x-5=0$ 在区间 $[0,4]$ 的解

- 解法：将方程等价变换成：$$x=x^3-x-5=\varphi(x)$$取初值 $x_0=2.0$，进行迭代：
```C++
#include<iostream>
using namespace std;

double varphi(double x) {return (x*x*x-x-5);}

int main()
{
	double x=2.0, y, z;
	cout<<"x0=2.0"<<endl;
	for(int i=1; i<=8; i++)
	{
		y=varphi(x);
		z=varphi(y);
		x=(x*z-y*y)/(x+z-2*y);
		cout<<"第 "<<i<<" 次迭代结果：y"<<i<<"="<<y<<", z"<<i<<"="<<z<<", x"<<i<<"="<<x<<endl;
	}
	return 0;
}
```
~~~
输出：
x0=2.0
第 1 次迭代结果：y1=1, z1=-5, x1=2.2
第 2 次迭代结果：y2=3.448, z2=32.5443, x2=2.14407
第 3 次迭代结果：y3=2.71232, z3=12.2413, x3=2.10804
第 4 次迭代结果：y4=2.25969, z4=4.27875, x4=2.09572
第 5 次迭代结果：y5=2.10877, z5=2.26878, x5=2.09456
第 6 次迭代结果：y6=2.09466, z6=2.09593, x6=2.09455
第 7 次迭代结果：y7=2.09455, z7=2.09455, x7=2.09455
第 8 次迭代结果：y8=2.09455, z8=2.09455, x8=2.09455
~~~

- 上述方程若采用 $x=x^3-x-5=\varphi(x)$ 的格式直接迭代求解：$$\varphi^{'}(x)=3x^2-1$$可以发现：在 $\alpha$ 附近 $\vert\varphi^{'}(x)\vert\gg1$，故 $x_{n+1}=x_n^3-x_n-5$ 迭代序列不收敛


- 例 10：求解方程 $f(x)=x^3-x-1=0$ 在区间 $(1,1.5)$ 内的根

- 解法：将方程等价变换得：$$x=x^3-1=\varphi(x)$$取初值 $x_0=1.25$，进行迭代：
```C++
#include<iostream>
using namespace std;

double varphi(double x) {return (x*x*x-1);}

int main()
{
	double x=1.25, y, z;
	cout<<"x0=1.25"<<endl;
	for(int i=1; i<=12; i++)
	{
		y=varphi(x);
		z=varphi(y);
		x=(x*z-y*y)/(x+z-2*y);
		cout<<"第 "<<i<<" 次迭代结果：y"<<i<<"="<<y<<", z"<<i<<"="<<z<<", x"<<i<<"="<<x<<endl;
	}
	return 0;
}
```
~~~
输出：
x0=1.25
第 1 次迭代结果：y1=0.953125, z1=-0.134136, x1=1.36151
第 2 次迭代结果：y2=1.52384, z2=2.53846, x2=1.33059
第 3 次迭代结果：y3=1.35578, z3=1.49211, x3=1.32488
第 4 次迭代结果：y4=1.32559, z4=1.32932, x4=1.32472
第 5 次迭代结果：y5=1.32472, z5=1.32472, x5=1.32472
~~~


- 例 11：求解方程 $f(x)=x^4-3x^3+4x^2-2x-1=0$ 在 $[1,2]$ 的根

- 解法：将方程等价变换得$$x=x^4-3x^3+4x^2-x-1=\varphi(x)$$取初值 $x_0=1.5$，进行迭代：
```C++
#include<iostream>
#include<cmath>
using namespace std;

double varphi(double x) {return (pow(x,4)-3*pow(x,3)+4*pow(x,2)-x-1);}

int main()
{
	double x=1.5, y, z;
	cout<<"x0=1.5"<<endl;
	for(int i=1; i<=4; i++)
	{
		y=varphi(x);
		z=varphi(y);
		x=(x*z-y*y)/(x+z-2*y);
		cout<<"第 "<<i<<" 次迭代结果：y"<<i<<"="<<y<<", z"<<i<<"="<<z<<", x"<<i<<"="<<x<<endl;
	}
	return 0;
}
```
~~~
输出：
x0=1.5
第 1 次迭代结果：y1=1.4375, z1=1.18678, x1=1.52075
第 2 次迭代结果：y2=1.52745, z2=1.55726, x2=1.51881
第 3 次迭代结果：y3=1.51888, z3=1.51919, x3=1.51879
第 4 次迭代结果：y4=1.51879, z4=1.51879, x4=1.51879
~~~


- 埃特肯法在第 $n$ 次迭代得到在精度允许范围内有 $y_n=z_n=x_n$ 时，可以终止迭代（即不需要比较 $x_{n}$ 与 $x_{n-1}$）


- 例 12：在两次迭代内求解方程 $x=e^{-x}$ 的根，要求精度在五位小数

- 解法：取初值 $x_0=0.5$，直接用埃特肯法进行迭代：
```C++
#include<iostream>
#include<cmath>
#define e 2.718281828459
using namespace std;

double varphi(double x) {return pow(e,-x);}

int main()
{
	double x=0.5, y, z;
	cout<<"x0=0.5"<<endl;
	for(int i=1; i<=2; i++)
	{
		y=varphi(x);
		z=varphi(y);
		x=(x*z-y*y)/(x+z-2*y);
		cout<<"第 "<<i<<" 次迭代结果：y"<<i<<"="<<y<<", z"<<i<<"="<<z<<", x"<<i<<"="<<x<<endl;
	}
	return 0;
}
```
~~~
输出：
x0=0.5
第 1 次迭代结果：y1=0.606531, z1=0.545239, x1=0.567624
第 2 次迭代结果：y2=0.566871, z2=0.567298, x2=0.567143
~~~
$$y_3=e^{-x_2}=0.567143,\ \ \ \ z_3=e^{-y_3}=0.567143$$由此判断不需要再进行第三次迭代，即能保证五位小数的精度，取方程的根为：$x=0.56714$


- 可以看到，相比于普通 $x=\varphi(x)$ 格式迭代，埃特肯加速法的收敛速度非常快，且收敛性非常强

##### 组合法：

- 取初值 $x_0$，令 $y_1=\varphi(x_0)$，并使 $x_1=\frac{x_0+y_1}{2}$，$y_2=\varphi(x_1)$，以此循环，取 $x_{n+1}=\frac{y_{n+1}+x_n}{2}$，相当于 $\alpha$ 两侧数据互补，用迭代值两两组合的方式加快收敛（埃特肯法 Aitken's Method 相当于三三组合以加快收敛）


- 例 13：求解方程 $f(x)=x-\frac{1}{x^2+1}=0$ 在区间 $[0,1]$ 的根

- 解法：直接将方程等价变换为：$$x=\frac{1}{x^2+1}=\varphi(x)$$取初值 $x_0=0.5$，进行迭代：
```C++
#include<iostream>
using namespace std;

double varphi(double x) {return 1/(x*x+1);}

int main()
{
	double x=0.5, y;
	cout<<"x0=0.5"<<endl;
	for(int i=1; i<=10; i++)
	{
		y=varphi(x);
		x=(x+y)/2.0;
		cout<<"第 "<<i<<" 次迭代结果：y"<<i<<"="<<y<<", x"<<i<<"="<<x<<endl;
	}
	return 0;
}
```
~~~
输出：
x0=0.5
第 1 次迭代结果：y1=0.8, x1=0.65
第 2 次迭代结果：y2=0.702988, x2=0.676494
第 3 次迭代结果：y3=0.686039, x3=0.681266
第 4 次迭代结果：y4=0.683002, x4=0.682134
第 5 次迭代结果：y5=0.682451, x5=0.682293
第 6 次迭代结果：y6=0.68235, x6=0.682321
第 7 次迭代结果：y7=0.682332, x7=0.682327
第 8 次迭代结果：y8=0.682329, x8=0.682328
第 9 次迭代结果：y9=0.682328, x9=0.682328
第 10 次迭代结果：y10=0.682328, x10=0.682328
~~~


##### 第二类引入参数法：

- 第一类引入参数法迭代公式为：$$x_{n+1}=\frac{1}{1-\theta}[\varphi(x_n)-\theta\cdot x_n]$$令 $\lambda=\frac{1}{1-\theta}$，则：$$x_{n+1}=\lambda[\varphi(x_n)+(\frac{1}{\lambda}-1)x_n]=x_n-(x_n-\varphi(x_n))$$取 $F(x_n)=x_n-\varphi(x_n)=0$，得：$$x_{n+1}=x_n-\lambda F(x_n),\ \ \ \ (\theta=1-\frac{1}{\lambda})$$其中 $F(x)=0$ 可由 $f(x)=0$ 适当变形得到，上述即为第二类引入参数法的迭代公式

- 在上述推导下，将方程 $f(x)=0$ 变形得到合适的 $F(x)=0$，使得在区间 $[a,b]$ 内满足：$$0\textless m\leq F^{'}(x)\leq M,\ \ \ \ F^{'}(x)\ 为\ F(x)\ 的一阶导数$$可以给出第二类引入参数法的更优迭代公式为：$$x_{n+1}=x_n-\frac{2}{M+n}F(x_n)$$即 $\lambda$ 的选取尽可能保证 $\lambda^{-1}$ 解决 $M$ 与 $m$ 的平均值


- 例 14：用第二类引入参数法求解方程 $x=e^{-x}$，$x\in[0.5,0.6]$

- 解法：取：$$f(x)=x-e^x=0\ \Rightarrow\ f^{'}(x)=1+e^{-x}$$$$m=f^{'}(0.6)=1.55,\ \ \ \ M=f^{'}(0.5)=1.61,\ \ \ \ \lambda=\frac{2}{m+M}=0.63$$迭代公式为：$$x_{n+1}=x_n-0.63(x_n-e^{-x_N})=0.37x_n+0.63e^{-x_n}$$并取迭代初值 $x_0=0.5$，进行迭代：
```C++
#include<iostream>
#include<cmath>
#define e 2.718281828459
using namespace std;

double varphi(double x) {return 0.37*x+0.63*pow(e,-x);}

int main()
{
	double x=0.5;
	cout<<"x0=0.5"<<endl;
	for(int i=1; i<=3; i++)
	{
		x=varphi(x);
		cout<<"第 "<<i<<" 次迭代结果：x"<<i<<"="<<x<<endl;
	}
	return 0;
}
```
~~~
输出：
x0=0.5
第 1 次迭代结果：x1=0.567114
第 2 次迭代结果：x2=0.567143
第 3 次迭代结果：x3=0.567143
~~~


#### 4. 基于微分的迭代方法：

##### 牛顿迭代法 Newton's Method：

- 对于方程 $f(x)=0$ 可得：$$\lambda f(x)=0\ \Rightarrow\ x=x-\lambda f(x)=\varphi(x)\ \Rightarrow\ \varphi^{'}(x)=1-\lambda\cdot f^{'}(x)$$选择 $\lambda$ 的值：令 $\vert\varphi^{'}(x)\vert\textless1$，取 $\lambda=\frac{1}{f^{'}(x)}$，尽可能使得 $\vert\varphi^{'}(x)\vert$ 接近 $1$

- 由上述式可得牛顿迭代法得到公式：$$x_{n+1}=x_n-\frac{f(x_n)}{f^{'}(x_n)}$$

- 牛顿迭代法的几何意义：对于函数 $y=f(x)$，其在 $(x_n,\ f(x_n))$ 点的切线方程与 $x$ 轴交于 $(x_{n+1},\ 0)$

- 牛顿迭代法的收敛阶数：
	- 一般情况下牛顿迭代法收敛阶数为 $r=2$
	- 当所求根是方程重根时，收敛阶数 $r=1$

- 可以用 $\vert x_{n+1}-x_n\vert\textless\epsilon$ 作为收敛条件


- 例 15：用牛顿迭代法求解方程 $x=e^{-x}$ 的根，$\alpha\in[0.5,0.6]$

- 解法：$x=e^{-x}\ \Rightarrow\ x\cdot e^x-1=0$，取 $f(x)=x\cdot e^x-1$，对其求一阶导数：$$f^{'}(x)=e^x(1+x)$$则迭代公式为：$$x_{n+1}=x_n-\frac{x_n\cdot e^{x_n}-1}{e^{x_n}(1+x_n)}=x_n-\frac{x_n-e^{-x_n}}{1+x_n}$$取迭代初值 $x_0=0.5$，进行迭代：
```C++
#include<iostream>
#include<cmath>
#define e 2.718281828459
using namespace std;

double varphi(double x) {return x-(x-pow(e,-x))/(1+x);}

int main()
{
	double x=0.5;
	cout<<"x0=0.5"<<endl;
	for(int i=1; i<=4; i++)
	{
		x=varphi(x);
		cout<<"第 "<<i<<" 次迭代结果：x"<<i<<"="<<x<<endl;
	}
	return 0;
}
```
~~~
输出：
x0=0.5
第 1 次迭代结果：x1=0.57102
第 2 次迭代结果：x2=0.567156
第 3 次迭代结果：x3=0.567143
第 4 次迭代结果：x4=0.567143
~~~


- 牛顿迭代法收敛的四大条件：若 $f(x)$ 在 $[a,b]$ 上二阶导数存在，则牛顿迭代法若要收敛，必须满足：
	- 1. $f(a)\cdot f(b)\textless0$（区间 $[a,b]$ 内有根）
	- 2. $\forall x\in(a,b)$，有 $f^{'}(x)\neq0$（函数单调变化）
	- 3. $\forall x\in(a,b)$，有 $f^{''}(x)$ 不变号（$[a,b]$ 上 $f(x)$ 图形凹凸方向不变）
	- 4. $f(x_i)\cdot f^{''}(x_i)\textgreater0$（每一个迭代值均在 $[a,b]$ 内）


##### 三阶迭代：

- 扩展牛顿迭代法，可以得到更高阶数的迭代公式，其三阶迭代公式为：$$x_{n+1}=x_n-\frac{f(x_n)}{f^{'}(x_n)}-\frac{[f(x_n)]^2\cdot f^{''}(x_n)}{2[f^{'}(x_n)]^3}$$

##### 简化切线法：

- 将牛顿迭代法中 $f^{'}(x_n)$ 变为 $f^{x_0}$，减少导数代值计算，得到简化切线法（又称“固定斜率的切线法”）：$$x_{n+1}=x_n-\frac{f(x_n)}{f^{'}(x_0)}$$

- 简化迭代法的几何意义：对于函数 $y=f(x)$，过 $(x_n,\ f(x_n))$ 点且斜率恒为 $f^{'}(x_0)$ 的直线方程与 $x$ 轴交于 $(x_{n+1},\ 0)$

- 推广可取 $x_{n+1}=x_n-\frac{f(x_n)}{C}$，$C$ 是常熟，此时若要收敛需满足：$$\vert\psi^{'}(x)\vert=\vert1-\frac{f^{'}(x)}{C}\vert\textless1\ \Rightarrow\ 0\textless\frac{f^{'}(x)}{C}\textless2$$即当 $C$ 与 $f^{'}(x)$ 同号且 $0\textless\frac{f^{'}(x)}{C}\textless2$ 时，推广的简化切线法收敛

- 修正的切线法：$$x_{n+1}=x_n-\frac{f(x_n)}{f^{'}(x_m)},\ \ \ \ x_m\ 是某一中间迭代结果$$

##### 牛顿下山法 Newton Down-Hill Method：

- 牛顿迭代法收敛性太依赖于初值 $x_0$ 的选取，故引入参数 $\lambda$：$$x_{n+1}=x_n-\lambda\frac{f(x_n)}{f^{'}(x_n)}$$目的是达到 $\vert f(x_0)\vert\textgreater\vert f(x_1)\vert\textgreater\cdots$ 单调下降效果，其中 $\lambda$ 为“下山因子”，$\vert f(x_{n+1})\vert\textless\vert f(x_n)\vert$ 为“下山条件”

- 当满足下山条件时继续迭代，若不满足则重新取 $\lambda$ 值直至满足

- “下山”的目的是扩大可选 $x_0$ 范围，使迭代更易收敛，人为“下坡”（其实质是让直线斜率绝对值变大）

- $\lambda$ 的选取：$[\epsilon_1,1]$ 内选值，可依次取 $1,\ \frac{1}{2},\ \frac{1}{4},\ \frac{1}{8},\cdots,\frac{1}{2^r}\textgreater\epsilon_1$（这里设定下限 $\epsilon_1$ 的目的是防止 $\lambda$ 过小将直线斜率绝对值放得太大，使 $x_{n+1}$ 与 $x_n$ 过于相近）

- 如果上述序列中没有可以满足下山条件的 $\lambda$ 值，则应另选初值 $x_0$，重新迭代

- “下山”调试的简化：$$x_{n+1}=x_n-\lambda\frac{f(x_n)}{f^{'}(x_n)}+\lambda x_n-\lambda x_n=\lambda[x_n-\frac{f(x_n)}{f^{'}(x_n)}]+(1-\lambda)x_n$$令：$$y_{n+1}=x_n-\frac{f(x_n)}{f^{'}(x_n)}$$得：$$x_{n+1}=\lambda y_{n+1}+(1-\lambda)x_n$$这是一次切线法中新旧迭代值 $y_{n+1}$ 和 $x_n$ 按 $\lambda$ 与 $(1-\lambda)$ 的线性组合公式


- 例 16：求解方程 $f(x)=x^3-x-1=0$ 在 $[0,1.5]$ 上的根（取迭代初值为 $x_0=0.6$），精确到四位小数

- 解法：由于牛顿迭代法收敛条件四不成立：$$f(x_0)\cdot f^{''}(x_0)=f(0.6)\times f^{''}(0.6)\textgreater0$$故直接使用牛顿迭代法不收敛，此时需要“下山”调节，取 $y_1=x_0-\frac{f(x_0)}{f^{'}(x_0)}=17.9$，利用 $$x_{n+1}=\lambda y_1+(1-\lambda)x_0$$进行迭代：$$取\ \lambda=\frac{1}{2}\ \to\ x_1=9.25\ \Rightarrow\ \vert f(9.25)\vert\textgreater\vert f(x_0)\vert\ \Rightarrow\ 不满足下山条件$$$$再取\ \lambda=\frac{1}{8}\ \to\ x_1=2.7625\ \Rightarrow\ \vert f(2.7625)\vert\textgreater\vert f(x_0)\vert\ \Rightarrow\ 不满足下山条件$$$$再取\ \lambda=\frac{1}{2^5}\ \to\ x_1=1.140625\ \Rightarrow\ \vert f(1.140625)\vert\textless\vert f(x_0)\vert\ \Rightarrow\ 满足下山条件$$此时用 $x_1=1.140625$ 在 $x_{n+1}=x_n-\frac{f(x_n)}{f^{'}(x_n)}$ 中迭代即可，得：$$x_2=1.366814,\ \ (\vert f(x_2)\vert\textless\vert f(x_1)\vert),\ \ \ \ x_3=1.32628,\ \ (\vert f(x_3)\vert\textless\vert f(x_2)\vert)$$$$x_4=1.32472,\ \ \vert f(x_4)\vert\textless\vert f(x_3)\vert,\ \ \ \ x_5=1.32472$$已经达到五位小数一致的结果，可以取精确到四位小数的解：$x=1.3247$


#### 5. 基于差分的迭代方法：

##### 单点弦截法：

- 为避免牛顿迭代法中一阶导数 $f^{'}(x_n)$ 的计算，可用割线斜率代切线斜率：$$f^{'}(x_k)\approx\frac{f(x_k)-f(x_0)}{x_k-x_0}$$由此可得单点弦截法迭代公式：$$x_{n+1}=x_n-\frac{f(x_n)}{f(x_n)-f(x_0)}(x_n-x_0)$$

- 单点弦截法的几何意义即在牛顿迭代法的基础上以割线代切线：$(x_0,f(x_0))$ 处一个不动点 $A$，和 $(x_n,f(x_n))$ 处一个迭代动点 $B$，直线 $\overline{AB}$ 即为割线

- 单点弦截法四大收敛条件：若 $f(x)$ 在 $[a,b]$ 上二阶导数存在，且：
	- 1. $f(a)\cdot f(b)\textless0$
	- 2. $f^{'}(x)\neq0$
	- 3. $f^{''}(x)$ 不变号
	- 4. 不动点 $x_0$ 满足 $f(x_0)\cdot f^{''}(x_0)\textgreater0$，$x_1$ 与 $x_0$ 点的函数值相异（保证各迭代值在 $\alpha$ 左右“摆动”）
上述四大条件下，单点弦截法收敛


- 例 17：求解方程 $f(x)=x\cdot e^x-1=0$ 的根，$\alpha\in[0.5,0.6]$

- 解法：$$f(x)=x\cdot e^x-1,\ \ \ \ f^{'}(x)=e^x(1+x),\ \ \ \ f^{''}(x)=e^x(2+x)$$有：$$f(0.5)\cdot f^{''}(0.5)\textless0,\ \ \ \ f(0.6)\cdot f^{''}(0.6)\textgreater0$$因此应当取 $[0.6,f(0.6)]$ 为不动点，另一端点取 $x_1=0.5$，进行迭代：
```C++
#include<iostream>
#include<cmath>
#define e 2.718281828459
using namespace std;

double varphi(double x) {return x*pow(e,x)-1;}

int main()
{
	double x=0.5;
	cout<<"x0=0.5, x1=0.6"<<endl;
	for(int i=2; i<=6; i++)
	{
		x=(0.6*varphi(x)-x*varphi(0.6))/(varphi(x)-varphi(0.6));
		cout<<"第 "<<i<<" 次迭代结果：x"<<i<<"="<<x<<endl;
	}
	return 0;
}
```
~~~
输出：
x0=0.5, x1=0.6
第 2 次迭代结果：x2=0.565315
第 3 次迭代结果：x3=0.567095
第 4 次迭代结果：x4=0.567142
第 5 次迭代结果：x5=0.567143
第 6 次迭代结果：x6=0.567143
~~~


- 单点弦截法具有线性收敛性，即收敛阶数 $r=1$

##### 双点弦截法：

- 用双点割线斜率代表切线斜率：$$f^{'}(x_k)\approx\frac{f(x_k)-f(x_{k-1})}{x_k-x_{k-1}}$$由此得双点弦截法迭代公式：$$x_{n+1}=x_n-\frac{f(x_n)}{f(x_n)-f(x_{n-1})}(x_n-x_{n-1})$$

- 双点弦截法的收敛阶数为：$r=1.618$

- 注意：双点弦截法的初值是 $x_0$ 和 $x_1$ 两点

- 双点弦截法的收敛条件：若 $f(x)$ 在 $[a,b]$ 上二阶导数连续，且：
	- 1. $f(a)\cdot f(b)\textless0$
	- 2. $f^{'}(x)\neq0$
则双点弦截法收敛


- 例 18：求解方程 $f(x)=x\cdot e^x-1=0$ 的根，$\alpha\in[0.5,0.6]$

- 解法：用双点弦截法，取初值 $x_0=0.6$，$x_1=0.5$，迭代公式为：$$x_{n+1}=x_n-\frac{f(x_n)}{f(x_n)-f(x_{n-1})}(x_n-x_{n-1})=\frac{x_{n-1}f(x_n)-x_n f(x_{n-1})}{f(x_n)-f(x_{n-1})}$$进行迭代：
```C++
#include<iostream>
#include<cmath>
#define e 2.718281828459
using namespace std;

double varphi(double x) {return x*pow(e,x)-1;}

int main()
{
	double x=0.6, x1=0.5;
	cout<<"x0=0.6, x1=0.5"<<endl;
	for(int i=2; i<=6; i++)
	{
		double p=x1;
		x1=(x*varphi(x1)-x1*varphi(x))/(varphi(x1)-varphi(x));
		x=p;
		cout<<"第 "<<i<<" 次迭代结果：x"<<i<<"="<<x1<<endl;
	}
	return 0;
}
```
~~~
输出：
x0=0.6, x1=0.5
第 2 次迭代结果：x2=0.565315
第 3 次迭代结果：x3=0.567246
第 4 次迭代结果：x4=0.567143
第 5 次迭代结果：x5=0.567143
第 6 次迭代结果：x6=0.567143
~~~


#### 6. 反解构造法：

##### 反函数的导数：

- 若 $f(x)$ 与 $\psi(x)$ 互为反函数，则 $y=f(x)$ 反解得 $x=\psi(y)$，如果 $f(x)$ 与 $\psi(y)$ 以下相应阶导数均存在，则有：$$一阶导数：\psi^{'}(y)=\frac{dx}{dy}=\frac{1}{\frac{dy}{dx}}=\frac{1}{f^{'}(x)}$$$$二阶导数：\psi^{''}(y)=\frac{d}{dy}\frac{1}{f^{'}(x)}=\frac{-f^{''}(x)\cdot\frac{dx}{dy}}{[f^{'}(x)]^2}=-\frac{f^{''}(x)}{[f^{'}(s)]^2\frac{dy}{dx}}=-\frac{f^{''}(x)}{[f^{'}(x)]^3}$$

##### 反解构造法：

- $\vert \varphi^{'}(x)\vert\textgreater1$ 的处理：假设 $f(x)=0$ 分解后的 $x=\varphi(x)$ 有 $\vert\varphi^{'}(x)\vert\geq k\textgreater1$，$x\in[a,b]$，此时迭代过程有可能是发散的（由于是收敛充分条件为满足，所以只是有可能发散），故将 $x=\varphi(x)$ 的 $\varphi(x)$ 中 $x$ 反解出 $x=\psi(x)$

- $\varphi(x)$ 和 $\psi(x)$ 互为反函数，故一阶导数：$$\psi^{'}(x)=\frac{1}{\varphi^{'}(x)}\ \Rightarrow\ \vert\psi^{'}(x)\vert\leq\frac{1}{k}\textless1$$由此可知此时 $x_{n+1}=\psi(x_n)$ 迭代必收敛


- 例 19：迭代求解方程 $x=e^x-1.30=\varphi(x)$ 在 $[0,1]$ 的根，结果保留五位小数

- 解法：$\varphi^{'}(x)=e^x$，在 $[0,1]$ 上有 $\vert\varphi^{'}(x)\vert\geq1$，不满足收敛充分条件，则考虑反解迭代法，求解反函数：$$x=e^x-1.30=\varphi(x)\ \Rightarrow\ x=\ln{(x+1.30)}=\psi(x)$$得到的迭代公式一定收敛：$$x_{n+1}=\ln{(x_n+1.30)}$$取迭代初值为 $x_0=0.1$，进行迭代：
```C++
#include<iostream>
#include<cmath>
#define e 2.718281828459
using namespace std;

double psi(double x) {return log(x+1.30);}

int main()
{
	double x=0.1;
	cout<<"x0=0.1"<<endl;
	for(int i=1; i<=25; i++)
	{
		x=psi(x);
		cout<<"第 "<<i<<" 次迭代结果：x"<<i<<"="<<x<<endl;
	}
	return 0;
}
```
~~~
输出：
x0=0.1
第 1 次迭代结果：x1=0.336472
第 2 次迭代结果：x2=0.492543
第 3 次迭代结果：x3=0.583635
第 4 次迭代结果：x4=0.633204
第 5 次迭代结果：x5=0.659178
第 6 次迭代结果：x6=0.672525
第 7 次迭代结果：x7=0.679315
第 8 次迭代结果：x8=0.682751
第 9 次迭代结果：x9=0.684485
第 10 次迭代结果：x10=0.685359
第 11 次迭代结果：x11=0.6858
第 12 次迭代结果：x12=0.686022
第 13 次迭代结果：x13=0.686134
第 14 次迭代结果：x14=0.68619
第 15 次迭代结果：x15=0.686218
第 16 次迭代结果：x16=0.686232
第 17 次迭代结果：x17=0.68624
第 18 次迭代结果：x18=0.686243
第 19 次迭代结果：x19=0.686245
第 20 次迭代结果：x20=0.686246
第 21 次迭代结果：x21=0.686246
第 22 次迭代结果：x22=0.686247
第 23 次迭代结果：x23=0.686247
第 24 次迭代结果：x24=0.686247
第 25 次迭代结果：x25=0.686247
~~~
取解 $x=0.68625$


- 例 20：求解方程 $x=-\ln{x}=\varphi(x)$ 的根，结果保留五位小数，$\alpha\in[0.5,0.6]$

- 解法：$\varphi^{'}(x)=-\frac{1}{x}$，在 $[0.5,0.6]$ 上不满足 $\vert\varphi^{'}(x)\vert\textless1$，故用 $x_{n+1}=\varphi(x_n)$ 迭代有可能不收敛，考虑反解构造法，求解反函数：$$x=e^{-x}$$得到的迭代公式一定收敛：$$x_{n+1}=e^{-x_n}$$取迭代初值为 $x_0=0.5$，进行迭代：
```C++
#include<iostream>
#include<cmath>
#define e 2.718281828459
using namespace std;

double psi(double x) {return pow(e,-x);}

int main()
{
	double x=0.5;
	cout<<"x0=0.5"<<endl;
	for(int i=1; i<=25; i++)
	{
		x=psi(x);
		cout<<"第 "<<i<<" 次迭代结果：x"<<i<<"="<<x<<endl;
	}
	return 0;
}
```
~~~
输出：
x0=0.5
第 1 次迭代结果：x1=0.606531
第 2 次迭代结果：x2=0.545239
第 3 次迭代结果：x3=0.579703
第 4 次迭代结果：x4=0.560065
第 5 次迭代结果：x5=0.571172
第 6 次迭代结果：x6=0.564863
第 7 次迭代结果：x7=0.568438
第 8 次迭代结果：x8=0.566409
第 9 次迭代结果：x9=0.56756
第 10 次迭代结果：x10=0.566907
第 11 次迭代结果：x11=0.567277
第 12 次迭代结果：x12=0.567067
第 13 次迭代结果：x13=0.567186
第 14 次迭代结果：x14=0.567119
第 15 次迭代结果：x15=0.567157
第 16 次迭代结果：x16=0.567135
第 17 次迭代结果：x17=0.567148
第 18 次迭代结果：x18=0.567141
第 19 次迭代结果：x19=0.567145
第 20 次迭代结果：x20=0.567142
第 21 次迭代结果：x21=0.567144
第 22 次迭代结果：x22=0.567143
第 23 次迭代结果：x23=0.567143
第 24 次迭代结果：x24=0.567143
第 25 次迭代结果：x25=0.567143
~~~
取解 $x=0.56714$

