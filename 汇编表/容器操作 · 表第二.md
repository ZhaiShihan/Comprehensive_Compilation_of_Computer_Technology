### 壹  string 容器

###### 零、输入输出操作
```C++
1. cin>>a;    //输入字符串 a
2. std::getline(std::cin, a);    //输入字符串 a
3. cout<<a; 或 std::cout<<a;    //输出字符串 a
```

###### 一、字符串的创建与赋值
```C++
1. string a;    //创建一个名为 a 的字符串
2. string::std a(int n, char c);    //将 a 的前 n 位赋值为字符“c”
3. string::std b(a);    //用字符串 a 给 b 赋值
4. string::std a("hello");    //将 “hello” 赋值给字符串 a
```

###### 二、存取字符操作
```C++
1. char a=str[i];    // a 取 str 这个字符串的第 i +1 个字符
2. char a=str.at(i);    // a 取 str 这个字符串的第 i +1 个字符，如果访问越界会抛出异常
```

###### 三、拼接操作
```C++
1. a.operator+=(b); 或 a+=b;    //将字符串 b 拼接到 a 的尾部
   a.operator+=('c') 或 a+='c';    //将字符“c”拼接到字符串 a 的尾部
2. a.append(b);    //将字符串 b 拼接到字符串 a 的尾部
3. a.append(b, int n);    //把字符串 b 的前 n 个字符拼接到 a 的尾部
4. a.append(b, int pos, int n);    //把字符串 b 从 b[pos] 开始到 b[pos+n-1] 拼接到 a 末尾
5. a.append(int n, char c);    //在字符串 a 的结尾添加 n 个字符 c
6. a.push_back(char c);    //在字符串 a 的末尾添加字符 c
```

###### 四、查找和替换
```C++
1. int p=a.find(b);    //在字符串 a 中查找字符串 b 首次出现的位置，返回位置的值
//说明：如果没有找到 b，则返回值为 std::string::npos（用“p==std::string::npos”判定未找到）
2. int p=a.find('c');    //在字符串 a 中查找字符“c”第一次出现的位置
3. int p=a.rfind(b);    //在字符串 a 中查找字符串 b 最后一次出现的位置，返回位置的值
4. a.replace(int pos, int n, "hello");    //从 a[pos] 开始数 n 个字符，这个字符替换成 “hello”
   a.replace(int pos, int n, b);    //从 a[pos] 开始数 n 个字符，这个字符替换成字符串 b
```

###### 五、比较操作
```C++
1. int p=a.compare(b);    //将字符串 a 与字符串 b 进行比较
//说明：当返回值 p>0（一般是1），说明 a>b；当返回值 p=0，说明 a=b；当返回值 p<0（一般是-1），说明 a<b
2. a<b 或 a==b 或 a>b    //可以直接在判断语句中使用，用于判别字符串的大小关系
```

###### 六、插入和删除操作
```C++
1. a.insert(int i, b);    //在 a[i] (第i+1个字符) 之前插入字符串 b
2. a.insert(int i, int num, char c);    //在 a[i] (第i+1个字符) 之前插入 num 个字符 c
3. a.erase(int pos, int n);    //删除从 a[pos] 开始的 n 个字符（a[pos]~a[pos+n-1]）
4. a.clear();    //将字符串 a 清空成空字符串
5. a.pop_back();    //删除字符串 a 末尾的字符
6. string::std b=a.substr(int pos, int n);    //子串提取
//说明：提取从 a[pos] 开始的 n 个字符（到a[pos+n-1]）作为子串 b
```

###### 七、长度统计
```C++
1. int p=a.length(); 或 int p=a.size();    //返回值 p 为字符串 a 的长度
2. int p=a.empty();    //检察字符串 a 是否为空：空-1，非空-0
```


### 贰  vector 容器

###### 零、输入输出操作
```C++
1. vec.resize(int n);    //重新定义 vec 的大小为 n
2. for(int i=0; i<n; i++) cin>>vec[i];    //循环输入
3. for(auto &a: vec) cin>>a;    //循环全输入（ auto 前面不能加 conost ）
4. for(int i=0; i<n; i++) cout<<vec[i]<<' ';    //循环输出
5. for(const auto &a: vec) cout<<a<<' ';    //循环全输出（如果只读不修改，const 可去掉）
```

###### 一、向量的初始化声明
```C++
1. std::vector <int> vec; 或 vector <int> vec;    //空的整数向量
2. std::vector <int> vec(int n);    //创建一个整数向量，包含 n 个元素（默认全是 0 ）
3. std::vectpr <int> vec(int n, int data);    //创建一个整数向量，包含 n 个元素，每个值都是 data
4. std::vector <int> vec{1, 2, 3, 4, 5};    //使用初始化列表初始化向量
5. std::vector <int> vec_1 (vec);    //用 vec 给 vec_1 向量赋值
6. std::vector <int> vec_1 (vec.begin()+i, vec.end()-j);    //用 vec 的区间给 vec_1 赋值
```

###### 二、访问元素
```C++
1. int element=vec[2];    //访问第三个元素
2. int element=vec.front();    //访问第一个元素
3. int element=vec.back();    //访问最后一个个元素
```

###### 三、插入和删除元素
```C++
1. vec.push_back(int data);    //在向量末尾插入元素 data
//说明：注意这类的操作都是在原来容量大小基础上扩容的，比如 vec.resize(n); 后插 m 个元素，则容量变为 n+m
2. vec.insert(vec.begin()+n, int data);    //在 vec[n] 之前插入元素 data
3. vec.pop_back();    //删除向量 vec 末尾的元素
4. vec.erace(vec.begin()+n);    //删除 vec[n] 这个元素（后继“顶上”，不会出现空洞）
5. vec.clear();    //清空向量，得到空向量
6. vec[n]=k;    //修改元素值：令 vec[n] 的值为 k
```

###### 四、获取向量信息
```C++
1. int p=vec.size();    //获取向量长度
2. bool b=vec.empty();    //判断向量 vec 是否为空：空-true；非空-false
```

###### 五、向量的互换与自置逆
```C++
1. vec_1.swap(vec);    //交换两个向量的内容
2. std::reserve(vec.begin()+i, vec.end()-j);    //将向量 vec[i] 到 vec[n-j-1] 原地置逆
//说明1：这个置逆是相对于整个向量空间（resize 开辟出的）而言的，而不是以局部的输入为整体
//说明2：std::reverse 的调用需要引用头文件：#include<algorithm>
```


### 叁  deque 容器

###### 零、输入输出操作
```C++
1. for(int i=0; i<n; i++) cin>>deq[i];    //循环输入
2. for(auto &a: vec) cin>>a;    //循环全输入（ auto 前面不能加 conost ）
3. for(int i=0; i<n; i++) cout<<deq[i]<<' ';    //循环输出
4. for(const auto &a: vec) cout<<a<<' ';    //循环全输出（如果只读不修改，const 可去掉）
```

###### 一、双端队列的创建
```C++
1. std::deque <int> deq; 或 deque <int> deq;    //创建双端队列
2. std::deque <int> deq(std::begin(arr), std::end(arr));    //用数组 arr 给双端队列 deq 赋值
//说明：最后 deq 的长度由开辟空间决定，不由 arr 的长度决定，deq 的空位均补 0
3. std::deque <int> deq(int n, int data);    //创建双端队列 deq，内含 n 个元素均为 data
   deq.assign(int n, int data);
4. std::deque <int> deq_1(deq);    //用双端队列 deq 给 deq_1 赋值
5. deq.assign(arr, arr+n);    //用数组 arr[0] 到 arr[n] 给 deque 赋值
6. deq_1=deq;    //用双端队列 deq 直接给 deq_1 全盘赋值
```

###### 二、大小操作
```C++
1. deq.resize(int n);    //重新调整双端队列 deq 的大小为 n
2. deq.resize(int n, int data);    //重新调整 deq 大小为 n，如果多空位则由 data 补全，缺位则删尾
3. int p=deq.size();    //返回值为双端队列 deq 的大小，这个大小与输入元素个数无关，与开辟空间大小有关
4. bool b=deq.empty();    //判断双端队列 deq 是否为空：空-true；非空-false
```

###### 三、数据存取
```C++
1. int p=deq[i];    //访问双端队列 deq 的第 i+1 个值
2. int p=deq.at(i);    //访问双端队列 deq 的第 i+1 个值，如果访问越界，抛出异常：std::out_of_range
3. int p=deq.front();    //访问双端队列 deq 的第一个元素
4. int p=deq.end();    //访问双端队列 deq 的最后一个元素
```

###### 四、插入和删除操作
```C++
1. deq.insert(deq.begin()+i, int k);    //将元素 k 插入 deq[i] 之前（有迭代器返回值）
2. deq.insert(deq.begin()+i, int n, int k);    //将 n 个元素 k 插入 deq[i] 之前（无返回值）
3. deq.insert(deq.begin()+i, deq_1.begin(), deq_1.end());
//将 deq_1 的对应区间插入 deq[i] 之前（无返回值）
4. deq.erase(deq.begin()+i, deq.begin()+j);    //删除 deq[i~j] 这个区间（返回下一元素位置迭代器）
5. deq.erase(int i);    //删除 deq[i] 的值（返回下一元素位置迭代器），后继“顶上”，不会出现空缺
6. deq.clear();    //清空双端队列 deq，得到一个空的双端队列
```

###### 五、双端插入和删除操作
```C++
1. deq.push_back(elem);    //在双端队列 deq 的尾部添加一个元素 elem
2. deq.push_front(elem);    //在双端队列 deq 的头部添加一个元素 elem
3. deq.pop_back();    //删除双端队列 deq 的队尾
4. deq.pop_front();    //删除双端队列 deq 的队头
```

###### 六、双端队列的互换与自置逆
```C++
1. deq_1.swap(deq);    //将双端队列 deq 与 deq_1 互换
2. std::reverse(deq.begin()+i, deq.end()-j);    //将向量 deq[i] 到 deq[n-j-1] 原地置逆
//说明1：这个置逆是相对于整个双端队列空间（resize 开辟出的）而言的，而不是以局部的输入为整体
//说明2：std::reverse 的调用需要引用头文件：#include<algorithm>
```


### 肆  list 容器

###### 零、输入输出操作
```C++
1. for(auto &a: List) cin>>a;    //循环全输入
2. for(const auto &a: List) cout<<a<<' ';    //循环全输出
3. 如果实现局部输入，可以使用循环插入 List.insert(elem) 或循环尾部弹入 List.push_back()；
4. 如果实现局部输出，可以使用：
	auto it=List.begin();
	for(int i=0; i<n; i++)
	{
		cout<<*it<<' ';
		it++;
	}
```

###### 一、双向链表的创建与赋值
```C++
1. std::list <int> List 或 list <int> List;    //构造双向链表 List
2. std::list <int> L_1(List);    //用双向链表 List 给 L_1 赋值
3. std::list <int> List={1, 2, 3};    //对双向链表 List 赋值
4. std::list <int> List(arr+i, arr+j);    //用 arr[i~j] 给双向链表 List 赋值
5. std::list <int> List(int n, int data);    //用 n 个元素 data 给双向链表 List 赋值
6. List.assign(vec.begin()+i, vec.begin()+j);    //用区间 vec[i~j] 给 List 赋值
7. List.assign({1, 2, 3, 4, 5});    // List 的赋值
8. List.assign(int n, int data);    //用 n 个元素 data 给双向链表 List 赋值
9. L_1=List;    //用双向链表 List 给 L_1 赋值
```

###### 二、大小操作
```C++
1. int p=List.size();    //返回 List 的大小（与开辟大小有关，与输入无关）
2. bool b=List.empty();    //判断 List 是否为空：空-true；非空-false
3. List.resize(int n);    //调整双向链表 List 的大小为 n
4. List.resize(int n, elem);    //调整双向链表 List 的大小为 n，用 elem 补余（开辟空间不够则删尾）
```

###### 三、数据的存储和访问
```C++
注意：int p=List[i]; 或 int p=List.at(i); list不支持！
1. int p=List.front();    //访问双向链表 List 的首个元素
2. int p=List.back();    //访问双向链表 List 的末尾元素
3. 如果实现任意元素访问，可以使用迭代器访问地址：
	auto it=List.begin();
	std::advance(it, i);    //移动迭代器到第 i+1 个元素
```

###### 四、插入和删除操作
```C++
1. List.push_back(elem);    //双向链表 List 尾部弹入一个元素 elem
2. List.push_front(elem);    //双向链表 List 开头插入一个元素 elem
3. List.pop_back();    //删除双向链表 List 末尾元素
4. List.pop_front();    //删除双向链表 List 开头元素
5. List.insert(List.begin()+i, elem);    //将元素 elem 插入第 i+1 个元素之前（返回迭代器）
6. List.insert(List.begin()+i, int n, elem);    //将 n 个 elem 插入第 i+1 个元素之前（无返回值）
7. List.insert(List.begin()+i, R.begin(), R.end());
//将容器 R 的区间插入双向链表 List 第 i+1 个元素之前（无返回值）
8. List.erase(List.begin()+i, List.begin()+j);    //删除 List 从第 i+1 到第 j+1 个元素
9. List.erase(i);    //删除 List 中第 i+1 个元素
10. List.remove(int data);    //删除所有值为 data 的元素
11. List.clear();    //清空双向链表 List，得到空双向链表
```

###### 五、互换、自反转与排序
```C++
1. List.reverse();    //反转双向链表 List
2. std::reverse(List.begin()+i, List.begin()+j);    //反转 List 中第 i+1 到第 j+1 之间的元素
3. L_1.swap(List);    //将双向链表 List 与 L_1 内容互换
4. List.sort();    //双向链表 List 升序排序
5. List.sort(std::greater<int>());    //双向链表 List 降序排列
```


### 伍  set 容器

###### 零、输入输出操作
```C++
1. set 容器的输入只能用这样的方式：
	for(int i=0; i<n; i++)
	{
		int a;
		scanf("%d",&a);
		Set.insert(a);
	}
2. Set 容器的输出：
	for(const auto &a: Set) cout<<a<<' ';
```

###### 一、集合的创建与赋值
```C++
1. std::set <int> Set; 或 set <int> Set;    //创建集合 Set（不允许有重复元素）
2. std::multiset <int> MSet; 或 multiset <int> MSet;    //创建可重复集合 Mset（允许有重复元素）
3. std::set <int> S_1(Set);    //用集合 Set 给 S_1 赋值
4. S_1=Set;    //将集合 Set 赋值给集合 S_1;
5. set <int> Set={1, 3, 5, 2, 6 ,7 ,4};    //给集合 Set 赋值
//注意：这些元素存入 Set 后，它们的顺序将变为升序：{1, 2, 3, 4, 5, 6, 7}
```

###### 二、大小操作
```C++
1. int p=Set.size();    //返回集合 Set 的大小
2. bool b=Set.empty();    //判断集合 Set 是否为空：空-true；非空-false
```

###### 三、查找操作
```C++
1. auto it=Set.find(elem);    //返回 elem 的位置迭代器
2. int p=MSet.count(elem);    //统计可重复集合 MSet 中 elem 的个数
3. auto it=Set.lower_bound(k);    //返回第一个大于等于 k 的元素的迭代器
4. auto it=Set.upper_bound(k);    //返回第一个大于 k 的元素的迭代器
5. auto range=equal_range(k);    //返回等于 k 的元素的范围的迭代器（首尾位置）
//说明：这里 range 的数据类型是对组 pair
```

###### 四、插入和删除操作
```C++
1. Set.insert(elem);    //插入元素 elem（自动排序，故不需要指定插入位置）
2. Set.erase(k);    //删除集合 Set 中值为 k 的元素
3. Set.erase(Set.begin()+i, Set.begin()+j)    //删除第 i+1 到第 j+1 个元素之间这个区间
4. Set.erase(auto it);    //删除集合 Set 中位置为 it（迭代器）的元素，后继“顶上”来补空余
5. Set.clear();    //清空集合 Set，得到一个空集合
```

###### 五、互换操作
```C++
1. S_1=swap.(Set);    //交换集合 Set 与 S_1 中的内容
```


### 陆  stack 容器

###### 零、栈的输入输出
```C++
1. 栈的输入只能靠压栈（或循环压栈）完成
2. 栈的输出只能靠每次取栈顶输出（借助循环弹出栈顶）
```

###### 一、栈的创建与赋值
```C++
1. std::stack <int> S; 或 stack <int> S;    //创建一个名为 S 的栈
2. std::stack <int> S_1(S);    //将栈 S 的内容拷贝给栈 S_1
3. S_1=S;    //用栈 S 给栈 S_1 赋值
```

###### 二、数据存取操作
```C++
1. S.push(elem);    //向栈顶弹入元素 elem
2. S.pop();    //栈顶元素弹出
3. int p=S.top();    //返回栈顶元素
```

###### 三、大小操作
```C++
1. int p=S.size();    //返回栈 S 的空间大小（随 push 和 pop 的操作而变动）
2. bool b=S.empty();    //判断栈 S 是否为空：空-true；非空-false
```

###### 四、清空与互换
```C++
1. S.clear();    //清空栈 S，得到一个空的栈
2. S_1.swap(S);    //将栈 S 与另一个栈 S_1 交换
```


### 柒  queue 容器

###### 零、队列的输入与输出
```C++
1. 队列的输入只能从队尾弹入元素（或循环弹入）完成
2. 队列的输出只能靠每次取队头输出（借助循环弹出队头）
```

###### 一、队列的创建与赋值
```C++
1. std::queue <int> Q; 或 queue <int> Q;    //创建一个名为 Q 的队列
2. std::queue <int> Q_1(Q);    //将队列 Q 的内容拷贝给新队列 Q_1
3. Q_1=Q;    //用队列 Q 给队列 Q_1 赋值
```

###### 二、数据存取操作
```C++
1. Q.push(elem);    //向队尾添加一个元素
2. Q.pop();    //弹出队头元素
3. int p=Q.back();    //返回队尾元素的值
4. int p=Q.front();    //返回队头元素的值
```

###### 三、大小操作
```C++
1. int p=Q.size();    //返回队列 Q 的空间大小（随 push 和 pop 的操作而变动）
2. bool b=Q.empty();    //判断队列 Q 是否为空：空-true；非空-false
```

###### 四、清空与互换
```C++
1. Q.clear();    //清空队列 Q，得到一个空队列
2. Q_1.swap(Q);    //将队列 Q 与队列 Q_1 交换
```


### 捌  map 容器

###### 零、输入和输出操作
```C++
1. 输入：借助赋值或插入（或循环赋值、插入）实现
2. 输出：cout<<Map["apple"]<<endl;
```

###### 一、创建与赋值操作
```C++
1. std::map <int, char> Map; 或 map <int, char> Map;
//创建名为 Map 的关联容器，其中每一个元素都是一个对组 pair，这里的 pair 键为 int 型，值为 char 型
//说明：对组的键和值可以是任何数据类型，可以是 string，可以是 char，可以是 long int 等
2. std::map <int, char> M_1(M);    //用map M 给 M_1 赋值（注意这两个 map 必须是完全同类型的）
3. 插入键值对，可以直接进行赋值操作：
例1：
	std::map <string, int> Map;
	Map["apple"]=2;    //这行程序代表直接向 Map 插入了一个对组元素：< "apple", 2 >
例2：
	std::map <int, char> Map;
	Map[6]='s';    //这行程序代表直接向 Map 插入了一个对组元素：< 6, 's' >，而不是给第七位元素赋值
4. M_1=Map;    //用关联容器 Map 给 M_1 赋值（注意 M_1 和 Map 必须是完全同类型的）
5. std::multimap <int, char> MMap;    //创建可重复的multimap：MMap 中的对组均可以同键不同值
```

###### 二、大小操作
```C++
1. int p=Map.size();    //返回 Map 中对组的数目
2. bool b=Map.empty();    //判断 Map 是否为空：空-true；非空-false
```

###### 三、访问与查找操作
```C++
1. 访问时可以直接访问键 key 来得到值 value：
例1：
	/* Map 中的对组都是 <string, int> */
	int p=Map["apple"];    //直接得到字符串“apple”所对应的值是多少
例2：
	/* Map 中的对组都是 <int, char> */
	char c=Map[6];    //直接得到键值为 6 的对组的实值，注意这不是访问 Map 中第七位元素
2. auto it=Map.find(key);    //查找键为 key 的对组的位置，返回迭代器（若不存在则返回 Map.end() ）
3. int p=Map.const(key);    //返回键为 key 的所有对组的个数
4. auto it=lower_bound(key);    //返回第一个键大于等于 key 的对组的迭代器（位置）
5. auto it=upper_bound(key);    //返回第一个键大于 key 的对组的迭代器（位置）
6. auto range=euqal_range(kay);    //返回键等于 key 的对组的位置区间迭代器，range 也是一个对组
```

###### 四、数据的插入操作
```C++
1. Map.insert( {"apple", 2} );    //插入键值对 <"apple", 2> （注意花括号，不可以直接插"< >"形式）
   Map.insert(std::make_pair("apple", 2)); 或 Map.insert(make_pair("apple", 2));
//说明：对于第二行的插入方式，其中 make_pair(string s, int p) 代表创建一个对组，是一个函数
```

###### 五、删除操作
```C++
1. Map.erase(key);    //删除 Map 中键为 key 的对组
2. Map.erase(Map.begin()+i, Map.begin()+j)    //删除第 i+1 到第 j+1 个对组之间这个区间
3. Map.erase(auto it);    //删除 Map 中位置为 it（迭代器）的对组
4. Map.clear();    //清空 Map ，得到一个空的 map 容器
```


### 玖  容器的选择

|              | vector   | deque    | list     | set    | multiset | map          | multimap     |     |
|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
| 典型内存结构 | 单端数组 | 双端数组 | 双向链表 | 二叉树 | 二叉树   | 二叉树       | 二叉树       |
| 可随机存取   | √        | √        | ×        | ×      | ×        | 对于 key：×  |   ×            |     |
| 元素搜寻速度 | 慢       | 慢       | 非常慢   | 快     | 快       | 对于 key：快 | 对于 key：快 |
| 元素安插移除 | 尾端 | 头尾两端 | 任何位置 | —— | —— | —— | —— |

