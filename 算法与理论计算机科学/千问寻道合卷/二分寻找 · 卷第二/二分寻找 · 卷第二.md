### 壹  分绳问题

#### 问：
##### 数绳本不均，等长几段分。
##### 求问最长段，零散不可拼。

· 有N条绳子，每条绳子不等长，用 L1, L2, L3, …… , Ln 表示，它们都是【整数】
· 现在要切割出 K 条等长的绳子，散段绳子【不可】拼接成一条
问：达标 K 条前提下，每份绳子最大长度是多少？无论N和K是多少都一定可以达标吗？

##### 算法过程：
###### 逐一试段长，二分定区限。
###### 超数则段小，逐试解终见。

1. 确立算法为查找法
2. 确定最大区限，每次取半，二分法划分新范围
3. 如果此时取值使得绳子总段数多于k，则有可能还有更大解：
	· 可能还有更大的解
	· 也可能取值加一后立刻不满足 K 段的条件，说明这已经是最优解
4. 如果此时取值使得绳子总段数少于k，尝试减小答案的取值

```C++
int length[100];    //用于存放每一条绳子的长度
int max;    //所给的最长的绳子
int N;    //绳子的条数
int K;    //绳子的目标段数

int Divide(int t)    //分绳整除函数，此处的“t”是尝试的答案
{
	int sum;    //段数求和
	for(int i=0; i<N; i++)
	{
		sum+=(int) length[i]/t;
	}
	return sum;
}

void Search()
{
	int left=1, right=max;    //划定左右界限
	if(Divide(left)>=k&&Divide(left+1)<k)
	{
		printf("每一段的绳子长度最大只能是1\n");
		return ;
	}
	if(Divide(right)>=k&&Divide(right+1)<k)
	{
		printf("每一段的绳子长度最大可取到%d\n",right);
		return ;
	}
	if(Divide(left)<k)
	{
		printf("不可能达成段数要求\n");
		return ;
	}
	
	int Try;    //寻找的尝试
	while(1)
	{
		Try=(left+right)/2;
		if(Divide(Try)>=k&&Divide(Try+1)<k)
		{
			printf("每一段绳子最大长度：%d\n",Try);
			return ;
		}
		else if(Divide(Try)<k)
		{
			right=Try;
			continue;
		}
		else
		{
			left=Try;
			continue;
		}
	}
}
```

##### 总结：
###### 第一步：确定查找的上下界限
###### 第二步：判断上下界限值是否满足要求，以及问题是否存在解
###### 第三步：循环实现二分查找，如若未找到解，则将上界或下界改为此二分值，继续循环


### 贰  数列下标

#### 问：
##### 数字排阵小到大，从零编序无落下。
##### 何位数值编序等？正比走势两线画。

· 给定一个非常长的有穷整数列，共有 N 项，从小到大已经排好序，角标从 0 开始，到 N-1 结束
· 这 N 个数字的大小各不相同，即排序后的数列是严格单调递增的
问：有多少个数值和角标相等的项？它们都是第几项？如何在不遍历这个超长数列的情况下快速找出？

##### 算法过程：
###### 双标首尾验两端，两端验罢看中间。
###### 角标不足寻左手，值标相等顾两边。

1. 将问题看成求正比例数列 y=x 和一个严格单调递增数列的交点个数的问题
2. 先看两端，如果起始项数值比0大，或最终项数值比 N-1 小，则一定没有交点；若两端满足条件，则继续
3. 二分查找，如果分点处数值比角标小，说明分点左侧没有数值能赶上角标的项；
	如果分点处数值比角标大，说明分点右侧数值都会比角标大
	如果分点处数值和角标相等，则两端分别再二分寻找，可用结构体栈存储所有存疑的查找区间的起末点
	· 两个满足条件的点之间的所有点一定都满足条件，也可用结构体栈存储满足条件区间始末点
4. 直至所有区间寻遍，给出最终答案

```C++
struct 
{
	int start;
	int end;
} section;              //表示区间信息的结构体

int N;    //总共有 N 个数
int series[1000000];    //数列数组（给定）

stack<struct section>Need_to_find    //存放待查找区间的栈
stack<struct section>okk;      //存放符合条件的区间的栈

void Search()
{
	if(N==1)
	{
		if(series[0]==0) printf("0\n");
		else printf("无答案\n");
		return ;
	}
	else
	{
		int left=0, right=N-1;      //左右标记
		if(series[0]>0||series[N-1]<N-1)
		{
			printf("无答案\n");
			return ;
		}
		else if(series[left]==0&&series[right]==N-1)
		{
			printf("全部符合要求\n");
			return ;
		}
		else
		{
			struct node td;
			td.start=left, td.end=right;
			Need_to_find.push(td);

			while(1)
			{
				if(!Need_to_find.empty())
				{
					left=Need_to_find.top().start;
					right=Need_to_find.top().end;
					Need_to_find.pop();
				}
				else break;
				
				if(series[left]=left&&series[right]=right)
				{
					td.start=left, td.end=right;
					okk.push(td);
					continue;
				}
				if(left==right) continue;
				
				int middle=(left+right)/2;


				if(series[middle]==middle)
				{
					td.start=middle, td.end=right;
					Need_to_find.push(td);
					td.start=left, td.end=middle-1;
					Need_to_find.push(td);    //先入栈右侧，再入栈左侧，保证结果从左到右顺序输出
				}
				else if(series[middle]<middle)
				{
					td.start=middle+1, td.end=right;
					Need_to_find.push(td);
				}
				else
				{
					td.start=left, td.end=middle-1;
					Need_to_find.push(td);
				}
			}

			if(okk.empty())
			{
				printf("无答案\n");
				return ;
			}
			else printf("符合条件的项：\n");
			whlie(!okk.empty)
			{
				for(int i=okk.top().start; i<=okk.top().end; i++) printf("%d ",i);
			}
			printf("\b\n");

			return ;
		}
	}
}
```

##### 递归法：

```C++
int flag=0;

void Search(int *series, int left, int right)
{
	if(left>right) return ;
	
	int middle=(left+right)/2;

	Search(series, left, middle-1);    //对左数组递归

	if(series[middle]==middle)
	{
		printf("%d\n",middle);
		flag=1;
	}

	Search(series, middle+1, right);    //对右数组递归
}

// flag 的作用在于标记是否有符合条件的答案，如果 flag 值为 0，说明没有答案
```

##### 总结：
###### · 根据问题特性，选择二分后继续讨论的区间
###### · 用栈把待搜索区间和解区间存储起来，方便按顺序取用

