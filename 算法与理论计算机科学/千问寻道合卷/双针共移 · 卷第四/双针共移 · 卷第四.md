### 壹  瑕疵回文

#### 问：
##### 一行字列回文读，回文总有差一符。
##### 而今有权删一字，可否使之瑕疵无？

· 给定一个字符串，可能回文，也可能不回文
· 如果不回文，则至多删去一个字符，判断是否使之回文，如可以，改的是哪个？
· 如果回文，直接回答：“回文”，此时不进行字符删减
例：如果给定的是：asdfgfdssa，则删去的是第9个（或第8个）字符“s”

##### 算法过程：
###### 左右双标内相逼，每动左右两互比。
###### 两旁不同一舍去，舍去一边标内移。
###### 如若此时两不同，退回原位移另一。
###### 删后再有参差出，便知回文不可期。

1. 用左右两个标记同时标记字符数组首尾，每次同时对向向中间移动两个标记
2. 正常情况下，回文串的两个标记所指向的字符应该是一样的
3. 如果两个标记所在字符不同，则先尝试多移动一格一侧的标记，如果再次一样，则说明那个跳过的字符应删
4. 如果删字符后仍然不能两侧相同，则复原回第 3 步的初始，尝试多移动一格移动另一侧标记
5. 如果此时仍不满足条件，直接判定无法回文

```C++
char str[300];    //这个数组从第 0 项开始取
int N=(int)strlen(str);    //字符个数
int del_place[151];    //用于存纳删去的字符是第几个

void Palindrome()             //“palindrome”意为“回文”
{
	int left=0, right=N-1;      //左右两个标记
	int delete_number=0;    //删除次数
	
	if(N==1)
	{
		printf("回文\n");
		return ;
	}

	while(right>left)
	{
		if(str[left]!=str[right])
		{
			left++;
			if(str[left]==str[right]||left==right)    //如果左右移标碰头，说明中间两个应任删一个
			{
				delete_number+=1;
				del_place[delete_number]=left;
				continue;
			}
			else
			{
				left--, right--;
				if(str[left]==str[right])
				{
					delete_number+=1;
					del_place[delete_number]=right+2;
					continue;
				}
				else
				{
					printf("无法满足条件\n");
					return ;
				}
			}
		}
		else continue;
	}

	if(delete_number==0) printf("回文\n");
	else if(delete_number==1) printf("删去第%d个字符可以回文\n",del_place[1]);
	else printf("无法满足条件\n");
	return ;
}
```

##### 总结：
###### 对称判定的问题，“双针共移”的方法可以节省遍历一半的时间
###### 本题时间复杂度分析：n/2 --- 无需字符串反向拷贝，再用 strcmp 函数比较，两边各检索一半即可


### 贰  沉船救生

#### 问：
##### 巨轮冰礁一恍间，千百旅客尽自难。
##### 救生船艇载有限，何以最少却保全。

· 将沉之船上有 N 名旅客，他们的体重不等，全部给出（假定 N 不超过20000）
· 一艘救生艇最多可以救下两个人，且载重限度为 c（c 一定大于任何一个人单独的体重，保证所有人都能获救）
问：最少用多少救生艇，把所有的旅客全部救下？

##### 算法过程：
###### 千人身重小大排，首尾两两组队来。
###### 如若结伴超重限，重者独船先离开。

1. 将所有人按体重从小到大排序
2. 最轻的人和最重的人组队，将救生艇的空间尽可能大地利用
3. 如果两人组队超过重量限制，则体重大的人自己一艘救生艇，再让轻者与现场次重的人组队

```C++
int N;    //总共 N 位旅客
int weight[20005];    //记录这些旅客各自的体重

int compare(const void *a, const void *b)      //qsort 从小到大比较函数
{
	return *(int *)a - *(int *)b;
}

void Lifeboat()          //“lifeboat” 意为 “救生艇”
{
	qsort(weight, N, sizeof(weight[0]), compare);
	int left=0, right=N;    //左右“双针”
	int lifeboat_num=0;    //用来统计使用救生艇的个数

	while(1)
	{
		if(weight[left]+weight[right]<=c)
		{
			lifeboat_num+=1;
			left++, right--;
		}
		else
		{
			liftboat_num+=1;    //重者独自乘一艘救生艇
			while(right>left)
			{
				right--;
				if(weight[left]+weight[right]<=c)
				{
					lifeboat_num+=1;
					break;
				}
				else continue;
			}
		}
		if(left==right) lifeboat_num+=1;    //最后剩的一个人单独离开
		else if(left>right) break;
		else continue;
	}

	printf("最少需要救生艇的个数为:%d\n",lifeboat_num)；
	return ;
}
```

##### 总结：
###### · 贪心思想：
1. 一艘船最多可以载两个人，则优先考虑两两组合上船
2. 为了减少一个人占用一艘船的情况，优先考虑最重和最轻的人两两组队
###### · 双针共移：
1. 同时考察首尾两个人，如果可以组队则直接组队，两针向中间共移
2. 如果因为超重无法组队，则二人中较重的人独自乘船，右针左移，继续检验重量条件
3. 当两针“碰头”的时候，讨论此时是剩下了 1 人还是 0 人，再做出收尾的安排 ^5a40e2

【!】贪心的思想：[[../局部最优为整体最优解 · 卷第一/局部最优为整体最优解 · 卷第一#^eeafe7]]


### 叁  三角判别

#### 问：
##### 已知散数多，三取边长作。
##### 为能成围角，所组有几何？

· 给定 N 个数字（ N >= 3 ）
· 从中任意取三个数字作为三边长
· 问：这些数字中有多少可以构成三角形的组合？（数字可以重复利用，只求最多的组合种数）

##### 算法过程;
###### 两短合更长，三角方能当。
###### 长边从大选，两短在左方。
###### 其一至小取，其一尽可长。
###### 得解中左行，不得短右将。

1. 将所有边长从小到大排序，记在数组 side【·】中，用三个标记 i，j，k 进行指示，k 是长边，i 是最短边
2. 将 k 置于 side【N -1】（最大边长），i 初始置于 side【0】，j 初始置于 side【k -1】
3. 如果 side【i】+ side【j】<= side【k】，则说明短边不够，令 i 向右移动一格
4. 如果 side【i】+ side【j】> side【k】，则可以构成三角形，此时在 j 和 k 不动的条件下，i 有 j -i 种取值能满足条件，总数加上 j -i，将 j 向左移动一格
5. 如果 i 标记和 j 标记“碰头”，则将 k 标记向左移动一格，i 再次置于零位，j 置于 k 左侧相邻位

```C++
int N;    //边长数值个数
int side[300];    //边长存放数组
int count=0;    //合理情况数计数

int compare(const void *a, const void *b)      //qsort 从小到大比较函数
{
	return *(int *)a - *(int *)b;
}

void triangle_count()
{
	qsort(side, N, sizeof(side[0]), compare);

	for(int k=N-1; k>=2; k--)    //最长边从最大开始取值
	{
		int i=0, j=k-1;
		while(j>i)
		{
			if(side[i]+side[j]>side[k])
			{
				count+=(j-i);
				j--;
			}
			else
			{
				i++;
			}
		}
	}

	printf("能够构成三角形的组合数为 %d\n",count);
	return ;
}
```

##### 总结：
###### 双针共移：
1. 经典操作：如果满足条件则右指针左移（或左指针右移），如果不满足则另一指针反向移动
2. 两针“碰头”说明对向遍历结束，有时视情况选择第三指针作为外循环，循环进行两个内指针的对向遍历

