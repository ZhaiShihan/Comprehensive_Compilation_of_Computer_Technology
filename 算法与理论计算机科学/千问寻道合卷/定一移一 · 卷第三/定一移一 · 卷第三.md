### 壹  最大容水

#### 问：
##### 盒器有底少两面，今为容水插双板。
##### 板有高低水满灌，何取两板最多全？

· 以 x 轴当容器的底，给定 n 个插板，分别在x=1，x=2，……处插，板子两两组合都能构成一个开口盒
· 如果两个板子的高度不一样，储水量取决于低的板子
· 认为盒子的前后厚度就是单位 1
问：选择哪两块板子，可以使总储水量最大？并求出最大储水量
（如果两组板子的围成容积相同，优先选择外围的；如果两组互相交错，任选其一）
![[卷第三-图/卷第三-图一.png]]
（图二）
如图一所示，存水量表达式：(9-2)×(min{2, 9})=7×7=49

##### 算法过程：
###### 左右夹容看矮板，一移一定动最短。
###### 每遇高板更重记，首尾合龙方为完。

实现步骤：
1. 将所有数据存在一个数组 height【】 中，用 left 和 right 两个标记实现“定一移一”
2. 记录初始值
3. 如果 height【left】< height【right】，则左标记右移；
	如果 height【right】< height【left】，则右标记左移
4. 移动标记如果到了一个比原来还短的板子，由于往中间移动使宽度减小了，故更短板对应的一定不是最大解
5. 移动标记如果到了一个比原来高的插板，则计算此时容水量：
	a-如果此时容水量比之前的大，记录新的值
	b-如果此时容水量比之前的小，则不记录
6. 返回步骤3进行左右比较，之后一直重复执行步骤3到步骤6，直到最终左右两个标记“碰头”，说明巡查完毕

```C++
int n;    //给定的 n 个插板
int height[100];    // n 个插板的高度
int left=1;    //左侧标记
int right=n;    //右侧标记

int Volume(int l_height, int r_height, int l_mark, int r_height)    //求容量函数
{
	int ht;
	if(l_height<r_hright) ht=l_height;
	else ht=right_height;

	int S;
	S=1*ht*(right_mark-left_mark);
	return S;
}

void Fixed_And_Mobile()    //实现“定一移一”的函数
{
	int vol_max=0;    //容积的最大值
	int l_vmax=1, r_vmax=n;    //容积最大时左、右的位置
	int l_hmax=height[1], r_hmax=height[n];    //左、右标记各自遇到的最高点高度
	if(height[left]<=height[right])
	{
		vol_max=height[left]*(right-left);
	}
	else
	{
		vol_max=height[right]*(right-left);
	}

	while(left<right)
	{
		if(height[left]<=height[right])
		{
			left++;
			if(height[left]<=l_hmax) goto end;
			else
			{
				l_hmax=left;    //更新左侧最高高度
				if(Volume(height[left],height[right],left,right)>vol_max)
				{
					vol_max=Volume(height[left],height[right],left,right);
					l_vmax=left, r_vmax=right;
				}
				else goto end;
			}
		}
		else
		{
			right--;
			if(height[right]<=r_hmax) goto end;
			else
			{
				r_max=right;    //更新右侧最高高度
				if(Volume(height[left],height[right],left,right)>vol_max)
				{
					vol_max=Volume(height[left],height[right],left,right);
					l_vmax=left, r_vmax=right;
				}
				else goto end;
			}
		}
		
		end:;
	}

	printf("最大容水量为%d,此时取左边第%d块板、右边第%d块板\n",vao_max,l_vmax,r_vmax);
	return ;
}
```

##### 总结：
###### · 定一移一：左右双标记，每次定一侧，移一侧，寻找可能的最大解
###### · 移过不回：两侧往中间移动，直至两个标记合龙，标记的移动方向不变，也就是不回头
###### · 算法的时间复杂度：O(n)


### 贰  三数归零

#### 问：
##### 排数列于前，从中挑出三。
##### 相和归为零，直至无可选。

· 给定一排乱序的数字（整数），总共有 N 个，其中有正有负，也可能有零，保证 N 不小于4
· 每次从中挑出三个，使这三个数之和为 0
###### 规则壹：找出这里所有满足条件的组，直到剩余的数字都不可满足条件
###### 规则贰：取过的数字不再使用

· 问：可以如何挑选？（挑选顺序和挑选方式随意，不要求组数最多）

##### 算法过程：
###### 定一走二向中移，碰头移左再重起。
###### 何移与零比高低，有解按位做标记。


实现步骤：
1. 将所有数字存在数组 number【】中，并从小到大排序（qsort排序）
2. 用 left、middle、right 三个移动标记实现：
	· left 初始放在最左端，middle 初始放在 left 右边相邻一个位置上，right 初始放在最右端
3. 定 left 标记，移动 middle 和 right标记：
	· 如果三数之和小于零，则 middle 标记向右移动一格
	· 如果三数之和大于零，则 right 标记向左移动一格
	· 如果三数之和正好等于零，则这三个数全部用一个标记数组 mark【】来标记，输出三个数
	（标记：mark【】数组初始化全赋值为 0，当有数字被使用后，将那个数字对应的位置赋值为 1 ）
4. 当 middle 和 right 标记“碰头”，将 left 向右移动一格，并将 middle 重置到 left+1 的位置，
	right 重置到数组最右端的位置
5. 重复进行步骤 3 到步骤 4，当移动标记遇到已经取出的数字时（即 mark【·】=1 时），跳过
6. 全局终止条件：当 left 标记的位置所对应的数值大于零时，此时再不可满足三数之和为零，结束

```C++
int N;    //总共有 N 个数字
int number[100];    //用来存放数字
int mark[100]={0};    //排序后标记哪些数字被使用过
int left, middle, right;    //左、中、右三个标记

int compare(const void * a,const void *b)    //qsort从小到大排序比较函数
{
	return *(int *)a - *(int *)b;
}

void Search()
{
	qsort(number, N, sizeof(number[0]), compare);
	memset(mark, 0, sizeof(mark));
	left=1, middle=2, right=N;
	int sum=999;    //sum 用于计算三个数的加和
	int combination_number=0;    //已选出的组合数

	while(1)
	{
		left++;
		if(number[left]>0) break;    //如果左标“走”到了正数的位置，则结束
		if(mark[left]==1) continue;    //如果遇到已经用过的数字，则跳过

		middle=left+1;
		while(mark[middle]==1) middle++;
		right=N-1;
		while(mark[right]==1) right--;
		if(middle==right) break;      //给右侧两个标记初始化，如果两个标记初始化时已“碰头”，直接结束

		sum=number[left]+number[middle]+number[right];
		if(sum==0)
		{
			combination_number+=1;
			printf("组合 %d ：",combination_number);
			printf("【%d，%d，%d】\n",number[left],number[middle],number[right]);
			mark[left]=1, mark[middle]=1, mark[right]=1;
			continue;
		}
		
		while(1)
		{
			sum=number[left]+number[middle]+number[right];
			
			if(sum<0||mark[middle]==1)
			{
				left++;
				continue;
			}
			if(sum>0||mark[right]==1)
			{
				right--;
				continue;
			}
			if(middle==right) break;     //如果右侧两个标记“碰头”，右移 left，重新开始
			if(sum==0)
			{
				combination_number+=1;
				printf("组合 %d ：",combination_number);
				printf("【%d，%d，%d】\n",number[left],number[middle],number[right]);
				mark[left]=1, mark[middle]=1, mark[right]=1;
				break;      //寻找到合适的解，便重新开始，因为这时 number[left] 已经不能再使用了
			}
		}
	}

	return ;
}
```

##### 总结：
###### 【聚焦调节法】：
· 将 left 类比成聚焦的粗调，将 middle 和 right 类比成聚焦的细调，目标就是调零
· 先用 left 粗调试探，之后看现在 sum 和 0 的关系：
	· 若 sum>0，则细调 right（往左移动）
	· 若 sum<0，则细调 middle（往右移动）
· 如果调零成功，则记录并输出
· 曾经记录过的搭配，不再重复使用其中任一元素
【算法时间复杂度】：O ( n^2 )


### 叁  石坑接雨

#### 问：
##### 长石凿坑深不等，凹坑置上露天空。
##### 寒秋一夜敲窗雨，问水几两蓄石中？

· 一块前后厚度为 1 的石头，上面有凹凸不平的坑
· 给定石头的总长度 N，沿长边将石头平均分成N份，每一份的长和厚都是单位长度（如同平行排列的方柱）
· 每一个“方柱”的高度不等，按顺序全部给出，每一个高度值都是单位长度的整数倍
· 只有不在边上，且左右两边比自身高的方柱上方可以蓄雨水（石头上面的坑可以蓄雨水）
· 保证石头的长度N满足：N 不小于 3
问：给定的石头的坑内可以蓄多少单位体积的雨水？
![[卷第三-图/卷第三-图二.png]]
（图三）
（这里给定的石头长度是12，高度序列是：0，1，0，2，1，1，0，1，3，2，1，2，1 ）
· 如图所示，这样的石坑可以存蓄雨水的量是 6 倍单位体积

##### 算法过程：
###### 低洼存水高不存，各柱为营左右分。
###### 左右最高寻较短，算罢后柱作基准。

1. 用 node 标记高度数组 height【1~N】，node 初始置于位置 2
（每次考察的基准柱是 node，node 从 2 取，到 N-1 结束，因为边上的位置不能蓄水）
2. 建立结构 pillar（柱子），其中包含柱子的高度 h，柱子左右两边柱子的最高高度 l_max，r_max
（如果左或右边不存在比自己高的柱子，则将 l_max 与 r_max 直接赋值成自身高度 h，避免过后逐个柱子计算蓄水量时，在这一项出现负数）
3. 用扫描的方式确定 l_max 和 r_max 的值：以 node 为【定标记】，以 step 为【移标记】：
	· 先让 step 从左向右扫，确定每一个 pillar 的 l_max
	· 再让 step 从右向左扫，确定每一个 pillar 的 r_max
4. 逐个柱子计算上方蓄水量，用 l_max 和 r_max 中较小的值减去 h 的值
5. 总蓄水量用 Sum 求和

```C++
typedef struct p
{
	int h;    //高度
	int l_max;    //左侧最高值
	int r_max;    //右侧最高值
} Pillar;

Pillar P[1000];
int N;    //石头长度
int height[1000];    //每一个“柱子”的高度（从height[1]开始）

void COUNT()
{
	int node;    //定标记
	int left_or_right_max=height[1];    //每一个柱子左或右侧的最高值
	for(int step=2; step<=N; step++)    //从左向右扫描
	{
		P[step].h=height[step];
		if(left_or_right_max<=height[step])
		{
			P[step].l_max=P[step].h;
			P[step].r_max=P[step].h;    //这步也可以删去（仅这一行，不包括上一行和下一行）
			left_or_right_max=P[step].h;
		}
		else
		{
			P[step].l_max=left_or_right_max;
		}
	}
	left_or_right_max=height[N];
	for(int step=N-1; step>=1; step--)    //从右向左扫描
	{
		if(left_or_right_max<=height[step])
		{
			P[step].r_max=P[step].h;
			P[step].l_max=P[step].h;    //这步也可以删去（仅这一行，不包括上一行和下一行）
			left_or_right_max=P[step].h;
		}
		else
		{
			P[step].r_max=left_or_right_max;
		}
	}

	int Sum=0;    //记录总蓄水量
	for(int i=2; i<=N-1; i++)    //蓄水统计
	{
		if(P[i].l_max<=P[i].r_max)
		{
			Sum+=P[i].l_max-P[i].h;
		}
		else
		{
			Sum+=P[i].r_max-P[i].h;
		}
	}

	printf("石坑的蓄雨量为%d\n",Sum);
	return ;
}
```

##### 总结：
###### · 定一移一：逐个柱子考察，分别以每一个柱子为基准，移动扫描，寻找左右最高值
###### · 两次扫描：平行两个循环，化嵌套为并列，将时间复杂度降解
###### · 估算时间复杂度：3n : 一遍寻找左端最高，附带高度向结构体赋值；一遍寻找右端最高；一遍计算


### 肆  驿路马草

#### 问：
##### 环路长途乘马行，马无粮草就刻停。
##### 驿站供草途中耗，何站始发全途经？

· 环路上有 N 个驿站，从其中一个骑马出发，马在路途上需要消耗马草
· 每一个驿站所提供的马草量按照顺序给出
· 每一个驿站到下一个中间的路途中消耗的马草数量，按照顺序给出
· 马草耗尽没到驿站，则旅程终止
问：可否从某一驿站出发，经过环路再次回到此驿站？如若可以，给出全部答案

例：四个驿站：
驿站 1 提供 6 马草，1~2 路上消耗 8 马草
驿站 2 提供 3 马草，2~3 路上消耗 6 马草
驿站 3 提供 4 马草，3~4 路上消耗 2 马草
驿站 4 提供 7 马草，4~1 路上消耗 4 马草
则：从驿站 3 或驿站 4 出发可以保证再次回来

##### 算法过程：
###### 定一始发从此行，移标作马逐站经，马草尽时就此停。
###### 定子右移从头行，重走粮草须归零，直至全历此事竟。

1. 以 start 为【定标记】，以 horse 为【移标记】，从定标记开始向下走
2. 向下走的过程中，只要到达一个驿站时粮草数小于零，则说明这个始发站最后回不来，start 移一，再重走
3. 当 start 标记到最后一个驿站，且本次旅程验证结束后，终止
4. 每次遇到可以回环的情况时，记录下此时的始发站，所有的始发站逐个输出（如无解，则最后回答：无解）

```C++
int provide[100];    //提供的粮草数量
int consume[100];    //每站到下一个驿站中间路途花费的马草数量
int N;      //总共的驿站个数
int forage_number=0;    //草料数量变化
int start, horse;    //【定标记】和【移标记】

void The_way()
{
	int number_of_answer=0;    //记录解的数量，亦方便无解的判断
	for(start=1; start<=N; start++)
	{
		forage_number=forage_number+provide[start]-consume[start];
		if(forage_number<0) continue;
		
		horse=start+1;
		while(1)
		{
			if(horse==N+1) horse=1;
			if(horse==start)
			{
				number_of_answer+=1;
				if(number_of_answer==1) printf("从第%d个",start);
				else printf("、第%d个",start);
				break;
			}
			forage_number=forage_number+provide[horse]-consume[horse];
			if(forage_number<0) break;
			horse++;
		}
	}

	if(answer>0) printf("驿站出发可以再回来\n");
	else printf("无解\n");
	
	return ;
}
```

##### 总结：
###### · 定一移一：每次固定一个起点，从起点开始检索
###### · 循环截断：当粮草数在某一站到站时变为负数，则说明这个起点不满足条件，换下一个起点
（start 标记实现起点的移定）
###### · 时间复杂度：O ( n^2 )


### 伍  房屋供暖

#### 问：
##### 初九天寒冰封地，沿路楼屋尽冷意。
##### 半径供暖热源架，何以最小全波及？

· 给定一条路，上面线性均匀分布 N 个位置，N 给出
· 有一些位置点上有房屋，需要暖源供暖，这些位置点给出（至少一个点上有房屋），房屋总共有 house_num 个
· 有一些位置点上有暖源，所有暖源的热波及半径相同，（至少一个点上有热源），暖源总共有 heater_num 个
· 剩余的位置点上空着
· 【!】没有 0 号位置
问：如何选择暖源的最小波及半径 r，使得满足全部房屋接受到供暖的条件？

例：N=7
房屋位置点：1，5，7
暖源位置点：3，6
则最小的 r 应为 2，保证暖源的波及范围可以“罩”住所有的房屋

##### 算法过程：
###### 逐屋左右寻，暖源何侧近？
###### 近者各看距，留得最大存。

· 每一个房屋都考察，左右的暖源相对较近者，或者左右唯一的暖源，到这个房屋的距离记录下来
· 每一个房屋都会记录一个上述的距离值，比较出它们的最大值，这个值即为答案

```C++
int N;
int way[100]={0};    //表示一路上的所有位置信息，由于无 0 号位置，故从 way[1] 开始取
//在主函数的输入部分就可以实现，用 way 数组记录，way[a]=1 代表 a 位置是房屋，way[b]=2 代表 b 位置是暖源

typedef struct stu
{
	int left_nearest=-1;    //左侧最近暖源距离
	int right_nearest=-1;    //右侧最近暖源距离
	int min_of_lr;    //左右相对较近的暖源距离
} Buildings;
Buildings B[100];         //存储房屋的相关信息

int max_of_distance;      // way[·] 数组角标最大的设施（包括房屋和暖源）
int house_num;    //给定的房屋个数

void Search()
{
	int left=0, right=0;    //左右“移标记”
	int middle=0;    //中间检索房屋的“定标记”（可动）
	int build_num=0;    //统计这是第几个房屋
	for(middle=1; middle<=max_of_distance; middle++)
	{
		build_num+=1;
		if(way[middle]==1)    //此时说明这个位置上是房屋
		{
			for(left=middle, left>=1; left--)
			{
				if(way[left]==2)
				{
					B[build_num].left_nearest=middle-left;
					break;
				}
			}
			for(right=middle, right<=max_of_distance; right++)
			{
				if(way[right]==2)
				{
					B[build_num].right_nearest=right-middle;
					break;
				}
			}

			if(B[build_num].left_nearest==-1)
			{
				B[build_num].mim_of_lr=B[build_num].right_nearest;
			}
			else if(B[build_num].right_nearest==-1)
			{
				B[build_num].mim_of_lr=B[build_num].left_nearest;
			}
			else    //左或右一定有暖源，故此时只有一种情况，及左右最短距离都不是 -1
			{
				if(B[build_num].left_nearest>B[build_num].right_nearest)
				{
					B[build_num].min_of_lr=B[build_num].right_nearest;
				}
				else B[build_num].min_of_lr=B[build_num].left_nearest;
			}
		}
	}

	int max_of_min=-1;    //所有最小值中的最大值，即最终答案
	for(int i=1; i<=house_num; i++)
	{
		if(B[build_num].min_of_lr>max_of_min) max_of_min=B[build_num];
		else continue;
	}

	printf("能够给所有房屋供暖的最小热源半径：%d\n",max_of_min)；
	return ;
}
```

##### 总结：
###### · 定一移一：每次中间房屋的标记不动，两侧移动标记从中间向两边寻找最近暖源
###### · 满足条件：将所有房屋的最小需求记录，比较它们中最不易满足的，那个就是全局最小答案

