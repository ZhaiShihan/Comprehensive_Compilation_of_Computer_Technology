### 壹  活动安排

#### 问：
##### 百场活动一室中，活动两两不相容。
##### 每事占时定终始，只为求得最多重。

![[卷第一-图/卷第一-图一.png]]
（图一）
（i 为活动编号，si 为每个活动的起始时间，fi 为每个活动的终止时间）
##### 算法过程：
###### 完时小大排，首事必先开。
###### 须待前事结，后事相继来。

1. 按终止时间排序
2. 选择最早结束的活动，即第一个活动
3. 在其余活动集合中选择与已选活动不冲突，且结束时间最早的活动

```C++
typedef struct node
{
	int data;
	int start_time;
	int end_time;
} Activities;    //定义一个结构体，用于存放活动编号、起始时间与结束时间

Activities A[20];    //结构体数组
int N;    //表示活动的个数

int compare(const void* e1, const void* e2)  //qsort的比较函数（小到大）
{
	Activities a=*(Activities*)e1;
	Activities b=*(Activities*)e2;
	return a.end_time-b.end_time;
}

void Greedy_Activity_Selector()  //活动的贪心算法
{
	qsort(A, N, sizeof(A[0]), compare);  //结构体先按照终止时间排序
	
	int end=0, nd=0;  //end用于表示当前输出活动的结束时间，nd表示检索到第几个活动了
	printf("%d\n",A[0].data);
	end=A[0].end_time;

	while(nd<N-1)  //这里的N表示活动的个数
	{
		nd++;
		if(A[nd].start_time>=end)
		{
			printf("%d\n",A[nd].data);
			end=A[nd].end_time;
		}
		else continue;
	}
}
```
##### 总结：
###### 第一步：做出贪心选择：
· 选择一个活动，加入最优解中
· 即选择最早结束的活动 a1
###### 第二步：求解剩余子问题：
· 即寻找 a1 结束后开始的活动
· 若 A 是包含 a1 的最大活动集（最优策略），
则 A - {a1} 是剩下的 S1（子问题）上的最大相容活动集


### 贰  背包问题

#### 问：
##### 金玉百珍重千斤，美物世价各不同。
##### 怎奈背包有容限，何以最贵入囊中？

· 给定 n 种物品和一个背包
· 物品 i 的重量是 wi ，其价值为 v1
· 背包的容量为c
###### · 规则：可以选择每一件物品的一部分装入背包

问：应该如何选择装入背包的物品，使得装入背包中物品的总价值最大？

##### 算法过程：
###### 价重之比较高低，至上之物尽多取。
###### 取尽吾囊仍未满，再选价高补空余。

1. 首先计算每种物品单位重量的价值 vi/wi
2. 贪心选择，将尽可能多的单位重量价值最高的物品装入背包
3. 若将这种物品全部装入背包后，背包内的物品总重量未超过重限 c，
则选择单位重量价值次高的物品，并尽可能多地装入背包

```C++
typedef struct node
{
	int data;    //物品编号
	float value;    //物品总价值
	float weight;    //物品总重量
	float Value_divide_Weight  //价值和重量的比值
} Things;

Things T[50];    //结构体数组
int N;    //总共有N各物品
float c;  //背包的重量上限

int compare(const void* e1, const void* e2)    //qsort比较函数（大到小）
{
	Things a=*(Things*)e1;
	Things b=*(Things*)e2;
	return b.Value_divide_Weight-a.Value_divide_Weight;
}

void Knapsack()
{
	qsort(T, N, sizeof(T[0]), compare);

	int nd=-1;  //指示这是第几个物品
	float sum=0;  //现在已经装入的重量
	float s_value=0;  //现在已经装入的总价值

	while(nd<N-1)
	{
		nd++;
		if(T[nd].weight<c-sum)    //如果这个物品装入完背包还有空位，这种物品全装
		{
			sum+=T[nd].weight;
			s_value+=T[nd].value;
			printf("%d号物品全部装入\n",T[nd].data);
			continue;
		}
		else      //如果这个物品装入后背包正好满或超重，择取部分而装，结束
		{
			sum=c;
			s_value+=(c-sum)*T[nd].Value_divide_Weight;
			printf("%d号物品装入%.2f%\n",T[nd].data,(c-sum)/T[nd].weight);
			//同时输出装入的百分比
			break;
		}
	}

	printf("装入的最大价值为%.3f\n",s_value);
}
```

##### 总结：
###### 第一步：做出贪心选择：
· 寻找单位重量价值最高的物品装入背包
###### 第二步：考察后续问题：
· 寻找下一个单位重量价值最高的物品装入背包
· 如果背包超重，在重量限处截断百分比


### 叁  最优装载

#### 问：
##### 巍巍巨轮设重限，累累货箱积如山。
##### 求问何以不超重，载得最多去天边？

· 给定一艘载重量为 c 的货轮
· 集装箱 i 的重量为 wi
· 不考虑集装箱的体积
###### · 规则：一个集装箱，只有装和不装两种选择，没有只装一部分

问：如何在不超重的情况下，装载尽可能多的集装箱？

##### 算法过程：
###### 重箱排后轻在前，至轻装载最优先。
###### 前者置罢有空位，后继逐一试上船。

```C++
typedef struct node
{
	int data;    //货箱编号
	int weight;    //货箱重量
} Containers;

Containers C[50];
int N;    //货箱数量
int limit;    //船的承重限度

int compare(const void* e1, const void* e2)  //qsort的比较函数（小到大）
{
	Containers a=*(Containers*)e1;
	Containers b=*(Containers*)e2;
	return a.weight-b.weight;
}

void Loading()
{
	qsort(C, N, sizeof(C[0]), compare);    //按照重量顺序从小到大排序

	int nd=-1;    //用于指向现在是排序后的第几个箱子
	int sum=0;    //现在上船的重量
	int number=0;    //统计最多装入多少货箱

	while(nd<N-1)
	{
		nd++;
		if(limit-sum>=c[nd].weight)
		{
			sum+=c[nd].weight;
			printf("%d号货箱装入\n",c[nd].data);
			number++;
		}
		else
		{
			printf("最多可以装载%d个货箱\n",number);
			break;
		}
	}
	return;
}
```
##### 总结：
###### 第一步：做出贪心选择：
· 寻找最轻的集装箱装载货船
###### 第二步：考察后续问题：
· 如果货船有容量，考察次轻的集装箱
· 如果货船无法装载这个集装箱，那么后面的更无法承载，直接终止、


### 肆  桃树尽取

#### 问：
##### 数棵桃树园间栽，每树择日结果来，桃熟挂枝两天败。
##### 一日仅照定数摘，求问何法配分开，纳得最多桃入怀？

· 给定 n 棵桃树，每棵各有编号
· 第 i 棵桃树将会在第 ai 天结出 bi 个桃子、
· 每个桃子仅能在树上保鲜两天（及成熟的第 ai 天，和第 ai+1 天）
· 限定每天只能采摘 v 个桃子
问：所有桃子成熟衰败尽后，最多能采摘到多少？

##### 算法过程：
###### 昨日无桃从今来，有桃先拣昨日摘。
###### 一日必定尽余力，可保日日兜满载。

· 这道题树的编号和单棵树结果数是没有用的信息，主要关注点应是每日有多少个桃子成熟
· 使用数组 day_NumberOfPeach[ ] 来实现记录每日成熟数量
· 桃子的个数有累积性，只考虑一天的情况：
1. 如果前一天剩下了桃子，那么优先采摘前一天的：
	· 如果前一天的仍没摘完或者刚好摘完，本日的桃子剩余数量今天就不动了
	· 如果前一天的摘完了，还有余力，那么从本日剩余桃子中补回：
		a. 如果本日的桃子没摘完或刚好摘完，则正常留下剩下的放入 “d-N” 数组
		b. 如果本日的桃子摘空了，仍有余力，那么本日留下桃子树清零，余力浪费
2. 如果前一天没剩下桃子，那么摘今天的：
	· 如果今天的刚好摘完或没摘完，留下剩下的放入 “d-N” 数组
	· 如果今天的摘完了，还有余力，“d-N” 数组今日剩余归零，余力浪费
· 每一天都如上考虑，第一天没有前一天的累积，单独考虑
```C++
int n, v;    //总共有n棵树，每日最多能采摘 v 个果实
int day_NumberOfPeach[4000];   // day_NumberOfPeach[3]=x 表示第三天成熟x个桃子
int day_max=0;    //最多多少天
int sum=0;    //采摘总量

int main()
{
	memset(day_NumberOfPeach, 0, sizeof(day_NumberOfPeach));  //初始化，数组置0
	
	scanf("%d %d",&n,&v);    //输入树的总数和每日摘果上限
	for(int i=1; i<=n; i++)
	{
		int day, number;
		scanf("%d",&day);     //输入这棵树在第几日成熟
		scanf("%d",&number);    //输入这棵树这日成熟数量
		day_max=(day_max>day? day_max: day);    //寻找最后有树成熟的天数
		day_NumberOfPeach[day]=number;    //记录第day天成熟number个桃子
	}

	if(day_NumberOfPeach[1]<=v)  //如果第一天桃子数少于每日采摘限定，则尽取
	{
		sum+=day_NumberOfPeach[1];
		day_NumberOfPeach[1]=0;    //将本日剩余桃子数量归零
	}
	else    //如果第一天结的桃子就超过了采摘限度
	{
		sum+=v;
		day_NumberOfPeach[1]-=v;
	}                                 //第一日考察结束

	for(int i=2; i<=day_max+1; i++)    //从第二日到最后一日的下一日考察
	{
		if(day_NumberOfPeach[i-1]!=0)  //如果昨日存在剩余
		{
			if(day_NumberOfPeach[i-1]>=v)  //如果昨日都采摘不完或刚好采摘完
			{
				day_NumberOfPeach[i-1]-=v;
				sum+=v;
			}
			else      //如果昨日的可以采摘完且还有余力
			{
				if(v-day_NumberOfPeach[i-1]<=day_NumberOfPeach[i])
				//余力不足以采摘尽今日的桃子
				{
					day_NumberOfPeach[i]-=(v-day_NumberOfPeach[i-1]);
					day_NumberOfPeach[i-1]=0;
					sum+=v;
				}
				else    //如果余力足够采摘今日的桃子
				{
					sum+=(day_NumberOfPeach[i-1]+day_NumberOfPeach[i]);
					day_NumberOfPeach[i-1]=0;
					day_NumberOfPeach[i]=0;
				}    //余力浪费
			}
		}
		else      //如果昨日不存在剩余
		{
			if(v<=day_NumberOfPeach[i])    //如果今日的刚好采完或未全部采完
			{
				sum+=v;
				day_NumberOfPeach[i]-=v;
			}
			else      //如果今日的采完后仍有余力
			{
				sum+=day_NumberOfPeach[i];
				day_NumberOfPeach[i]=0;
			}
		}
	}

	printf("最后获得的桃子总数是%d",sum);
	return 0;
}
```
##### 总结：
###### 第一步：贪心规划：
· 如果前一天有剩余，那么优先选择尽可能采尽前一天的，使前一天的尽可能不浪费
· 如果前一天没有剩余，那么尽可能采摘今天的
· 一定尽量保证每日都达到最大采摘限度
###### 第二步：对于累积效应的讨论：
· 如果前一天的采尽还有余力，采摘今天的，直至余力耗尽或今日已没有果子这两种情况
###### 第三步：单独讨论特殊情况：
· 第一天由于没有前一天，需要从当日开始特殊讨论


### 伍  孩童分糖

#### 问：
##### 手有甘糖大小异，群童要糖各不一。
##### 试问将糖何分配，换得最多孩童怡？

· 手中有 m 个糖果，现有 n 个孩子要糖
· 每个糖果的大小不等，m 个糖果大小分别是 C1，C2，……，Cm
· 每个孩子的需求大小不等，n 个孩子的需求分别是W1，W2，……Wn
问：如何分配糖果，能满足最多的孩子？

##### 算法过程：
###### 数个孩童排队排，最易满者定首开。
###### 手中饴糖从小出，大者暂留试后来。

```C++
int candy_size[100];    //存放手中糖果大小
int want[100];    //存放孩童需求
int m, n;    //有 m 颗糖，n 个孩子

int compare(const void *a,const void *b)    //qsort从小到大排序比较函数
{
	return *(int *)a - *(int *)b;
}

void Hand_Out()
{
	qsort(candy_size, m, sizeof(candy_size[0]), compare);
	qsort(want, n, sizeof(want), compare);
	//将手中糖果大小和孩童对于大小的需求分别按照从小到大排列

	int want_nd=-1;    //指向 want 数组中的第几个元素
	int candy_nd=0;    //指向 candy_size 数组中的第几个元素
	int satisfied_number=0;    //已经满足孩子的个数

	while(1)
	{
		candy_nd++;
		if(candy_nd>=m||want_dy>=n)    //如果两个数组标记大于数组大小了则结束
		{
			break;
		}
		if(want[want_nd]<=candy_size[candy_nd])    //如果糖满足需求
		{
			satisfied_number++;
			want_nd++;
			continue;
		}
		else    //如果糖不满足这个孩子的需求，应当换一块糖
		{
			continue;
		}
	}

	printf("最多可以满足%d个孩子的糖果需求",satisfied_number);
}
```
##### 总结：
###### 第一步：贪心规划：
· 无论满足需求小的还是需求大的孩子，期望贡献都是相同的
· 需求小的孩子更容易满足
· 选择需求最小的孩子，从最小的糖果开始试起，大的糖果留给需求大的
###### 第二步：后续问题：
· 如果小糖果可以满足需求小的孩子，则考察下一个孩子，并从下一个糖果试起
· 如果不能满足，则换一块糖，同样是从剩余的糖果里找相对最小的


### 陆  四人夜桥

#### 问：
##### 窄桥仅容二人行，深夜四人一盏灯。
##### 风吹桥摇心更悬，暗行无灯不敢通。
##### 四人步行有快慢，结伴快须把慢等。
##### 试问何能时最短？莫要在此费时功。

· 四个人，仅有一盏灯，过桥者需要有一人把灯送回
· 四个人的过桥时间各不相同，两人结伴过桥的时间是慢者过桥的时间
问：如何过桥保证总时间最短？求出最短时间

##### 【!】普遍认同的误解算法：
###### 解答：
1. 两个过桥最快的人先过去，第一快的把灯还回
2. 两个最慢的人过去，对岸第二快的把灯还回
3. 第一和第二的人再同时过桥
· 总时长：一倍的第一快的时间+三倍的第二快的时间+一倍的第四快的时间
###### 原理：
1. 一个人单独过桥一定浪费时间，不可取，故每次都应该尽量二人同行
2. 回程时最好让对面相对最快的人来还灯
3. 四个人两两结伴，加上两次还灯，正常需要五段时间
4. 由于两两结伴，最快的人在去对面时，一定要迁就一个比自己慢的，所以在“往”的方向上，不会有最快的人的时间累计，最快的人的时间累计一定在“返”的方向上
5. 五段时间如何分配呢？既然在“往”的方向上不能出现最快的时间，那就五段更多分配给次快的时间，因此最短时长的表达式中是一倍的最快，却三倍的次快

#### 问二：

##### 四人换序各算之，穷举即见最小值。
##### 如若此时数人来，何以分配最短时？

· 在之前规则的基础上，由四人改成了 N 个人
· 仍然只有一盏灯
· N 个人的过桥用时各不相同
问：此时如何过桥保证总时间最短？求出最短时间

##### 算法过程：
###### 最快二人先结伴，首快回程把灯还，再行过桥两最慢。
###### 次快还灯回此岸，最快二人再结伴，后事皆依此循环。

```C++
int time[100];    //用于存放每个人的过桥时间
int time_all=0;    //用于记录总用时
int N;    //总人数

int compare(const void *a,const void *b)    //qsort从小到大排序比较函数
{
	return *(int *)a - *(int *)b;
}

void GoingThrough()
{
	qsort(time, N, sizeof(time[0]), compare);

	while(1)
	{                       // N 在此处可以表示剩余人数
		if(N==1)
		{
			time_all+=time[0];
			break;
		}
		else if(N==2)
		{
			time_all+=time[0]+time[1];
			break;
		}
		else if(N==3)                  //先分别讨论一个人、两个人、三个人的情况
		{
			time_all+=time[0]+time[1]+time[2];
			break;
		}
		else                           //当人数大于等于4时
		{
			time_all+=2*time[1]+time[0]+time[N-1];
			N-=2;
			continue;
		}
	}

	printf("需要的最短时长是%d\n",time_all);
	return ;
}                            //【这个算法有漏洞！】
```

##### 改进算法的提出：
###### 反例：当四个人的过桥时间分别是 1，8，9，10 时，最短时间是29，而按照上述算法结果是35
· 当四人过桥时间是1，8，9，10时，传递灯的如果是第二个人将会非常耗费时间，
不如第一个人将每个人依次送过去，改双人传递灯为单人传递
###### 本欲回程少时间，怎奈次快腿脚慢。
###### 如若无法相搭配，且试最快把灯传。

· 在上述算法之外，还需考察另一个算法是否更优，即全程靠最快的人传递灯
· 总时间为：（N-2）×第一个人过河时间+后面每个人过河时间之和

程序增加一步比较两种算法的结果，取最小值：
```C++
int time[100];    //用于存放每个人的过桥时间
int time_all=0;    //用于记录总用时
int N;    //总人数

int compare(const void * a,const void *)    //qsort从小到大排序比较函数
{
	return *(int *)a - *(int *)b;
}

void GoingThrough()
{
	qsort(time, N, sizeof(time[0]), compare);
	int NN=N;    //总人数的复制值（保证在后面改边N时，有一个不动的基准）

	while(1)
	{                       // N 在此处可以表示剩余人数
		if(N==1)
		{
			time_all+=time[0];
			break;
		}
		else if(N==2)
		{
			time_all+=time[0]+time[1];
			break;
		}
		else if(N==3)                  //先分别讨论一个人、两个人、三个人的情况
		{
			time_all+=time[0]+time[1]+time[2];
			break;
		}
		else                           //当人数大于等于4时
		{
			time_all+=2*time[1]+time[0]+time[N-1];
			N-=2;
			continue;
		}
	}

	int try_answer;    //试验另一种方法（最快单独传灯）的答案
	if(NN>3)
	{
		for(int i=0; i<=N-1; i++) try_answer+=time[i];
		try_answer+=((N-3)*time[0]);
		time_all=(time_all<try_answer? time_all: try_answer);
	}

	printf("需要的最短时长是%d\n",time_all);
	return ;
}
```

##### 总结：
###### 第一步：贪心选择：
· 先过去两个最快的人作为辅助，贪心思维，使中途运灯的时间最短
· 注意问题不是问规定时间内最多能过多少人，而是全通过的最短时间
· 每次让两个最慢的人一起过，让更慢者把次慢者的过桥时间“吃掉”，并且两个慢者不要再回程
###### 第二步：后续问题：
· 循环过后，特殊讨论还剩下三个人或两个人时应当如何处理
###### 注意：不要忘记讨论 N=1 这种最特别的情况
###### 【!】第三步：讨论在不同取值下，是否还有其他的“贪心”方式：
· 局部最优为整体最优解，以四个人或更少为“局部”，或一个考察单元
· 局部的最优解是什么？是否有可能不同的条件下，局部有可能有不同的解法保证最优？
· 分别以局部最优的不同解法出发，解出最终的若干个解，比较解的最小值
##### · 普遍错误·分析：
###### 【!】第一种解法的漏洞出现的根源，并不在于“贪心”思维，
###### 而在于没有考虑全，局部最优解是否仅有一种解法


### 柒  田忌赛马

#### 问：
##### 田忌齐王各数马，每马行速皆有差。
##### 求得一法忌多胜，避芒之智千古夸。

· 田忌和齐王各有 n 匹马，这 2n 匹马各有各的行速，认为速度快的一定会胜速度慢的
· 每人每次各出一匹马比赛，共赛 n 次，比过赛的马不能再出赛
###### 规则：合理分配出战次序，保证田忌赢得相对于自己最多的场数
问：田忌最多可以胜出多少局？

##### 算法过程：
###### 手中最慢定难赢，便以至劣换至优。
###### 最喜我马胜一毫，层层压敌英明留。

1. 将田忌和齐王的马全都按照速度大小，从小到大排序
2. 田忌的马只要有比齐王最慢马还慢的，那么这匹马一定赢不了，优先换齐王最快的马
3. 从最慢考察，田忌的马如果比齐王的快，这匹马与齐王最慢的马比赛，先赢得一局，贪心规划

```C++
int T[100];    //田忌各马的速度
int Q[100];    //齐王各马的速度
int n;        //每人各有 n 匹马

int compare(const void *a,const void *b)    //qsort从小到大排序比较函数
{
	return *(int *)a - *(int *)b;
}

void PK()
{
	qsort(T, n, sizeof(T[0]), compare);
	qsort(Q, n, sizeof(T[0]), compare);
	int win=0;    //记录胜场

	int nd_t=0, nd_q=0;    //两个分别为田忌马的数组当前位置和齐王马的数组当前位置
	int end_q=n-1;    //齐王的马的最后一个（实时更新），即目前还剩下最快的马的数组位置
	while(1)
	{
		if(T[nd_t]<=Q[nd_q])
		{
			T[nd_t]=0, T[end_q]=0;    //败或平一局，田忌最劣马与齐王最优马“同归于尽”
			end_q--, nd_t++;
			if(nd_t>=n||end_q<nd_q) break;
		}
		else      //如果田忌此马快于齐王，则两匹马比赛，田忌胜出
		{
			T[nd_t]=0, Q[nd_q]=0;
			nd_t++, nd_q++;
			win++;
			if(nd_t>=n||end_q<nd_q) break;
		}
	}

	printf("田忌最多可以胜出%d局",win);
	return ;
}
```

##### 总结：
###### 第一步：做出贪心选择：
· 从最慢的考虑，如果田忌的马比齐王的快，先赢一局
· 如果速度相同，为了保证赢的次数最多，宁可输也不要平局，给后面的胜利提供更加优越的条件
· 如果田忌数组中最前面的马速度慢，则“换掉”齐王最快的马
（qsort 排序后，前面的马永远是目前最慢的）
###### 第二步：实现逐个比较的循环：
· 从慢到快依次比较，循环实现
· 由于二人的马数相同，故不会出现最终结束后哪一方有马剩余的情况，
故终止条件为：两方（一方也可）都没有未出赛过的马了


### 捌  隔垄种花

#### 问：
##### 沿山开田形如带，初春田上种花来。
##### 邻花争水双双败，怎有最多鲜花开?

· 一个条状田地，分成花垄若干，每个花垄可以种一棵花
· 如果两个花种在了相邻的位置上，则互相争夺生存条件，最后双双枯败
· 已知有N个连续位置，上面种花便用 1 表示，不种花则用 0 表示，给定初始分配（初始一定没有花相邻）
· 再往上面添加花，要在保证没有两花争斗的条件下，放置最多的花
例：6个位置，初始：1，0，0，0，1，0，此时只能在第3个位置上放花，最多可以再种植 1 朵花
例：8个位置，初始：0，1，0，0，0，0，0，1，此时可以在第4、第6位置种两朵花

问：在给定的初始条件下，为了放置最多的花，应当在哪些位置放置？最多可以再种几朵花？

##### 算法过程：
###### 从头寻，邻位花无有；
###### 可则插，再复向尾走。
###### 有花处，隔二必下手；
###### 寻至末，所插即所求。

```C++
long int ridge[10000];    //花垄，先可以记录下初始分布
//  注意：为了方便，数组 ridge【】 从ridge【1】开始取
int N;    //总共 N 个位置
int max=0;    //能够再种下花的最大数量

void Plant()
{
	for(i=1; i<=N; i++)
	{
		if(ridge[i]==0)    //如果这个位置没有花
		{
			if(i==N)
			{
				printf("在第%d个位置上种花\n",i);
				max++;
				break;
			}
			else
			{
				if(ridge[i+1]==0)
				{
					printf("在第%d个位置上种花\n",i);
					max++;
					i++;    //隔掉这个位置后面相邻的位置，因为这个地方已经种上花了
				}
				else continue;
			}
		}
		else    //如果这个位置有花
		{
			if(i==N||i+1==N) break;
			else
			{
				i+=1;    //隔掉有花位置后面相邻的位置
				continue;
			}
		}
	}

	printf("最大再种花数量为：%d\n",max);
	return ;
}
```

##### 总结：
###### 第一步：做出贪心选择：
· 从左到右考察，只要遇到合适的位置就插入
###### 第二步：考察后续影响：
· 种过花的地方，需要隔掉后面相邻的一个位置，跳格后再续考察后面


### 玖  沉船救生

#### 问：
##### 巨轮冰礁一恍间，千百旅客尽自难。
##### 救生船艇载有限，何以最少却保全。

· 将沉之船上有 N 名旅客，他们的体重不等，全部给出（假定 N 不超过20000）
· 救生艇最多可以救下两个人，且载重限度为 c（c 一定大于任何一个人单独的体重，保证所有人都能获救）
问：最少用多少救生艇，把所有的旅客全部救下？

##### 算法过程：
###### 千人身重小大排，首尾两两组队来。
###### 如若结伴超重限，重者独船先离开。

1. 将所有人按体重从小到大排序
2. 最轻的人和最重的人组队，将救生艇的空间尽可能大地利用
3. 如果两人组队超过重量限制，则体重大的人自己一艘救生艇，再让轻者与现场次重的人组队

```C++
int N;    //总共 N 位旅客
int weight[20005];    //记录这些旅客各自的体重

int compare(const void *a, const void *b)      //qsort 从小到大比较函数
{
	return *(int *)a - *(int *)b;
}

void Lifeboat()          //“lifeboat” 意为 “救生艇”
{
	qsort(weight, N, sizeof(weight[0]), compare);
	int left=0, right=N;    //左右“双针”
	int lifeboat_num=0;    //用来统计使用救生艇的个数

	while(1)
	{
		if(weight[left]+weight[right]<=c)
		{
			lifeboat_num+=1;
			left++, right--;
		}
		else
		{
			liftboat_num+=1;    //重者独自乘一艘救生艇
			while(right>left)
			{
				right--;
				if(weight[left]+weight[right]<=c)
				{
					lifeboat_num+=1;
					break;
				}
				else continue;
			}
		}
		if(left==right) lifeboat_num+=1;    //最后剩的一个人单独离开
		else if(left>right) break;
		else continue;
	}

	printf("最少需要救生艇的个数为:%d\n",lifeboat_num)；
	return ;
}
```

##### 总结：
###### · 贪心思想：
1. 一艘船最多可以载两个人，则优先考虑两两组合上船
2. 为了减少一个人占用一艘船的情况，优先考虑最重和最轻的人两两组队
###### · 双针共移：
1. 同时考察首尾两个人，如果可以组队则直接组队，两针向中间共移
2. 如果因为超重无法组队，则二人中较重的人独自乘船，右针左移，继续检验重量条件
3. 当两针“碰头”的时候，讨论此时是剩下了 1 人还是 0 人，再做出收尾的安排

【!】双针共移的思想：[[../双针共移 · 卷第四/双针共移 · 卷第四#^5a40e2]]
^eeafe7

### 拾  田地灌溉

#### 问：
##### 随山绵延条带田，块块田下有水源。
##### 每源可覆田不等，何凿最少可济全？

· 将条带状的田地抽象成一维的 x 轴，田地长度为 N，从 x=0 开始，到 x=N 结束
· 从 0 开始的每个整数点位均有泉眼，每口泉眼的灌溉半径不等，都是整数，均给出
· 某些泉眼的水量十分小，起不到灌溉田园的作用，其灌溉半径为 0
问：最少开凿多少口泉眼，可以灌溉整个田地没有遗漏？

例：当 N=5 时，有六个整数点位有泉眼，它们的灌溉半径分别为：3，4，1，1，0，0
![[卷第一-图/卷第一-图二.png|500]]
                  （图二：需要灌溉的区间是【0，5】，每处水源的灌溉范围已画出）
· i 点的灌溉范围为【i-r，i+r】，( i=1, 2, ……, N ) ，r 是给出的灌溉半径
· 如图二，只需要开凿 x=1 处的泉眼即可，x=1 处泉眼的覆盖范围为：【-3，5】

##### 算法过程：
###### 观局左向右，左手密不漏。
###### 右去多延展，片片铺至头。

· 从左边 0 开始，寻找可以覆盖 x=0 的泉眼，并找出向右侧覆盖到最远的
· 从上述最远的右侧点开始，再寻找可以覆盖那个点的泉眼，再找出向右侧覆盖到最远的，以此类推
· 结束时的两种情况：1. 最后一个水源能够覆盖到 x=N 的位置；2. 无法全部灌溉
· 注意灌溉的范围是闭区间，即灌溉半径是 0 的水源是没有任何作用的

```C++
typedef struct spring
{
	int data;    //泉眼编号
	int left;    //左侧覆盖到的位置
	int right;    //右侧覆盖到的位置
} Springs;
Springs S[100];

int N;    //最远的点横坐标

int compare(const void *a, const void *b)    // qsort 对结构体二级排序
{
	Springs c=*(Springs*)a;
	Springs d=*(Springs*)b;
	if(c.left!=d.left) return d.right-c.right;
	else return c.left-d.left;
}    //将所有泉眼的灌溉范围排序：优先右端点从大到小排序，其次左端点从小到大排序

void Irrigate()    //“irrigate” 意为 “灌溉”
{
	qsort(S, N+1, sizeof(S[0]), compare);
	int start=0;    //实时更新的起点位置
	int i=-1;
	queue <int> Q;    //用于存放选取的水源位置
	int water_number=0;    //开泉个数统计
	
	while(1)    //遍历寻找
	{
		i++;
		if(i>N) break;
		if(S[i].left>start) continue;
		else
		{
			Q.push(i);
			water_number+=1;
			start=S[i].right;
		}
		if(start>=N) break;
	}

	if(start<N) printf("田地无法全部灌溉\n");
	else    //输出答案
	{
		printf("最少要开凿 %d 口水源，它们是：\n");
		while(!Q.empty())
		{
			printf("%d\n",Q.front());
			Q,pop();
		}
	}

	return ;
}
```

##### 总结：
###### · 第一步：做出贪心选择：
从头开始，每次选择可以接续上一个最右端，且自身右端延伸到最远的水源
###### · 第二步：考察后续问题：
· 如果遍寻结束后，没有找到左端可以接上上一个的，则说明无法全部灌溉
· 如果有可以直接延伸到右侧端点（x=N）的，直接结束检索

