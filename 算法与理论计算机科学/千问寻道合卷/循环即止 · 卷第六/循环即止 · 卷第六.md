### 壹  逐位平方

#### 问：
##### 一数多位各平方，平方加和新数得。
##### 每数既得如此作，终值归一是否可？

· 给定一个正整数，每一位数字求平方，所有位的平方数加和，得到一个新数，如此循环操作
问：能否最后得到一个数：1 ？
【!】注意：给定的数可能在多少次循环后归一，也可能这个循环是无尽的，已知所有无尽的循环都一定存在循环节

##### 算法过程：
###### 几试即知规律浅，八数一出必循环。
###### 已见循环立终止，不见接续归一完。

· 所有循环的情况最后循环节都是：
4 -> 16 -> 37 -> 58 -> 89 -> 145 -> 42 -> 20 -> 4

```C++
int num;    //给定的数字
int sum=0;    //统计各位平方和

void Judge()
{
	while(1)
	{
		if(num==1)
		{
			printf("可以归一\n");
			break;
		}
		else if(num==4||num==16||num==37||num==58||num==89||num==145||num==42||num==20)
		{
			printf("无限循环\n");
			break;
		}
		else
		{
			while(num>0)
			{
				sum+=num%10;
				num=num/10;
			}
			num=sum;
			sum=0;
		}
	}
	
	return ;
}
```

##### 解二：
###### 几转循环归个位，只看个位何能可。
###### 为一为七能归一，其余尽是框套落。

· 所有的数经过若干次变换之后都会得到个位数，只要这个个位数不是 1 或 7，那么必定无尽循环

```C++
int num;    //给定的数字
int sum;    //逐位平方和

void Judge()
{
	while(1)
	{
		if(num/10==0)
		{
			if(num==1||num==7) printf("可以归一\n");
			else printf("无尽循环\n");
			break;
		}
		else
		{
			while(num>0)
			{
				sum+=num%10;
				sum=sum/10;
			}
			num=sum;
			sum=0;
		}
	}

	return ;
}
```

##### 解三：
###### 如若不知规律在，层层探寻亦无碍。
###### 动一跳二看参差，循环节段终得来。

· 快慢指针法：
· 一个用于记录每次转换一步的结果，一个用于记录每次转换两步的结果，两者相等时，中间的就是循环节的整数倍
· 这种方法常用于试探不知规律的循环节，虽然寻找的耗时比较长，但一定可以找到最后的解
· 快慢指针法是当循环停止条件不明时的较优算法
```C++
int num;    //给定的数字
int sum=0;    //逐项平方求和

void Judge()
{
	int num1=num, num2=num;    //原数字的两个拷贝
	while(1)
	{
		while(num1>0)
		{
			sum+=num1%10;
			num1=num1/10;
		}
		num1=sum;
		sum=0;

		if(num1==1)
		{
			printf("可以归一\n");
			break;
		}

		while(num2>0)
		{
			sum+=num2%10;
			num2=num2/10;
		}
		num2=sum;
		sum=0;
		while(num2>0)
		{
			sum+=num2%10;
			num2=num2/10;
		}
		num2=sum;
		sum=0;

		if(num2==1)
		{
			printf("可以归一\n");
			break;
		}
		else if(num1==num2)
		{
			printf("无尽循环\n");
			break;
		}
	}

	return ;
}
```

##### 总结：
###### · 对于可能无尽循环的寻解问题，判断循环应当停止的方法：
1.  特殊规律判断这是无限循环
2.  快慢指针法，当快慢指针（不一定真的存在，只是个形象的说法）的指向内容相同时，说明中间是循环节的整数倍

##### 解四：
###### 快慢参差得解迟，预算上限迭代次。
###### 限内得解可归一，到限循环即终止。

· 对于一个 k 位数，平方求和的最大值是 k * 81 ：
· 当 k 不大于 12 时，第一次变换的结果最大只有三位数
· 当 k 不大于 123 时，第一次变换的结果最大只有四位数，再变换最大只有三位数
· 如果是比较小的数字，迭代不出 15 次基本可以实现归一，除非无法归一，为了保险，可以增大预估循环次数
【!】不妨假设迭代 25 次，可以归一或出现八个循环标志数，即当循环大于 25 次后未归一，即可下定结论：无尽循环

```C++
int num;    //给定的数
int sum;    //逐项平方求和

void Judge()
{
	int times=25;
	while(times--)
	{
		while(num>0)
		{
			sum+=num%10;
			num=num/10;
		}
		if(sum==1)
		{
			printf("可以归一\n");
			return ;
		}
		else
		{
			num=sum;
			sum=0;
		}
	}

	printf("无尽循环\n");
	return ;
}
```

