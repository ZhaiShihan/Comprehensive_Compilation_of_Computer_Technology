### 壹  丢失数字

#### 问：
##### 众数排列从零起，趁乱乘机其一取。
##### 取后打乱看剩余，何以速寻丢失几？

· 原本为 N 个数，它们是从 0 到 N-1 的连续整数（ N >= 2 ）
· 打乱，随机取走一个，存入数组 number【·】
问：如何快速寻找到，丢失的数字是几？

例：
输入：4（代表原来4个数字）
      3  1  0
期待输出：2（输出缺失的数字）

##### 算法过程：
###### 既知原数本连续，何必漫寻苦遍历？
###### 众数求和看总值，勿忘本是等差序。

· 等差序列求和：(0+ N-1 ) * N/2
· 丢失后边输入边求和：sum
· 上下两值相减就是丢失的数字

```C++
#include<stdio.h>

int N;
int sum;    //众数求和

int main()
{
	scanf("%d",&N);
	for(int i=1; i<=N-2; i++)
	{
		int a;
		scanf("%d",&a);
		sum+=a;
	}
	printf("丢失的数字是：%d\n",N*(N-1)/2-a);
	return 0;
}
```


##### 解二：
###### 每数减角标，逐项求加和。
###### 最后去个数，加一取反得。

```C++
int N;
int sum;

int main()
{
	scanf("%d",&N);
	for(int i=0; i<=N-2; i++)
	{
		int a;
		scanf("%d",&a);
		sum+=a-i;
	}
	sum+=1;
	sum-=N;
	printf("丢失的数字是：%d\n",-sum);
	return 0;
}
```
##### 总结：
· 探寻给定条件的规律，利用更高级的规律求解，减少搜索次数
· 时间复杂度：O ( n )，除了必要的输入以外，没有额外的时间复杂度

#### 问二：
##### 一数失易得，逐项求加和。
##### 现令失两数，此时应如何？

· 原来是 N 个数，从中随机抽走两个并打乱（ N >= 3 ）
问：如何快速找出丢失的两个数？（从小到大输出）

##### 算法过程：
###### 等差求加和，两数之和得。
###### 平方求加和，平方之和得。
###### 二次方程组，双解即两者。

```C++
int N;
int sum=0;    //用于记录求和
int sum_2=0;    //用于记录平方求和

int main()
{
	scanf("%d",&N);
	for(int i=0; i<=N-3; i++)
	{
		int a;
		scanf("%d",&a);
		sum+=a;
		sum_2+=a*a;
	}

	int add=N*(N-1)/2-sum;    //丢失两数的加和
	int square=(N-1)*N*(2*N-1)/6-sum_2;    //丢失两数的平方和

	int p=powf((float)(2*square-add*add), 1/2);    // “根号Δ”
	printf("丢失的两个数是：%d和%d",add=p,add+p);
	return 0;
}
```

