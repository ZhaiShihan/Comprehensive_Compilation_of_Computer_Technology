### 壹  农夫过河

#### 问：
##### 一农牵领狼羊菜，欲载三物过河来。
##### 船有二位农占一，空余之位选一载。
##### 农民相守本无事，农去其羊必毁菜。
##### 又有灰狼逐羊乱，何能相安渡河来？

· 一位农民牵着狼和羊，带着一筐白菜，欲渡河
· 只有农民可以撑船，船上除了农民以外还可以载另一样东西
· 狼和羊在一起，若没有农夫看守，狼会威胁羊
· 羊和菜在一起，若没有农夫看守，羊会威胁菜
· 狼不会威胁到农夫，农夫和狼共船是可以的，不考虑过多的约束
问：如何才能让农夫带着狼、羊和白菜全都平安过河？

##### 算法过程：
###### 狼可逐羊羊毁菜，羊避两祸先离开。
###### 羊回剩余逐一试，最后携羊过河来。

· 深度搜素，去对岸分成四种情况：农夫带菜，农夫带羊，农夫带狼，农夫自己；回程也可分为这四种情况
· 每次去对岸选择四种情况之一，回程选择四种情况之一，用一个标记记录上一次的行动，避免对称循环：
· 例如：农夫带羊过河，又立刻带羊回来，这样构成了一个对称循环，需要用上一次的行动判定
· 判断一个行动是否合规：用一个判断函数实现：
· 当农夫在和原岸时，如果对岸同时出现狼羊对或羊菜对，则不合规；农夫在对岸时考察原岸，同理；不合规赋 0
· 如果农夫未在的一边不存在冲突对，则合规，合规函数赋值为 1
· 终止条件：只考察最后一步，最后一定是羊送回了原岸，此时狼和菜已被农夫运过河，因为此时农夫才敢分身接羊
· 深搜时记录每一步合规的行动，如果发现不合规，则结束本次函数调用，深搜的这条“路”不通
· 当最后达到终止条件时，以标记 flag 逐层结束递归，不建议用 goto 等打破结构的操作直接强制跳出递归

```C++
#include<stdio.h>
#include<string.h>

typedef struct stu
{
	int wolf=0;
	int sheep=0;
	int cabbage=0;
	int farmer=0;
} Everyone;    //在河原岸时，赋值为 0；在河对岸时，赋值为 1
Everyone E;

int Judge()    //当值是 0 时，说明这种情况不可；当值是 1 时，才可以继续下一步行动
{
	if(E.farmer==1)
	{
		if(E.wolf==0&&E.sheep==0) return 0;
		else if(E.cabbage==0&&E.sheep==0) return 0;
		else return 1;
	}
	else
	{
		if(E.wolf==1&&E.sheep==1) return 0;
		else if(E.cabbage==1&&E.sheep==1) return 0;
		else return 1;
	}
}

int step=0;    //记录这是第几步
char Notes[15][100];    //每一步的笔记

int last_step=0;    //记录上一步行动，避免对称循环执行同一步骤
//当 last_step=1 代表上一步动的是农夫和白菜；2 代表动的是农夫和羊；3 是农夫和狼；4 是农夫自己行动
int symbol=0;    //当 symbol 的值为 1 时，强制跳出递归循环

void How_to_go()
{
	if(E.cabbage+E.farmer+E.sheep+E.wolf==3&&E.sheep==0)  //当只有羊未过河，此事才达到正解
	{
		for(int i=1; i<=step; i++)
		{
			printf("STEP %d :  %s\n",i,Notes[i]);
		}
		step++;
		printf("STEP %d :  farmer comes to the origin alone\n",step);
		step++;
		printf("STEP %d :  farmer and sheep go to the opposite\n",step);
		printf("then, everyone goes across the river in safety\n");
		symbol=1;
		return ;
	}
	
	if(E.farmer==0)    //农夫在河原岸
	{
		if(E.cabbage==0&&last_step!=1)    //带白菜过河
		{
			E.farmer=1, E.cabbage=1;
			if(Judge()==0) E.farmer=0, E.cabbage=0;
			else
			{
				step++;
				strcpy(Notes[step], "farmer and cabbage go to the opposite");
				last_step=1;
				How_to_go();
				if(symbol==1) return ;
				step--;
			}
		}
		if(E.sheep==0&&last_step!=2)    //带羊过河
		{
			E.farmer=1, E.sheep=1;
			if(Judge()==0) E.farmer=0, E.sheep=0;
			else
			{
				step++;
				strcpy(Notes[step], "farmer and sheep go to the opposite");
				last_step=2;
				How_to_go();
				if(symbol==1) return ;
				step--;
			}
		}
		if(E.wolf==0&&last_step!=3)    //带狼过河
		{
			E.farmer=1; E.wolf=1;
			if(Judge()==0) E.farmer=0, E.wolf=0;
			else
			{
				step++;
				strcpy(Notes[step], "farmer and wolf go to the opposite");
				last_step=3;
				How_to_go();
				if(symbol==1) return ;
				step--;
			}
		}
		if(last_step!=4)    //农夫自己过河
		{
			E.farmer=1;
			if(Judge()==0) E.farmer=0;
			else
			{
				step++;
				strcpy(Notes[step], "farmer goes to the opposite alone");
				last_step=4;
				How_to_go();
				if(symbol==1) return ;
				step--;
			}
		}
	}
	
	else    //农夫在河对岸
	{
		if(E.cabbage==1&&last_step!=1)
		{
			E.farmer=0, E.cabbage=0;
			if(Judge()==0) E.farmer=1, E.cabbage=1;
			else
			{
				step++;
				strcpy(Notes[step], "farmer and cabbage come to the origin");
				last_step=1;
				How_to_go();
				if(symbol==1) return ;
				step--;
			}
		}
		if(E.sheep==1&&last_step!=2)
		{
			E.farmer=0, E.sheep=0;
			if(Judge()==0) E.farmer=1, E.sheep=1;
			else
			{
				step++;
				strcpy(Notes[step], "farmer and sheep come to the origin");
				last_step=2;
				How_to_go();
				if(symbol==1) return ;
				step--;
			}
		}
		if(E.wolf==1&&last_step!=3)
		{
			E.farmer=0; E.wolf=0;
			if(Judge()==0) E.farmer=1, E.wolf=1;
			else
			{
				step++;
				strcpy(Notes[step], "farmer and wolf come to the origin");
				last_step=3;
				How_to_go();
				if(symbol==1) return ;
				step--;
			}
		}
		if(last_step!=4)
		{
			E.farmer=0;
			if(Judge()==0) E.farmer=1;
			else
			{
				step++;
				strcpy(Notes[step], "farmer comes to the origin alone");
				last_step=4;
				How_to_go();
				if(symbol==1) return ;
				step--;
			}
		}
	}
}

int main()
{
	How_to_go();
	return 0;
}
```

##### 总结：
· 深度搜素，考察每一步的合理性，如果不合理则停止搜素，合理则继续，直到找到答案为止
· 这道题的输出结果唯一，可以用《卷第五》所述“推理寻找法”先将结果推出，然后直接用 “printf” 输出


### 贰  背包取舍

#### 问：
##### 宝物各有重，每每价不同。
##### 奈何力有限，逾之走不动。
##### 欲得值最高，试问取何种？

· n 种物品重量用数组 w 表示（从 w【1】开始），价值对应存入数组 v【·】中（均取整数）
· 物品只能整件装入，不可破坏或拆散，且每一个物品只能被取一次，不可重复选取
问：不同的装包方式下，最大价值是多少？

##### 算法过程：
###### 各物仔细察，取舍当考虑。
###### 留之有何弊，弃之有何利。
###### 每物取不取，须看最多益。

· 每种物品考察取不取，假设这个物品的价值是 v，其重量为 w
· 设取前背包剩余容量为 W，这个物品价值为 V：
1. 取这个物品，则目前的最优解应当是这个物品的价值 v 加上背包重量是 W -w 时的最优解
2. 不取这个物品，则目前的 V 仍是原值，W 也仍是原值
3. 比较这两个值的大小：<font color="#00b050">v + v ( W -w 时)</font> 和 <font color="#00b050">V </font>
4. 如果前者大，则这个物品取；如果后者大，则这个物品不取，得到的结果是背包重量为 W 下的最优解
5. 继续考察下一个物品，对于后面的某一个物品来说，第 4 步的 W 可能就充当了第 1 步的 W -w 这一值

![[卷第七-图/卷第七-图一.png]]
（图一：背包问题最优结构考量的举例）

· 对于每一个格子，只考虑它左上方的区域（第零行表示取的是空物品）
· 以<font color="#00b0f0">第二行第五列</font>为例：
1. 取第二行的物品，它的重是 3，价值是 5，取后背包容量为 2，价值为 5，则再加上背包容量是 2 时的最优解 3（取自上一行的第二列，不要取本行，因为物品不能取重复），得到取物品时的最优解为 8
2. 不取第二行的物品，则目前总价值继承前一行该列的值 3
3. 3 < 8，故取第一种方案，即取这一个物品，将第二行第三列格子更新为 8
· 再考察<font color="#00b0f0">第三行第六列</font>：
1. 取第三行的物品，它的重是 4，价值是 6，取后背包容量为 2，价值为 6，再加上背包容量是 2 时的最优解 3（取自上一行的第二列，不要取本行，因为物品不能取重复），得到取物品时的最优解为 9
2. 不取第三行的物品，则目前总价值继承前一行该列的值 8
3. 8 < 9，故取第一种方案，即取这一个物品，将第三行第六列格子更新为 9

###### 代码实现：
```C++
int w[1000];
int v[1000];
//用于存放每个物品的重量和价值，数组从角标为 1 开始更方便
int n;    //物品的总个数
int limit;    //重量的总上限

void DP(int w[], int v[], int n)
{
	int dp[n][n]={0};
	for(int i=1; i<=n; i++)
	{
		for(int j=1; j<=n; j++)
		dp[i][j]=(dp[i-1][j]<(dp[i-1][j-w[i]]+v[i])? dp[i-i][j-w[i]]+v[i]: dp[i-1][j]);
	}

	printf("背包的最大价值为：\n",dp[n][limit]);
	return;
}
```

##### 总结：
###### · 动态规划的常用形式：二维数组存储所有的最优子结构，遍历整个二维数组，用二重循环形式，在两层循环中比较取与不取的值的大小，保证每一个“格子”中的值都是尽可能最大的，即最优子解

##### 回溯算法：
###### 每物取舍相组合，从前至尾各定夺。
###### 容量超限立回返，再探他路有何得。

1. 考察第一个物品，有取或不取两条路
	1. 走取的一条路，则考察第二个物品取或不取
		1. 走取的一条路，考察第三个物品取或不取
		2. 走不取的一条路，考察第三个物品取或不取
		……………………
	2. 走不取的一条路，考察第二个物品取或不取
		1. 走取的一条路，考察第三个物品取或不取
		2. 走不取的一条路，考察第三个物品取或不取
		……………………
2. 开始回溯的条件有二：
	1. 重量达到限制，不能再装入物品
	2. 所有的物品讨论完毕
3. 每次记录最大价值，这个值随着回溯与深入的进行动态更新

###### 代码实现：
```C++
int w[1000];
int v[1000];    //重量和价值
int n;    //物品个数
int limit;    //背包重量限制
int max=0;    //最大的价值
int value=0;    //当前价值累计
int weight=0;    //当前累计重量
int step=0;    //当前考察的是第几个物品

void BackTracking()
{
	step++;
	if(step==n+1)
	{
		max=(value>max? value: max);
		goto mark;
	}
	if(w[step]+weight<=limit)    //取这个物品的递归
	{
		value+=v[step];
		weight+=w[steo];
		BackTracking();
		weight-=w[step];
		value-=v[step];
	}
	BackTracking();    //不取这个物品的递归
	mark:;
	step--;
}
//最后的 max 值即为所求
```

##### 总结：
###### · 回溯算法的常用形式：前进迭代+终止条件+深入分支+剪枝+回退迭代
· 在这一代码中：
1. <font color="#fac08f">前进迭代</font>：step++；
2. <font color="#92cddc">终止条件</font>：step=n+1；
3. <font color="#b2a2c7">深入分支</font>：a. value+=v，BackTracking()，value-=v（取）；b. BackTracking()；（舍）
4. <font color="#c3d69b">剪枝</font>：w【step】+ weight <= limit；
5. <font color="#ffffcc">回退迭代</font>：step--；

