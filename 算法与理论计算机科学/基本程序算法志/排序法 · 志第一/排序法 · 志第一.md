### 壹  排序概述

#### 述：
##### 漫天星海阵点点，衡开枢摇权玑璇。
##### 盘中散子各有法，明灯北斗一线连。

#### 何为排序？

##### · 将一组“无序”的记录序列调整为“有序”的记录序列称为“排序”
###### · 假设含n个记录的序列为 { R1, R2, …，Rn }
###### · 其相应的关键字序列为 { K1, K2, …，Kn }
###### · 这些关键字相互之间可以进行比较，即在它们之间存在着关系：Kp1 ≤ Kp2 ≤ …… ≤ Kpn
###### · 按此固有关系将上式记录序列重新排列：{ Rp1, Rp2, …，Rpn }，这样的操作就称为<font color="#92d050">排序</font>

#### 排序的稳定性：
##### · 在待排记录序列中，任何两个关键字相同的记录，用某种排序方法排序后相对位置不变，则称这种排序方法是稳定的，否则称为不稳定的

![[志第一-图/志第一-图一.png|600]]
                            （图一：排序的稳定性图示）
#### 排序方法的分类：
##### · 按照是否访问外存：
###### 1. 内部排序：整个排序过程不需要访问外存
###### 2. 外部排序：若参加排序的记录数量很大，整个序列的排序过程不可能在内存中完成
##### · 内部排序方法的分类：
###### · 根据设置有序序列的方式的不同，排序方法可以分为：
1. 插入排序：直接插入排序、折半插入排序、希尔排序
2. 交换排序：冒泡排序、快速排序
3. 选择排序：简单选择排序、堆排序
4. 归并排序：2-路归并排序
5. 基数排序
##### · 待排记录的数据类型定义：
```C++
#define MAXSIZE 1000    //待排顺序表最大长度

typedef struct    //待排记录
{
	int key;    //关键字项
	char otherinfo;    //其他数据项
} RcdType;

typedef struct    //顺序表
{
	RcdType r[MAXSIZE+1];    // r[0] 闲置
	int length;    //顺序表长度
} SqList;
```


### 贰  插入排序

#### 述：
##### 棋盘散子落，次次取一颗。
##### 细思归何处，每步几腾挪。

![[志第一-图/志第一-图二.png|550]]
                            （图二：插入排序的粗略原理示意）
###### · 插入排序（ Insertion Sort ）的基本思想：
1. 在 R【1】到 R【i -1】中查找 R【i】的插入位置：
	R【1 … j 】.key  <=  R【i】.key  <=  R【 j+1 … i-1 】.key
2. 将 R【 j+1 … i-1 】中的所有记录均后移一个位置
3. 将 R【i】插入（复制）到 R【j +1】的位置上

##### 一、直接插入排序：
###### · 利用<font color="#00b0f0">顺序查找</font>实现在R【 1 … i -1 】中查找 R【i】的插入位置
###### · 基本思想：
1. 监视哨设置在 R【0】；R【0】=R【i】
2. 从 R【 i -1 】起向前顺序查找，直到找到插入位置
	for ( j = i -1 ;  R【0】.key < R【0】.key ;  j-- )
（ 插入位置是：j +1 ）
![[志第一-图/志第一-图三.png]]
（图三：直接插入排序的图示）
###### · 插入方法：把从 j +1 到 i -1 的所有数据向后移动一位
###### <font color="#ffc000">· 代码实现：</font>
```C++
#define MAXSIZE 1000    //待排顺序表最大长度

typedef struct    //待排记录
{
	int key;    //关键字项
	char otherinfo;    //其他数据项
} RcdType;

typedef struct    //顺序表
{
	RcdType r[MAXSIZE+1];    // r[0] 闲置
	int length;    //顺序表长度
} SqList;

void InsertionSort(SqList &L)
{
	//对顺序表 L 进行直接插入排序
	for(int i=2; i<=L.length; i++)
	{
		L.r[0]=L.r[i];    //复制为监视哨
		int j;
		for(j=i-1; L.r[0].key<L.r[j].key; j--)
		{
			L.r[j+1]=L.r[j];    //查找+后移
		}
		L.r[j+1]=L.r[0];    //插入到正确位置
	}
	return ;
}
```

###### · 直接插入排序的时间复杂度分析：
【注：实现内部排序的基本操作有两个：1. <font color="#ffc000">比较</font>序列中两个关键字的大小；2. <font color="#ffc000">移动</font>记录】
· 直接插入排序的平均时间复杂度为：O ( n ^2 )
###### · 直接插入排序的特点：
1. 算法简单
2. 存储结构：顺序、链式
3. 时间复杂度为 O ( n ^2 )
4. 空间复杂度为 O ( 1 )
5. <font color="#00b0f0">稳定</font>的排序法
6. 适用范围：
	1. 若待排序记录按关键码基本有序时，直接插入排序的效率可以大大提高
	2. 由于直接插入排序算法简单，则在待排序记录数量 n 较小时效率也很高

##### 二、折半插入排序：
###### · 利用<font color="#00b0f0">折半查找</font>实现在R【 1 … i -1 】中查找 R【i】的插入位置
###### <font color="#ffc000">· 代码实现：</font>
```C++
void BInsertionSort(SqList &L)
{
	//对顺序表 L 进行折半插入排序
	for(int i=2; i<=L.length; i++)
	{
		L.r[0]=L.r[i];    //复制监视哨
		int low=1, high=i-1;
		while(low<=high)
		{
			int m=(low+high)/2;
			if(L.r[0].key<L.r[m].key) high=m-1;
			else low=m+1;
		}
		for(int j=i-1; j>=low; j--)
		{
			L.r[j+1]=L.r[j];    //后移
		}
		L.r[low]=L.r[0];    //插入到正确位置
	}
	return ;
}
```

###### · 折半插入法的平均时间复杂度为： O ( n ^2 )

##### 三、希尔排序（ Shell 's sort ）：
###### · 希尔排序又称缩小增量排序（ Diminishing Increment Sort ）
###### · 基本思想：对待排记录序列先作“宏观”调整，再作 “微观”调整
1. 对数据分组，在各组内进行直接插入排序
2. 进行若干次使待排记录基本有序
3. 对全部记录进行一次顺序插入排序
###### · 分组的方式：将 n 个记录分成 d 个子序列
<font color="#fac08f">{ R【1】，R【1+d】，R【1+2d】，…，R【1+kd】 }</font>
<font color="#fac08f">{ R【2】，R【2+d】，R【2+2d】，…，R【2+kd】 }</font>
<font color="#fac08f">……</font>
<font color="#fac08f">{ R【d】，R【2d】，R【3d】，…，R【kd】，R【 (k+1) d】 }</font>
###### <font color="#b7dde8">· d 称为增量，它的值在排序过程中从大到小逐渐缩小，直至最后一趟排序减为 1</font>
![[志第一-图/志第一-图四.png|550]]
                             （图四：11 个元素的希尔排序举例）
###### <font color="#ffc000">· 代码实现：</font>
```C++
void ShellInsert(SqList &L, int dk)    // dk 为增量
{
	//一趟希尔插入排序
	for(int i=dk+1; i<=L.length; i++)
	{
		L.r[0]=L.r[i];    //暂存于 r[0]
		for(int j=i-dk; j>0&&(L.r[0]key<L.r[j].key); j-=dk)
		{
			L.r[j+dk]=L.r[j];    //查找并后移
		}
		L.r[j+dk]=L.r[0];    //插入
	}
}

int dlta[]={5, 3, 1};    //增量序列
int t=3;    //增量数

void ShellSort(SqList &L)
{
	//增量为 dlta【·】 的希尔排序
	for(int k=0; k<t; k++)
	{
		ShellInsert(L, dlta[k]);
	}
}
```

###### · 希尔排序的时间复杂度分析比较复杂，往往与增量数有关，但已知它的复杂度一定在 O ( n ^2 ) 以下
###### · 希尔排序的时间复杂度记为 O ( n ^m )，m∈【1，2）
###### · m 的具体取值视情况而定，很多情况下的估算是： m ≈ 1.3


### 叁  选择排序

#### 述：
##### 林中各木高不齐，本自散乱却求序。
##### 取得至高另起列，每看剩余抽第一。

###### · 选择排序（ Selection Sort ）：
##### 一、简单选择排序：
![[志第一-图/志第一-图五.png|600]]
                             （图五：简单选择排序的基本原理）
![[志第一-图/志第一-图六.png|300]]
                               （图六：简单选择排序不稳定）
###### <font color="#ffc000">· 代码实现：</font>
```C++
int SelectMinkey(int *R, int i, int n)
{
	//在 R[i…n] 中选择关键字最小的记录
	int min_node=0;
	for(int j=i; j<n; j++)
	{
		if(R[j]<R[min_node]) min_node=j;
	}
	return min_node;
}

void SelectSort(int R[], int n)
{
	//对记录序列 R[1…n] 进行简单选择排序
	for(int i=0; i<n; i++)
	{
		//选择第 i 小的记录，并交换到位
		int j=SelectMinkey(R, i, n);    //在 R[i… n-1] 中选择关键字最小的记录
		if(i!=j)
		{
			int temp=R[i];
			R[i]=R[j];
			R[j]=temp;
		}    //与第 i 个记录交换
	}
}
```

###### · 简单选择排序时间复杂度：O ( n ^2 )

##### 二、树型选择排序（ Tree Selection Sort ）：
###### · 选择最小关键字，比较 n -1 次
###### · 选择其他当前最小关键字：（ log n ）
###### · 排序的时间复杂度：O ( n logn )
###### · 排序的空间复杂度：O ( n )
###### · 树型选择排序又称“锦标赛排序（ Tournament Sort ）”：
![[志第一-图/志第一-图七.png]]
（图七：树型选择排序的原理示意）
###### · 树型选择排序的关键是构建完全二叉树

##### 三、堆排序（ Heap Sort ）：
###### · 堆排序的一般过程：
1. 建立初始堆
2. 将堆顶元素与最后一个元素对换
3. 调整堆
###### · 基于初始堆进行堆排序：（大顶堆）
1. 最大堆堆顶 R【1】具有最大的排序码, 将 R【1】与 R【n】对调, 把具有最大排序码的对象交换到最后
2. 对前面的 n -1 个对象，使用堆的调整算法重新建立最大堆, 具有次最大排序码的对象上浮到 R【1】位置，这一过程称为“筛选”
3. 对调 R【1】和 R【n -1】,调用调整算法, 对前 n -2 个对象重新调整
4. 如此反复执行，最后得到全部排序好的对象序列
###### · 堆排序的时间复杂度分析：
1. 含有 n 个关键字的完全二叉树的深度 h = log<sub>2</sub> n（向下取整）+ 1
2. 对深度为 h 的堆，“筛选”所需进行的关键字比较的次数至多为 2（ h -1 ）= 2 log<sub>2</sub> n（向下取整）
3. 建堆的复杂度：对 n 个关键字，建立深度为 h 的堆，所需进行的关键字比较的次数 t：
	· 建立初始堆需要对 n /2（向下取整）棵子树进行调整
	· 第 i 层上的结点至多为 2<sup>i-1</sup> 个，以它们为根的子树的深度为：h - i +1
![[志第一-图/志第一-图八.png]]
（图八：堆排序的时间复杂度中关键字比较次数 t 的推导）
· 由此可得，堆排序的<font color="#ff00ff">最坏</font>时间复杂度为：<font color="#ff00ff">O ( n logn )</font>
###### · 堆排序的特点：
1. 最坏时间复杂度为：O ( n logn )
2. 空间复杂度：1 个记录空间，O ( 1 )
3. 稳定性：堆排序是<font color="#ffff00">不稳定</font>的排序
4. 适合于 n 较大的情况


### 肆  交换排序

#### 述：
##### 
##### 

###### · 交换排序基本思想：将待排记录中两两记录关键字进行比较，若逆序则交换位置

##### 一、冒泡排序：
![[志第一-图/志第一-图九.png|300]]
                                （图九：冒泡排序示例）
###### <font color="#ffc000">· 代码实现：</font>
```C++
void BubbleSort(int R[], int n)
{
	//气泡排序：从小到大排列
	for(int i=0; i<n-1; i++)
	{
		for(int j=i; j<n-1; j++)
		{
			if(R[j+1]>R[j])
			{
				int temp=R[j+1];
				R[j+1]=R[j];
				R[j]=temp;
			}
		}
	}
	return ;
}
```

###### · 冒泡排序分析：
1. 时间复杂度：O ( n ^2 )
2. 空间复杂度：O ( 1 )
3. 稳定性：冒泡排序是<font color="#ffff00">稳定</font>的排序

##### 二、快速排序：

###### · 快速排序基本思想：
1. 通过一趟排序将待排记录分割成两部分
2. 一部分记录的关键字比另一部分的小
3. 选择一个关键字作为分割标准，称为“pivot”（基点、枢轴）
###### · 基本操作：
1. 选定一记录 R（ pivot ），将所有其他记录关键字 k ' 与该记录关键字 k 比较
	1. 若 k ' < k，则将记录换至 R 之前
	2. 若 k ' > k，则将记录换至 R 之后
2. 继续对 R 前后两部分记录进行快速排序，直至排序范围为 1
![[志第一-图/志第一-图十.png|550]]
	                       （图十：快速排序的枢轴工作原理）
###### · 快速排序实施过程：
1. 设初始时：
	· low 指针指向第一个记录
	· high 指针指向最后一个记录
2. 对于一趟快速排序，将第一个记录设置为 pivot
3. 从表的两端交替地向中间扫描，直到两个指针相遇
	· 先从高端扫描：找到第一个比 pivot. key 小的记录，将该记录移动到 low 指针指向的地方
	· 再从低端扫描
4. 将 pivot 移动到 low 指针位置，并返回该位置
###### <font color="#ffc000">· 代码实现：</font>
```C++
int Partition(SqList &L, int low, int high)    //"partition"意为“分治”
{
	//对顺序表 L 中子表 r[low…high] 的记录进行一趟快速排序，并返回 pivot 记录所在位置
	L.r[0]=L.r[low];    //用第一个记录作 pivot 记录
	int pivotkey=L.r[low].key;    // pivotkey 是 pivot 的关键字
	while(low<high)
	{
		//从表的两端交替地向中间扫描
		while(low<high&&L.r[high].key>=pivotkey)
		{
			high--;
		}
		L.r[low]=L.r[high];
		while(low<high&&L.r[low]<=pivotkey)
		{
			low++;
		}
		L.r[high]=L.r[low];
	}    //交替扫描结束
	L.r[low]=L.r[0];    // pivot 位置
	return low;    //返回 pivot 位置
}

void Qsort(SqList &L, int low, int high)
{
	//对顺序表 L 中的子序列 L.r[low…high] 快速排序
	if(low<high)    //递归结束条件
	{
		int pivotloc=Partition(L, low, high);    //枢轴的位置
		Qsort(L, low, pivotloc-1);
		Qsort(L, pivotloc+1, high);
	}
	return ;
}

void QuickSort(SqList &L)
{
	//对顺序表 L 进行快速排序
	Qsort(L, 1, L.length);
	return ;
}
```

###### · 快速排序的特点：
1. 存储结构：顺序
2. 时间复杂度：
	1. 最坏情况：每次划分选择的 pivot 是最大或最小元素
	2. 最坏情况的时间复杂度为 O ( n ^2 )
	3. 最好情况（每次划分折半）：O ( n log<sub>2</sub>n )
	4. 平均时间复杂度为 O ( n log<sub>2</sub>n )
3. 空间复杂度：
	1. 最坏情况：O ( n )
	2. 最好情况（每次划分折半）：O ( log<sub>2</sub>n )
	3. 平均空间复杂度：O ( log<sub>2</sub>n )
4. 稳定性：不稳定

##### · 改进的快速排序：
###### <font color="#ffff00">1. 小序列用直接插入排序：</font>
```C++
#define CutOff 5    //假设定义 CutOff 的值为 5，当递归子序列长度小于 CutOff 时，直接用插入排序

void InsertionSort(int *&R, int low, int high)
{
	//对顺序表 L 进行直接插入排序
	for(int i=low+1; i<=high; i++)
	{
		R[0]=R[i];    //复制为监视哨
		int j;
		for(j=i-1; R[0]<R[j]; j--)
		{
			R[j+1]=R[j];    //查找+后移
		}
		R[j+1]=R[0];    //插入到正确位置
	}
	return ;
}

int Partition(int *&R, int low, int high)    //"partition"意为“分治”
{
	//对顺序表 L 中子表 r[low…high] 的记录进行一趟快速排序，并返回 pivot 记录所在位置
	R[0]=R[low];    //用第一个记录作 pivot 记录
	int pivotkey=R[low];    // pivotkey 是 pivot 的关键字（值）
	while(low<high)
	{
		//从表的两端交替地向中间扫描
		while(low<high&&R[high]>=pivotkey)
		{
			high--;
		}
		R[low]=R[high];
		while(low<high&&R[low]<=pivotkey)
		{
			low++;
		}
		R[high]=R[low];
	}    //交替扫描结束
	R[low]=R[0];    // pivot 位置
	return low;    //返回 pivot 位置
}

void Qsort(int *&R, int low, int high)
{
	if(high-low<CutOff) InsertionSort(R, low, high);
	else
	{
		int pivotloc=Partition(R, low, high);    //枢轴的位置
		Qsort(R, low, pivotloc-1);
		Qsort(R, pivotloc+1, high);
	}
	return ;
}

void QuickSort(int *R, int n)
{
	Qsort(R, 0, n-1);
	return ;
}
```

###### <font color="#ffff00">2. 三平均分区法（ median - of - three ）：</font>
###### · 尽量将 pivot 取在中间位置
###### · low，center，high 指示的记录关键字“三值”取中
![[志第一-图/志第一-图十一.png|700]]
                            （图十一：median3 法示意）
###### · center 是 low 和 high 中间的那个数，即区间的中位数
###### · 将 R【low】，R【center】，R【high】中第二大的数（中间数）作为 pivot 的值

```C++
int Mid(int *&R, int low, int high, int middle)
{
	if((R[high]<=R[middle]&&R[middle]<=R[low])||(R[low]<=R[middle]&&R[middle]<=R[high]))
	{
		int temp=R[middle];
		R[middle]=R[low];
		R[low]=temp;
		return R[middle];
	}
	else if((R[middle]<=R[high]&&R[high]<=R[low])||(R[low]<=R[high]&&R[high]<=R[middle]))
	{
		int temp=R[high];
		R[high]=R[low];
		R[low]=temp;
		return R[high];
	}
	else return R[low];
}

int Partition(int *&R, int low, int high)    //"partition"意为“分治”
{
	//对顺序表 L 中子表 r[low…high] 的记录进行一趟快速排序，并返回 pivot 记录所在位置
	int middle=(high+low)/2;
	int pivotkey=Mid(R, low, high, middle);
	while(low<high)
	{
		//从表的两端交替地向中间扫描
		while(low<high&&R[high]>=pivotkey)
		{
			high--;
		}
		R[low]=R[high];
		while(low<high&&R[low]<=pivotkey)
		{
			low++;
		}
		R[high]=R[low];
	}    //交替扫描结束
	R[low]=pivotkey;    // pivot 位置
	return low;    //返回 pivot 位置
}

void Qsort(int *&R, int low, int high)
{
	if(low<high)
	{
		int i=Partition(R, low, high);    //枢轴的位置
		Qsort(R, low, i-1);
		Qsort(R, i+1, high);
	}
	return ;
}

void QuickSort(int *R, int n)
{
	Qsort(R, 0, n-1);
	return ;
}
```

###### · 对于三平均分区法还可以进一步扩展：
median - of - ( 2 t +1 )：
在选取中轴值时，可以从由左中右三个中选取扩大到五个元素中或者更多元素 (2t+1) 中选取

###### <font color="#ffff00">3. 三区间划分法：</font>
###### · 当序列中有许多相同元素时，某些分区的所有元素值可能都相等
· 划分三个区间：
	· 一块是小于中轴值的所有元素
	· 一块是等于中轴值的所有元素
	· 一块是大于中轴值的所有元素

###### · 快速排序分析：
· 快速排序的基本思想是基于分治策略的，对于输入的子序列，如果规模足够小则直接进行排序（比 如用前述的冒泡、选择、插入排序均可），否则分三步处理：
1. 分解（ Divide ）：将待排序列划分为两个非空子序列，使前面任一元素的值不大 于后面元素的值
2. 递归求解（ Conquer ）：通过递归调用快速排序算法，分别对前后两个子区间进行排序
3. 合并（ Merge ）：由于对分解出的两个子序列的排序是原地进行的，所以整个序列自然合并
· 这个解决流程是符合分治法的基本步骤的，因此，<font color="#00b0f0">快速排序法是分治法的经典应用实例之一</font>


### 伍  归并排序

#### 述：
##### 二分脉岭重重叠，各逐龙首对对排。
##### 云遮日照明复灭，阴阳五行去还来。

![[志第一-图/志第一-图十二.png|550]]
                              （图十二：归并排序原理图示）
###### · 归并：将两个或两个以上有序表组合成一个新的有序表：
· 每个小区间内部有序，每两个有序小区间再合成一个有序“大”区间，依此类推，层层进行
###### · 2-路归并排序：
· 设初始序列含有 n 个记录，则可看成 n 个有序的子序列，每个子序列长度为 1
· 两两合并，得到 n/2 个长度为 2 或 1 的有序子序列
· 再两两合并，如此重复，直至得到一个长度为 n 的有序序列为止
###### · 逆序：如果要求 R【·】数组从小到大排序，则任意一对 i < j，有 R【i】> R【j】，则这是一对逆序
###### <font color="#ffc000">· 代码实现：</font>（这个代码同时可以计算出逆序对的个数，效率远大于冒泡）
```C++
#define MAXSIZE 1000

int inverse_number=0;    //逆序个数

void MergeSort(int *R, int left, int middle, int right)
{
	int i=left, j=middle+1;    //将待考察区间折半，i 是左区间的头， j 是右区间的头
	int storage[1000];    //用于存放排序后的数组
	int k=left;    //指示 storage 的头，用于标记 storage 现在存储到了哪个位置
	//原理：左右区间均从头考察，例：左区间的头小于右区间，则在 storage 数组中存放左区间的头，左标记右移
	while(i<=middle&&j<=right)
	{
		if(R[i]<=R[j])
		{
			storage[k]=R[i];
			i++, k++;
		}
		else
		{
			storage[k]=R[j];
			inverse_number+=middle+1-i;    //中间这些全是逆序（小区间内部有序性）
			j++, k++;
		}
	}
	while(i<=middle)    //如果左区间有剩余，则全部存储到 storage
	{
		storage[k]=R[i];
		i++, k++;
	}
	while(j<=right)    //如果右区间有剩余，则全部存储到 storage
	{
		storage[k]=R[j];
		j++, k++;
	}
	for(int l=left; l<=right; l++) R[l]=storage[l];    //将 storage 中排好序的内容归还给 R 数组
}

void divide(int *R, int left, int right)
{
	if(right>left)
	{
		int middle=(left+right)/2;
		divide(R, left, middle);
		divide(R, middle+1, right);                     //分
		MergeSort(R, left, middle, right);           //治
	}
}

int main()
{
	int R[MAXSIZE]={0};
	int n;    // R 数组有效长度
	/* R 数组读取值操作，如输入*/
	divide(R, 1, n);    //或：divide(0, n-1);
	printf("逆序对的个数为 %d\n",inverse_number);
	return 0;
}
```

###### · 归并排序的时间复杂度：O ( n logn )
（共进行 log<sub>2</sub>n （向上取整）趟归并，每趟对 n 个记录进行归并）
###### · 归并排序的空间复杂度：O ( n )
###### · 归并排序是<font color="#00b0f0">稳定</font>的排序

##### · 注：斯特林公式：n ! = ( 2πn ) ^ (1/2) · ( n /e ) ^ n


### 陆  基数排序

#### 述：
##### 散列争序逐位比，可从高起从低起。
##### 一层铺是一层序，取尽自能分高低。

###### · 基数排序（ Radix Sorting ）：借助多关键字排序的方法对单关键字排序
	· 最高位优先（ MSD：Most Significant Digit first ）
	· 最低位优先（ LSD：Least Significant Digit first ）
例：对 52 张扑克牌排序，花色优先：
![[志第一-图/志第一-图十三.png|500]]
                            （图十三：扑克牌花色优先排序）
· 先按花色分类，再按面值分类：最高位优先
· 先按面值分类，再按花色分类：最低位优先
![[志第一-图/志第一-图十四.png|400]]
                          （图十四：最高位优先:：先按照花色分为 4 堆）
![[志第一-图/志第一-图十五.png|400]]
                            （图十五：一堆按面值从小到大排列）
· 高位优先（HSD）：先通过一次分配将数据分成多个组，然后对各组数据分别进行排序
· 低位优先（LSD）：通过多次对全体数据集的分配和收集即可实现排序
![[志第一-图/志第一-图十六.png|500]]
                          （图十六：链式基数排序，最低位优先）
![[志第一-图/志第一-图十七.png|500]]
                         （图十七：续链式基数排序，最低位优先）
######  · 静态链表实现法：
```C++
#define MAX_NUM_KEY 3    //关键字个数
#define RADIX 10    //关键字的基数
#define MAXSIZE 10000

typedef struct
{
	int key[MAX_NUM_KEY];    //关键字：每一“格”只存放一位数
	int next;
} SLCell;    //静态链表的结点类型

typedef struct
{
	SLCell R[MAXSIZE];    //静态链表空间
	int bitnum;    //关键字位数
	int rednum;    //记录个数
} SLList;
```
###### · 计数桶法：
```C++
#include<stdio.h>
#include<queue>
using namespace std;

typedef struct
{
	int data;    //记录的值
	int key[10];    //关键字：每一“格”只存放一位数
} Node;    //结点类型

queue <Node> Que[10];    //数组的每一“格”都是一个队列，用于存放某位数拥有对应数字的结点

int e(int x)    //求 10 的 x 次方
{
	if(x==0) return 1;
	else if(x<0) return 0;
	else
	{
		int q=1;
		for(int i=1; i<=x; i++) q*=10;
		return q;
	}
}

void LSD_RadixSort(Node *R, int n, int digit)
//三个参数：待排记录数组、待排记录个数、数字位数
{
	while(digit--)
	{
		int pt=0;
		
		for(int i=1; i<=n; i++)
		{
			Que[R[i].key[digit]].push(R[i]);    //结点存入对应的队列
		}
		for(int i=0; i<=9; i++)
		{
			while(!Que[i].empty())
			{
				R[++pt]=Que[i].front();
				Que[i].pop();
			}
		}
		if(pt!=n)
		{
			printf("LSD_RadixSort 函数运行错误\n");
			return ;
		}
	}
}

int main()
{
	int n;    //待排记录个数
	Node R[10000];    //待排记录数组
	int digit;    //数字位数
	
	scanf("%d",&n);    //输入待排记录的个数
	scanf("%d",&digit);    //输入待排记录的数字位数
	for(int i=1; i<=n; i++)
	{
		int a;
		scanf("%d",&a);
		R[i].data=a;
		for(int j=0; j<=digit-1; j++)
		{
			R[i].key[j]=a/e(digit-1-j);
			a%=e(digit-1-j);
		}
	}    //输入及处理部分结束

	LSD_RadixSort(R, n, digit);
	printf("排序结果：\n");
	for(int i=1; i<=n-1; i++) printf("%d ",R[i].data);
	printf("%d\n",R[n].data);
	return 0;
}
```


###### · 基数排序分析：
1. 时间复杂度：O ( d ( n +r ) )
2. 空间复杂度：O ( n +r )
3. 基数排序是<font color="#ffff00">稳定</font>的排序


### 柒  其他排序方法

#### 述：
##### 
##### 

#### 1. 哈希排序
###### · 已知一个含有 m（m < n）个记录的序列，其关键字为整数，其取值范围是【0，n），没有重复数字：
![[志第一-图/志第一-图十八.png|600]]
                              （图十八：哈希排序的条件）
```C++
int R[1000];    //待排记录数组
int n;    //待排记录上限（开区间）

void HashSort(int *R, int n)
{
	int Hash_arr[10000]={0};
	for(int i=0; i<n; i++)
	{
		Hash_arr[R[i]]=1;
	}
	int pt=0;
	for(int i=0; i<n; i++)
	{
		if(Hash_arr[i]>0) R[pt++]=i;
	}
	return ;
}
```

#### 2. 计数排序
###### · 已知一个含有 m 个记录的序列，其关键字为整数，其取值范围是【0，n），可能有重复数字：
![[志第一-图/志第一-图十九.png|550]]
                             （图十九：计数排序的原理）
```C++
int R[1000];    //待排记录数组
int n;    //待排记录上限（开区间）

void CountingSort(int *R, int n)
{
	int counting_arr[10000];
	for(int i=0; i<n; i++)
	{
		counting_arr[R[i]]++;
	}
	int pt=0;
	for(int i=0; i<n; i++)
	{
		while(counting_arr[i]--) R[pt++]=i;
	}
	return ;
}
```

#### 3. 桶排序
###### · 例：给定待排记录： { 49，2，16，87，25，68，38，35，97，76，73，27，49 }
###### · 数据都在【0，100）的区间之内
![[志第一-图/志第一-图二十.png|600]]
                               （图二十：桶排序举例）
###### · 再分别对桶内数据进行排序
###### <font color="#ffc000">· 代码实现：</font>
```C++
int R[1000];    //待排记录数组
int n;    //待排记录个数

typedef struct
{
	int arr[1000];    //“桶”数组
	int node;    //定位指针
} Bucket;
Bucket B[5];

int compare(const void *a, const void *b)
{
	return *(int *)a - *(int *)b;
}

void BucketSort(int *R, int n)
{
	for(int i=0; i<=4; i++) B[i].node=0;
	
	int max=0;
	for(int i=0; i<n; i++)
	{
		max=(max>R[i]? max: R[i]);
	}
	int d=max/5;
	for(int i=0; i<n; i++)
	{
		if(R[i]>=0&&R[i]<d)
		{
			B[0].arr[B[0].node++]=R[i];
		}
		else if(R[i]>=d&&R[i]<2*d)
		{
			B[1].arr[B[1].node++]=R[i];
		}
		else if(R[i]>=2*d&&R[i]<3*d)
		{
			B[2].arr[B[2].node++]=R[i];
		}
		else if(R[i]>=3*d&&R[i]<4*d)
		{
			B[3].arr[B[3].node++]=R[i];
		}
		else B[4].arr[B[4].node++]=R[i];
	}

	for(int i=0; i<=4; i++)
	{
		if(B[i].node>0) qsort(B[i].arr, B[i].node, sizeof(B[i].arr[0]), compare);
	}
	int tp=0;
	for(int i=0; i<=4; i++)
	{
		if(B[i].node>0)
		{
			for(int j=0; j<B[i].node; j++) R[tp++]=B[i].arr[j];
		}
	}
	return;
}
```

#### 4. 珠排序
###### · 一个数字用对应个数的珠子表示：
![[志第一-图/志第一-图二十一.png|350]]
                        （图二十一：一个数字用对应个数的珠子表示）
###### · 把珠子向算盘珠一样串在一起，然后让珠子自由下落：
![[志第一-图/志第一-图二十二.png|550]]
                 （图二十二：把珠子向算盘珠一样串在一起，然后让珠子自由下落）
###### · 珠排序的复杂度：
1. O ( 1 )：所有珠子都同时移动，无法在计算机中实现
2. O ( n^(1/2) )：在真实的物理世界中用引力实现，时间正比于珠子最大高度的平方根，而最大高度正比于 n
3. O ( n )：一次移动一列珠子，可以用 模拟和数字的硬件实现
4. O ( S )：S 是所有输入数据的和：一次移动一个珠子，能在软件中实现

#### 5. 睡眠排序：
###### · 构造 n 个线程，它们和这 n 个数一一对应
###### · 设置线程 Th<sub>i</sub> 在 n<sub>i</sub> 时刻醒来
###### · 初始化后，线程们开始睡眠，等到对应的数那么多个时间单位后各自醒来，然后输出它对应的数
###### · 这样最小的数对应的线程最早醒来，这个数最早被输出，等所有线程都醒来，排序就结束了

#### 6. Bogo 排序 / 猴子排序 / 随机排序：
###### · 算法思想：
1. 把元素随机排列
2. 如果没有排好序，再次把元素随机排列
3. 如果还没有排好序，继续随机排列
4. 直到得到一个有序数组
###### · 特点：“高效而无效”，排序的成功具有随机性，在有限时间内排序成功非必然事件
（如果“运气”极好，可以超快完成本来十分复杂的排序工作，成功得到目标序列）


### 捌  内部排序算法小结

#### 述：
##### 
##### 

![[志第一-图/志第一-图二十三.png|700]]
                        （图二十三：内部排序算法小结）
###### · 几点说明：
1. 几种简单的排序算法（直接插入、冒泡排序）的最好时间复杂度都为 O ( n )，说明算法的输入在接近有序时的效率比较高
2. 三种平均时间复杂度为 O ( n log<sub>2</sub>n ) 的算法中：
	1. 快速排序的平均效率高，但是最坏时间复杂度为 O ( n<sup>2</sup> )，且空间复杂度为 O ( log<sub>2</sub>n )
	2. 堆排序的最坏时间复杂度为 O ( n log<sub>2</sub>n )，且空间复杂度仅为 O ( 1 )，但是不稳定
	3. 归并排序的最坏时间复杂度也为 O ( n log<sub>2</sub>n )，而且是稳定算法，但是空间复杂度为 O ( n )
3. 不同的排序方法适应不同的应用环境和要求：
	1. 若 n 较小，可采用直接插入或简单选择排序：
		1. 当记录规模较小时，直接插入排序较好，它会比选择更少的比较次数，且是稳定的
		2. 当记录规模稍大时，因为简单选择移动的记录数少于直接插入，所以宜用选简单选择排序
	2. 若初始状态基本有序，则应选用直接插入、冒泡或随机的快速排序为宜
	3. 若n较大，则应采用时间复杂度为 O ( n log<sub>2</sub>n )的排序方法：快速排序、堆排序或归并排序
	4. 特殊的基数排序：以空间换时间


### 玖  外部排序概述

#### 述：
##### 
##### 

###### · 外部排序：基于外部存储设备（或文件）的排序技术
1. 当待排序的对象数目特别多时，在内存中不能一次处理
2. 必须把它们以文件的形式存放于外存，排序时再把它们一部分一部分调入内存进行处理
3. 在排序过程中必须不断地在内存与外存之间传送数据
###### 外部存储设备：磁带、磁盘

##### 1. 基于磁盘的排序多使用归并排序法：
###### · 排序过程主要分为两个阶段
1. 建立用于外排序的内存缓冲区：
	· 根据它们的大小将输入文件划分为若干段，用某种内排序方法对各段进行排序
	· 这些经过排序的段叫做初始归并段或初始顺串 ( Run )
	· 当它们生成后就被写到外存中去
2. 仿照归并树的模式，把第一阶段生成的初始归并段加以归并，一趟趟地扩大归并段和减少归并段个数，直到最后归并成一个大归并段（有序文件）为止
![[志第一-图/志第一-图二十四.png]]
（图二十四：外部排序需要的总时间）
###### · 因为 t<sub>IO</sub> >> t<sub>mg</sub>，故要提高外排序速度，应减少读写次数 d，有效途径：
1. 增加归并路数 k
2. 减小初始段数 m

##### 2. 多路平衡归并排序
###### · k-way balanced merging
###### · 对于 k 路归并排序，如果有 m 个初始归并段，则需要归并 s=log<sub>k</sub>m （向上取整）趟
###### · 内部 k 路归并时，要在 k 个对象中选择最小者，常用<font color="#00b050">败者树</font>的方法：
败者树是一棵正则的完全二叉树，其中：
	1. 每个叶结点存放各归并段在归并过程中当前参加比较的对象
	2. 每个非叶结点记忆它两个子女结点中对象关键码大的结点（即“败者”），并将“胜者”“传到”上面去

![[志第一-图/志第一-图二十五.png|400]]
                                （图二十五：败者树的原理）

```C++
int k;    //表示这是 k 路归并的排序
int b[100];    // b[s] 表示第 s+1 个序列的首元（不断更新）
int ls[100];    //存储败者树的每一个结点
int s;    //表示一个结点的编号

void Adjust(int s);    //败者树的调整函数（参数 s 是讨论的序列标号）
{
	int t=(s+k)/2;    //当讨论的是第 s+1 个序列时，这个序列所对应的败者树叶子结点记为 ls[t]
	//其中 s 是序列的编号，注意序列是从 b0 开始编号的
	while(t>0)
	{
		if(b[s]>b[ls[t]])
		{
			int temp=s;
			s=ls[t];    // s 永远指向最小值，即胜者
			ls[t]=temp;    //父结点保存新的败者
		}
		t=t/2;    //沿路径向上（父结点）比较
	}
	ls[0];    //最终的“冠军”
}

void CreateLoserTree()    //败者树的创建函数
{
	b[k]=-99999;    //初始化数据结点的最小值
	for(int i=0; i<k; i++)
	{
		ls[i]==k;    //初始化内部结点记录的下标
	}
	for(int i=k-1; i>=0; i--)    //调整败者树
	{
		Adjust(i);
	}
}
```

