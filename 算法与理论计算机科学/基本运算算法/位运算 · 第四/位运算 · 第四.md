### 壹  字节与位

#### 述：
##### 实虚共覆终可成，阳阴相搏灭其形。
##### 兜兜转转有无事，明明晦晦万象生。

###### · 比特位：
· 对于二进制计算机，所有的数据都以二进制的形式存储在设备中
· 位运算就是直接对存储在内存中的数据的二进制位进行操作
· 在计算机中，每一个二进制位称为 1 个 bit（b），8 个 bit 位称为一个字节（byte（B））
（一个字节也可以不是 8 位，大多数是，由硬件决定）

###### · 按位与：
· 在**逻辑与**运算中，参与运算的两个布尔值只有 0 和 1 两种取值
· 当两个布尔值都为 1，结果为 1；当两个布尔值中存在 0 时，结果为 0
· 逻辑与的符号为：**&&**
· **按位与**是对两个二进制数的对应位分别作逻辑与运算，符号为：**&**
· 与 1 相与不变，与 0 相与会变为 0 ，可以利用这个特性将某些位清零，也可以取出某些位
![[位运算第四-图/位运算第四-图一.png|500]]
                                   （图一：按位与运算）

###### · 按位或：
· 在**逻辑或**运算中，参与运算的两个布尔值只有 0 和 1 两种取值
· 当两个布尔值都为 0，结果为 0；当两个布尔值中存在 1 时，结果为 1
· 逻辑或的符号为：**||**
· **按位或**是对两个二进制数的对应位分别作逻辑或运算，符号为：**|**
· 与 0 相或不变，与 1 相或会变为 1 ，可以利用这个特性将某些位变成 1
![[位运算第四-图/位运算第四-图二.png|500]]
                                   （图二：按位或运算）

###### · 按位取反：
· 在**逻辑非**运算中，参与运算的两个布尔值只有 0 和 1 两种取值
· 当布尔值为 0 时，结果为 1；当布尔值为 1 时，结果为 0
· 逻辑非的符号为：**!**
· **按位取反**是对两个二进制数的对应位分别作逻辑与运算，也称**按位非**，符号为：**~**
![[位运算第四-图/位运算第四-图三.png|500]]
                                   （图三：按位非运算）

###### · 按位异或：
· 在**逻辑异或**运算中，参与运算的两个布尔值只有 0 和 1 两种取值
· 当两个布尔值不同时，结果是 1；当两个布尔值结果相同时，结果是 0
· 逻辑异或在数学上用符号 **⊕** 表示
· 编程语言很少有专门的异或符号，常用布尔值的“不等于”表示：!=
· **异或的特性**：任何值 和 1 异或取反，和 0 异或不变：$$x异或1=!x$$$$x异或0=x$$
· **按位异或**是对两个二进制数的对应位分别做逻辑异或运算，符号为：**^**
![[位运算第四-图/位运算第四-图四.png|500]]
                                   （图四：按位异或运算）

###### · 移位：
1. 左移：将所有二进制位向左移动 n 位（对于 32 位值，0<=n<=31，如果移动位数超出 32 3232 位，将会被对32 3232取模），移动后，最左边的 n 个二进制位将因被移出边界而丢弃，移动后最右边空出来的二进制位补 0
· **溢出**：计算结果超出有符号数存储的范围
· **环绕**：计算结果超出无符号数存储的范围
· 在没有溢出和环绕发生时，通常一个数左移一位后值变为 2 倍
![[位运算第四-图/位运算第四-图五.png|500]]
                                   （图五：左移的原理）
2. 算术右移（有符号）：有符号整数的最高位为符号位，有符号数右移时，最右边的位丢弃，最左边的空位补上原来的最高位（符号位）
· 有符号数每次算术右移，在算术上相当于是值除以 2 （并向下取整）的结果
· C/C++ 中有符号类型变量的右移是算术右移
· 负数不断进行算术右移，最终变为 −1， 而非负数最终变为 0
![[位运算第四-图/位运算第四-图六.png|500]]
                               （图六：负数算术右移的原理）
![[位运算第四-图/位运算第四-图七.png|500]]
                               （图七：正数算术右移的原理）
3. 逻辑右移（无符号）：无符号数没有符号位，所有位都作为二进制的数值位，右移时，最右边的位丢弃，最左边的位补 0
· 无符号数每次算术右移，在算术上也相当于是值除以 2 （并向下取整）的结果
· C/C++ 中无符号类型变量的右移是逻辑右移
· 二进制数连续进行逻辑右移，最终变为 0
~~~
例：
a:     【1 1 0 1 0 1】0 1  右边被以除丢弃
          ——————————>>
a>>2:  0 0【1 1 0 1 0 1】  左边空位补 0
~~~

###### · C++ 中位运算操作符：
| 位运算         | 操作符                          |
| ----------- | ---------------------------- |
| 按位与         | a&b                          |
| 按位或         | a\|b                         |
| 按位异或        | a^b                          |
| 按位取反        | ~a                           |
| 左移          | a<< b（ a 左移 b 位）             |
| 有符号右移（算术右移） | a>>b（当变量 a 为有符号类型时，a 右移 b 位） |
| 无符号右移（逻辑右移） | a>>b（当变量 a 为无符号类型时，a 右移 b 位） |

###### · C++ 运算符优先级：
| 顺序  | 运算符      | 说明             | 匹配规则 |
| --- | -------- | -------------- | ---- |
| 1   | ( )      | 带括号的表达式        | 从左至右 |
|     | [ ]      | 数组下标           |      |
|     | .        | 按对象选择成员        |      |
|     | ->       | 按指针选择成员        |      |
| 2   | +  -     | 一元加  一元减       | 从左至右 |
|     | ++  --   | 递增  递减         |      |
|     | ~  !     | 逻辑非  按位补       |      |
|     | *        | 取消引用（简介运算符）    |      |
|     | &        | 寻址符            |      |
|     | sizeof   | 表达式或者类型所占字节数   |      |
|     | (type)   | 强制类型转换         |      |
| 3   | *  /  %  | 乘  除  取余数      | 从左至右 |
| 4   | +  -     | 加  减           | 从左至右 |
| 5   | <<  >>   | 按位左移  按位右移     | 从左至右 |
| 6   | <<=      | 小于小于等于         | 从左至右 |
|     | >>=      | 大于大于等于         |      |
| 7   | ==  !=   | 等于  不等于        | 从左至右 |
| 8   | &        | 按位与            | 从左至右 |
| 9   | ^        | 按位异或           | 从左至右 |
| 10  | \|       | 按位或            | 从左至右 |
| 11  | &&       | 逻辑与            | 从左至右 |
| 12  | \|\|     | 逻辑或            | 从左至右 |
| 13  | (? :)    | 条件运算符          | 从右至左 |
| 14  | =        | 赋值             | 从右至左 |
|     | +=  -=   | 加法赋值  减法赋值     |      |
|     | * =  /=  | 乘法赋值  除法赋值     |      |
|     | %=       | 取余数赋值          |      |
|     | <<=  >>= | 按位左移赋值  按位右移赋值 |      |
|     | &= \|=   | 按位与赋值  按位或赋值   |      |
|     | ^=       | 按位异或赋值         |      |
| 15  | ,        | 逗号运算符          | 从左至右 |


### 贰  常用位运算

#### 述：
##### 一山望山较高低，一路觅路问东西。
##### 世间万物皆有位，缘何无安苦相比？

###### 0. 整型提升：
· 在 C/C++ 中，进行表达式计算时，各种整数类型会首先自动转换成 int 型
· 如果 int 不足以表示的话，就需要提升为 unsigned int 类型
· 两个 8 位的 char 型的值进行运算时，会先转换成 32 位的整型再进行计算，整个表达式结果为整型

· C 中可以使用 **1U** 来表示无符号整型 1：00000001
· C 中可以使用 **0U** 来表示无符号整型 0：00000000

###### 1. 数二进制形式输出：
1. itoa() 函数：
· 标准库函数 **itoa()** 能够将数值转换成 2~36 进制格式的字符串，函数在头文件 *<stdlib.h>* 中声明
· 某些编译器（如Visual Studio）有安全检查，如果 itoa() 函数不可用，则需要使用 *_itoa_s()* 安全函数
· 用法：`itoa(①待转换值，②存放转换后结果的数组，③需要转换的数制)`

· <font color="#ffc000">代码</font>：
```C++
#include <stdlib.h>
#include <stdio.h>
#include <stdint.h>
#include <limits.h>

#define INT_BIT (sizeof(int)*CHAR_BIT)    // int 型所占位数数（一般是 32 位）

int main()
{
	int value=0x1237A;    //二进制：0001 0010 0011 0111 1010

	//创建一个可容纳转换结果字符串的缓冲区（int 位数再额外考虑末尾 '\0'）
	const int bufferlength=INT_BIT+1;    //缓冲区长度（int 位数加一）
	char buffer[INT_BIT+1];    //缓冲区

	//将 value 转成二进制格式字符串，存放到 buffer 数组中，需要保证 buffer 数组能够保存转换结果
	itoa(value, buffer, 2);

	//如果在编译器上有安全检查，则使用安全函数 _itoa_s()：
	//_itoa_s(value, buffer, 2);

	//输出字符串：
	printf("%s\n",buffer);    //输出：10010001101111010
	return 0;
}
```

2. 手动实现进制转换：
· 按位与运算（&）可以提取出对应的二进制位，可以借助按位与将对应的二进制位提取并输出
· 在输出时，可以 4 位为一组，用空格间隔，增加可读性

· <font color="#ffc000">代码实现</font>：
```C++
//输出固定为 nBit 位的二进制数
void printBinary(int number, int nBit)
{
	if(nBit>32||nBit<=0) nBit=32;    //修正 nBit 的错误
	for(int n=nBit-1; n>=0; n--)
	{
		putchar( ( ( (num>>n)&1)==0 )? '0': '1');
		//如果对应位是 1，则输出 “1”；如果对应位是 0，则输出“0”
		if((n%4)==0&&(n!=0)) putchar(' ');    //四位一空格
	}
	return;
}
```

###### 2. 对应位置位与清零：
· 置位即将二进制位置为 1
· 清零即将二进制位置为 0
· 默认二进制的最右边一位为*第零位*
```C++
#define bit(n) (1U<<(n))
```
· 置位运算可以通过和 1 进行按位或运算完成：
```C++
a|=bit(n);    //对 a 从右数第 n 位置位
a|=(bit(3)|bit(4)|bit(5));    //对 a 的第 3、4、5 位同时置位
```
· 清零运算可以通过和 0 进行按位与运算完成：
```C++
a=a&~bit(n);    //对 a 从右数第 n 位清零
a=a&~(bit(6)|bit(7)|bit(8));    //对 a 的第 6、7、8 位同时清零
```

###### 3. 对应位取反：
· 按位取反可以通过和 1 进行按位异或运算完成：
```C++
a^=bit(n);    //对 a 从右数第 n 位取反
a^=bit(2)|bit(5)|bit(9);    //对 a 的第 2、5、9 位同时取反
```

###### 4. 取二进制位：
· 取二进制位可以通过按位与运算进行，要取的位和 1 进行与运算，不取的位和 0 进行与运算
```C++
a&bit(0);    //取第 0 位
a&bit(3);    //取第 3 位
```
```C++
a&(bit(0)|bit(1)|bit(7));    //取第 0 位、第 1 位、第 7 位
//等价于：
a&0x83;
```

· 常见用法：
```C++
a&0xFF;    //取最低 8 位
a&0xFFFF0000;    //取最高 16 位
a&0xFF00;    //取第 8~15 位
a&0x55555555;    //取偶数位
a&0xAAAAAAAA;    //取奇数位
```

· 取两个二进制数不同的位：
```C++
a^b;    //取 a 与 b 二进制不同的位
```

· 取 a 为 1，b 为 0 的位：
```C++
a&(~b);    //取 a 为 1，b 为 0 的位
(a^b)&a;    //或者先取差异位，再取其中 a 为 1 的位
```

###### 5. 位逆序与蝴蝶算法：
1. 常规位逆序算法：
![[位运算第四-图/位运算第四-图八.png]]
（图八：位逆序）
· 实现原理：不断地取出原数 a 的最低位并将 a 右移，然后将另一个初始值为 0 的数 b 左移，并将从 a 取出的最低位放到 b 的最低位上
· 时间复杂度：O ( n )
```C++
int bitReverse(int num, unsigned int nBit)    //截取 num 的低 nBit 位，逆序后返回
{
	if(nBit>32) nBit=32;
	int ans=0;
	while(nBit-- > 0)
	{
		ans << = 1;
		//将 num 的最低位取出放到 ans 的最低位上
		ans|=num&1;
		num >> = 1;
	}
	return ans;
}
```
2. **蝴蝶算法**：
· 蝴蝶算法是通过递归将二进制位左右分半并进行交换来完成逆序的
![[位运算第四-图/位运算第四-图九.png|400]]
                               （图九：“蝴蝶算法”的原理）
· 左右交换从位置上看，实际上是一部分左移，另一部分右移，并不是镜像翻转
· 如 8 位二进制数的第一次的$\frac{1}{2}$交换，只需要如下操作即可：
```C++
((num>>4)&0x0F)|((num<<4)&0xF0)
```
· 其中 0x0F 和 0xF0 是用于配合按位与(&)取对应的二进制位，称为**掩码**
· 也可以先取对应二进制位再移动，但是这样*要保证 num为无符号整数*，否则当最高位为 1 时，右移可能会引入多余的 1，所以*并不推荐先取位再移动*

· 八位二进制数的逆序算法：
~~~
掩码变化：
0b11110000 0b00001111
0b11001100 0b00110011
0b10101010 0b01010101
~~~
```C++
unsigned char byteReverse(unsign char data)    //八位无符号数据类型
{
	data=((num>>4)&0xF0)|((num<<4)&0x0F);
	data=((num>>2)&0xCC)|((num<<2)&0x33);
	data=((num>>1)&0xAA)|((num<<1)&0x55);
	return data;
}
```

· N 位二进制数逆序：（ N 只能取 2 的幂）
![[位运算第四-图/位运算第四-图十.png|400]]
                                  （图十：掩码的变化）
```C++
unsigned int bitReverse(unsigned int num, unsigned int N = 32)
{
	//先构造最低 N 位的验码：
	unsigned int mask = (N>=32)? (0xFFFFFFFF): ((1U<<N)-1U);    //即 0xFFFFFFFF
	num&=mask;    //取最低 N 位

	unsigned int M=N/2;    //生成下一级掩码需要移动的位数

	//当 M 为 0 时，下一级掩码将全为 0，此时已逆序完成，可以结束
	while(M>0)
	{
		mask^=(mask>>M);
		num=((num<<M)&mask)|((num>>M)&~mask);    //每组对半交换
	}

	return num;
}
```
· 掩码为全 0 后就已经逆序完成，而且值就不再变化，所以循环至掩码为 10101010 即可

###### 6. 位循环移动：
· 位循环移动即相当于把所有位看成一个首尾相连的环，一端移出的位会放入另一端
![[位运算第四-图/位运算第四-图十一.png|450]]
                                （图十一：位循环移动两位）
```C++
unsigned int circleRightShift(unsigned int num, unsigned int n)//将 32 位数 num 循环右移 n 位
{
	n%=32;
	return (num>>n)|(num<<(32-n));
}

unsigned int circleLeftShift(unsigned int num, unsigned int n)//将 32 位数 num 循环左移 n 位
{
	n%=32;
	return (num<<n)|(num>>(32-n));
}
```

· 对于不固定位数：
```C++
unsigned int circleRightShift(unsigned int num, unsigned int n, unsigned int nBit)
//将 nBit 位二进制数 num 循环右移 n 位
{
	if (nBit>32)
		nBit=32;

	//获取低nBit位的掩码
	unsigned int mask=(nBit>=32)? (0xFFFFFFFF): ((1U<<nBit)-1U);
	num&=mask;	//取最低 nBit 位，mask 保证只有最低 nBit 位被保留，其余的有数位被清零

	n%=nBit;
	return ((num>>n)|(num<<(nBit-n)))&mask;
}

unsigned int circleLeftShift(unsigned int num, unsigned int n, unsigned int nBit)
//将 nBit 位二进制数 num 循环左移 n 位
{
	if (nBit>32)
		nBit=32;

	//获取低nBit位的掩码
	unsigned int mask=(nBit>=32)? (0xFFFFFFFF): ((1U<<nBit)-1U);
	num&=mask;	//取最低 nBit 位，mask 保证只有最低 nBit 位被保留，其余的有数位被清零

	n%=nBit;
	return ((num<<n)|(num>>(nBit-n)))&mask;
}
```

###### 7. lowbit 运算：
· **lowbit 运算**是位运算中比较重要的运算方式，用于计算一个二进制数最低位的 1
· **lowbit** 即二进制数最低位1所对应的值
· 例：二进制数 0b01011000 最低的 1 是在第 3 位，对应值为 0b1000

· **lowbit 运算的实现**：
![[位运算第四-图/位运算第四-图十二.png]]
（图十二：lowbit 运算的实现）
`lowbit(a)=a&(~a+1)`
```C++
int lowbit(int a)
{
	return a&(~a+1);
}
```
· 由于取反加一的操作其实就是二进制的补码，由于补码的性质：二进制的补码相当于*相反数的二进制*，故可以得到：~a+1 = -a
```C++
//另一种实现方式：
int lowbit(int a)
{
	return a&(-a);
}
```
***· 划重点：源码和补码的按位与就是 lowbit ！***

· **消去 lowbit 算法**：
· 一个数消去它的 lowbit 位，直接减去它的 lowbit 值即可：
```C++
int Remove_lowbit(int a)
{
	return a-lowbit(a);
}
```
```C++
//另一种实现方式：
int Remove_lowbit(int a)
{
	return a&(a-1);
}
```
· `a&(a-1)=a&(-a)` 等式成立：
1. a-1 可以认为是将 a 最右边 1 及其右边所有位取反，而左边不动
2. -a 可认为是全局取反后加一，当全局取反时，a 最右边 1 及其右边所有位和 a-1 变得一样，形如“0111”；但其左边与 a-1 是完全互补的
3. 当全局取反后再加一时，a 最右边 1 及其右边所有位正好与 a-1 相反，此时形如“1000”；左边只有一位会发生变化（进位使 0 变 1），就是那个想要保留的：a 中除了 lowbit 之外的下一位
4. a&(a-1) 使得最右边 1 及其右边所有位的对应位置全部归零，上一步发生变化的位的左边也全部归零
![[位运算第四-图/位运算第四-图十三.png|450]]
                          （图十三：用 a&(a-1) 的方法消去 lowbit ）

###### 8. highbit 运算：
· **highbit** 即二进制数最高位 1 所对应的值
· 例：二进制数 0b01011000，其最高位 1 是在第 6 位上，对应值为 0b01000000
· highbit 运算和 lowbit 运算不同，并不能通过一个简单计算实现

1. 步骤一：**位的扩散**：将二进制数中比最高位1低的位全部变为 1，采用的是右移和位或操作
![[位运算第四-图/位运算第四-图十四.png|500]]
                                   （图十四：位的扩散）
· 位的扩散：
```C++
unsigned int bitSpread(unsigned int a)
{
	// 连续进行移位（按位或实现）
	a|=(a>>1);
	a|=(a>>2);
	a|=(a>>4);    // 8 位
	a|=(a>>8);    // 16 位
	a|=(a>>16);	   // 32 位
	a|=(a>>32);	   // 64 位
	return a;
}
```

2. 步骤二：利用异或或相减取最高位：
![[位运算第四-图/位运算第四-图十五.png|450]]
                           （图十五：利用异或或相减取最高位）
· 注意，这里用异或或做差的方法取最高位，而不是 c+1，因为当 c 为 0 时，要保证 highbit = 0，而非 1
```C++
b^(bitSpread(b)>>1);
//或者：b-(bitSpread(b)>>1);
```

· <font color="#ffc000">总体代码</font>：
```C++
unsigned int highbit(unsigned int n)
{
	a|=(a>>1);
	a|=(a>>2);
	a|=(a>>4);    // 8 位
	a|=(a>>8);    // 16 位
	a|=(a>>16);	   // 32 位
	//如果考虑 int 是 64 位的情况，那么需要再进行：n|=(n>>32);

	//这里必须是无符号右移：
	return n^((unsigned int)n>>1);
}
```

· 若求*比给定值大的二进制位*，可以在扩散后的结果基础上加一
· 若求*不小于给定值的二进制位*，有两种实现方式：
	1. 先判定原来的数是不是 2 的次方数，如果是则直接返回；不是则按照“比给定值大的二进制位”方法进行
	2. 原数减一  ==>  扩散  ==>  加回一
【第二种实现方式的图解：】
![[位运算第四-图/位运算第四-图十六.png|500]]
                    （图十六：原数减一 ==> 扩散 ==> 加回一 模式图解）


### 叁  位运算的应用

#### 述：
##### 天道补阙富余去，亏过盈生损中益。
##### 人道恒常心无满，宁损不足供有余。

###### 1. 生成低 N 位掩码：
```C++
unsigned int mask(unsigned int n)
{
	return (n>=32)? (-1): ((1U<<n)-1);
}
```

###### 2. 生成从第 M 位开始的连续 N 位的掩码：
![[位运算第四-图/位运算第四-图十七.png|500]]
                        （图十七：从第 M 位开始的连续 N 位的掩码）
· 可以通过将低 N 位掩码左移 M 位得到

###### 3. 取连续 N 位的值：
例：取 32 位数中第三个字节的值：第三个字节从第 24 位开始的 8 位，所以可以将原数右移 24 位，然后和低 8 位掩码 0xFF 做按位与运算即可得到对应的值
```C++
(a >> 24) & 0xFF;
```
· 推荐先移位，再取位：避免符号数的首位添 “1”

###### 4. 设置某些位的值：
· 可以通过先使用按位与运算将对应位清零，在使用按位或运算将对应位置位的方法来达到赋值的目的
例：将 16 位中的高 8 位赋值为 0xA
```C++
a&=~0xFF00;    //清零
a|=(0xA<<8);    //赋值
```

###### 5. 位连续反转：
· 取反只能将全部位同时取反，而部分位翻转可以使用异或运算
· 将对应位和 1 做异或运算将被取反，而其它位和 0 异或运算不变
```C++
a^=0xFF;    //第一次反转
a^=0xFF;    //第二次反转
……
a^=0xFF;    //第 N 次反转
```

###### 6. lowbit 的应用：
1. 统计一个二进制中 1 的位数：
· 实现方法：不断进行消去 lowbit
```C++
int calcNUMOfBit1(unsigned int 1)
{
	int count=0;    //初始记录为 0
	
	//不断消去 lowbit 直至值为 0
	while(n!=0)
	{
		n&=(n-1);
		++count;
	}
	return count;
}
```

2. 判断一个数是不是 2 的幂：
```C++
bool isPowerOfTwo(unsigned int a)
{
	return (a!=0)&&((a&(a-1))==0);
}
```
· 也可以直接利用上述 calcNUMOfBit1() 函数，计算 “1” 的个数，如果是 1，则说明是 2 的幂：
```C++
bool isPowerOfTwo(unsigned int a)
{
	return calcNUMOfBit1(a)==1;
}
```

3. 将右边第一组连续为 1 的二进制位变为 0
![[位运算第四-图/位运算第四-图十八.png|500]]
                      （图十八：将右边第一组连续为 1 的二进制位变为 0 ）
· 可以利用 `a&(a+lowbit(a))` 来消去二进制数右边连续的为 1 的位
· *变式1*：将右边从最低位开始的连续为 1 的二进制位变为 0（即第零位开始就一定是连续的 1）：
	· 可以利用 `a&(a+1)` 解决（即此时 lowbit(a) 就是 1 ）
· *变式2*：将右边从最低位开始的连续为 0 的二进制位变为 1（即第零位开始就一定是连续的 0）：
	· 可以利用 `a|(a-1)` 解决（退位减法，从形如 “1000” 得到 “0111” ）
	· 可以利用“形如” `a&(a+1)` 的“反”运算：
	```C++
	a=~a;    //先取反，再将右边 0 变成 1
	~(a&(a+1))    //去掉右边的 1 再取反回去
	```

###### 7. 奇偶判断：
· 奇数最低位为1，偶数最低位为0，可以用按位与运算取出二进制数的最低位
```C++
(x&1)==1;    //奇数判断
(x&1)==0;    //偶数判断
```

###### 8. 对 2<sup>k</sup> 取模：
· n 位二进制形式的数对应的十进制数值为：$$a_{n-1}·2^{n-1}+……+a_2·2^2+a_1·2^1+a_0·2^0$$
· 一个数对 2<sup>k</sup> 取模，直接取其二进制形式的低 k 位即可，将其与第 N 位掩码进行按位与运算：
```C++
a&((1<<k)-1);
```
· 如果 2<sup>k</sup> 的值 b 已经给出，则可以：
```C++
a&(b-1)
```



~~~ 参考：“CSDN”【依稀_yixy】《（三）位运算》
~~~ 网站：https://blog.csdn.net/qq_39151563/article/details/108294687