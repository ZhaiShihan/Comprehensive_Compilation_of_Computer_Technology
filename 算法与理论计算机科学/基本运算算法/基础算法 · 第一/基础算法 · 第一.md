### 壹  数组创建

#### 述：
##### 一字长蛇头尾连，每有传唤按位点。
##### 今若百人尽离去，楼空留存一百间。

###### 1. 数组的创建：

· C++ 中数组能够顺序存储相同类型的多个数据，访问数组中某个元素的方法就是编号与索引
· 一维数组的编号从 0 开始，N 个元素连续存储则最后一个编号是 N -1
· 对于一个数组 arr，把 0 到 N -1 中间任意的 i 作为对应元素的**索引**
· 在代码中用 arr【i】唯一地表示第 i +1 个元素
![[基础算法第一-图/基础算法第一-图一.png|450]]
                                 （图一：一维数组的图示）
**创建数组的两种方式**：

1. 直接创建一个固定大小的数组，它所需要的内存在 *编译期* 就会被确定和分配：
```C++
int arr[10];    //创建一个大小为 10 的数组，从 arr[0] 到 arr[9]
```
· 注意：一定要用一个常量来指定数组的大小，不能用变量 int arr【n】

2. 动态内存分配，可以在 *运行期* 分配内存，所需的内存空间大小不需要在 *编译期* 确定：
```C++
#include <stdlib.h>
int* arr = (int*) malloc (10 * sizeof(int));    //动态内存分配
free(arr);    //释放内存
```
```C++
 · C++中有分别用于动态内存分配和释放的关键字：“new”和“delete”：
int* arr = new int[10];
delete[] = arr;
```
· 注意：当动态分配的内存不再需要被使用时，应当及时释放，将其归还系统内存池，待之后重新分配使用
· 分配内存但在使用完毕后不释放会造成 *内存泄漏*

###### 2. 数组的初始化：

1. 如果数组在代码块之外被声明，或者使用了 static 关键字进行声明，那么数组将被存储于静态内存中，也就是不属于 *栈* 的内存，这时数组属于**静态变量**，<font color="#ffc000">数组元素的初始值将会自动设置为 0 </font>
2. 如果数组在代码块之内被声明，或者没有使用 static 关键字进行声明，那么数组将被存储于 *栈* 中，这时数组属于**自动变量**，此时数组中元素的值是未被初始化的，<font color="#ffc000">元素的值取决于内存原本的值</font>

· <font color="#ffc000">代码分析：</font>
```C++
 · 代码测试：
#include<stdio.h>

int arr[10];

int main()
{
	int brr[10];
	
	for(int i=0; i<=9; i++) printf("%d %d\n",arr[i],brr[i]);
	return 0;
}

 · 测试的输出结果：
0 1390641797
0 -2
0 6422280
0 1965720173
0 4200736
0 6422404
0 4200848
0 4200736
0 2043520
0 0
```

· <font color="#ffc000">数组初始值的赋值：</font>
```C++
1. int arr[10] = {1, 2, 3, 4, 5 ,6 ,7 ,8 ,9, 10};    标准赋值法，赋值序列长度等于声明长度
2. int brr[5] = {1, 2, 3, 4};    正确赋值法，赋值序列长度小于声明长度
3. int crr[5] = {1, 2, 3, 4, 5, 6};    错误赋值法，赋值序列长度大于声明长度
4. int drr[] = {5, 4, 3, 2, 1};    正确赋值法，不写明数组长度，默认数组长度就是5
```

· <font color="#ffc000">获取数组的长度：</font>
```C++
int length = sizeof(arr) / sizeof(arr[0]);
//注意：sizeof(arr) 获取的是整个数组的内存大小，而不是开辟的“格子”数，每“格”内存大小为 sizeof(arr[0])
```

###### 3. 多维数组：

· 如果数组的维数不止一个，则称这样的数组为**多维数组**
```C++
int a[4][5];    //二维数组
int a[4][5][6];    //三维数组
int a[4][5][6][7];    //四维数组
```
![[基础算法第一-图/基础算法第一-图二.png]]
（图二：一维数组与二维数组的 *存储顺序* ）
· 二维数组又被称为“数组的数组”

注意：在 C 中，多维数组的元素存储按照最右边的下标优先变化的原则，称为**行主序**

· 二维数组的动态内存分配需要先分配一个 *指针数组* ，再为数组里的每个指针元素赋值一个一维数组的首地址
· 二维数组释放内存的顺序相反，先释放指针数组里指针所指的内存，再释放指针数组的内存

```C++
int row=3, column=4;

int** arr = new int*[row];    先分配一个 int* 型的指针数组
for(int i=0; i<row; i++)  int arr[i]= new int[column];    再为数组里的指针元素动态分配一个数组

for(int i=0; i<row; i++)  delete[] arr[i];    先释放指针数组里指针所指的内存
delete arr[];    再释放指针数组的内存
```


### 贰  基本算法

#### 述：
##### 笑谈天地变，推演五千年。
##### 日月运其轨，一算开江山！

##### 1. 数字运算：
###### 1. 数字交换：
![[基础算法第一-图/基础算法第一-图三.png|350]]
                                （图三：两个数交换原理）
· <font color="#ffc000">代码实现：</font>
```C++
void Swap(int &a, int &b)
{
	int temp=a;
	a=b;
	b=temp;
}
```

###### 2. 比较大小：

1. 三目运算符法：
```C++
int MAX(int a, int b)
{
	return a > b ? a : b ;
}

int MIN(int a, int b)
{
	return a < b ? a : b;
}
```

2. 宏定义法：
```C++
＃ define MAX(a, b)  ((a) > (b) ? (a) : (b))
＃ define MIN(a, b)  ((a) < (b) ? (a) : (b))
```

###### 3. 求最大公约数：

· 两个整数的最大公约数是能整除二者的最大整数，记作 *Gcd*
· 求解最大公约数的最常用方法是**欧几里得算法**，又称**辗转相除法**

· <font color="#92d050">辗转相除法：</font>
1. 求两个整数 m 与 n 的余数：m % n = r
2. 令 m=n，n=r
3. 再求 m % n = r，直至求得的 r 为 0，此时的 n 即为最大公约数

· 例：
m = 27，n = 18
=>  r = 9
=>  n % r = 0  =>  9 为最大公约数

· 辗转相除序列：
a1，a2，a3，a4，……，其中初始设为 a1 > a2，递推公式为 a(n+2) = a(n) % a(n+1)

**粗略证明**：*设序列为 a1，a2，a3，……，an，0*
则 a(n-1) = an · k1 + 0
a(n-2) = a(n-1) · k2 + an = ( 1+ k1·k2 ) · an        （ k1 与 k2 互质 ）
a(n-3) = a(n-2) · k3 + a(n-1) = ( k1 + k3 + k1·k2·k3 ) · an        （ ( 1+ k1·k2 ) 与 k3 互质）
……
故可知，a3 = K · an，a4 = Q · an，且相邻两项中 an 的系数互质
=>  a2 = P · a3 + a4 = ( KP + Q ) · an
=>  a1 = R · a2 + a3 = ( RKP + QR + K ) · an
由此可知，an 一定是 a1 和 a2 的公约数
由于 a1 和 a2 中 an 的系数互质，故 an 是 a1 和 a2 的最大公约数

· <font color="#ffc000">代码实现：</font>
```C++
int Gcd(int m, int n)
{
	int r=m%n;
	while(r!=0)
	{
		m=n;
		n=r;
		r=m%n;
	}
	return n;
}
```
· 注：这里无需考虑 m >=n，即使 m< n，第一次循环会交换 m 与 n

###### 4. 求最小公倍数：

· 两个数的最小公倍数是指能同时被两个数整除的整数的最小值，记为 *Lcm*
· 最小公倍数计算公式：
$$两数最小公倍数 × 两数最大公约数 = 两数乘积$$
$$即： Lcm(m,n) · Gcd(m,n)=m·n$$

· <font color="#ffc000">代码实现：</font>
```C++
int Lcm(int m, int n)
{
	if(Gcd(m,n)==0) return 0;
	else return m*n/Gcd(m,n);
}
```

###### 5. 质数判断：

· 质数又称素数 ，一个大于 1 的自然数，除了 1 和它自身外，不能被其他自然数整除的数称**素数**，否则称**合数**
· 规定 1 既不是质数，又不是合数，最小的质数是 2，最小的合数是 4
· 判定方法：检索法，检索从 1 到这个数的算数平方根（取整）间的所有整数，检查是否是因数

· <font color="#ffc000">代码实现：</font>
```C++
void Judge(int p)
{
	if(p<=1)
	{
		printf("Not Prime, not Composite!\n");
		return;
	}
	else
	{
		int s=(int)round(sqrt(p));    //算数平方根近似取整，取平方根是重要的加速法之一
		for(int i=2; i<=s; i++)
		{
			if(p%i==0)
			{
				printf("Composite!\n");
				return;
			}
			else continue;
		}
		printf("Prime!\n");
		return;
	}
}
```

##### 2. 数学函数：
###### 1. 求绝对值：

· 判断值是否小于零，若小于零返回相反数，否则返回原数

· <font color="#ffc000">代码实现：</font>
```C++
int Absolute(int x)
{
	return (x>0) ? x : -x;
}
```
```C++
double Absolute(double x)
{
	return (x>0.0) ? x : -x;
}
```

###### 2. 直角三角形勾股定理：

· 给定直角三角形的两个边长，求第三边
· 如果给定的两条边长不等，则有两种情况，一种是长的为斜边，一种是斜边未给出
· 如果给定的两条边长相等，则这两条边一定都是直角边

· <font color="#ffc000">代码实现：</font>
```C++
int Judge(double x, double y)
{
	if(x==y) return 1;
	else return 0;
}

void Calculate(double x, double y)
{
	if(Judge(x,y)) printf("Only One Answer：%lf\n",sqrt(x*x+y*y));
	else
	{
		int M=(x>y?x:y);
		int m=(x<y?x:y);
		printf("If Hypotenuse Was Given: %lf\n",sqrt(M*M-m*m));
		printf("If Hypotenuse Wasn't Given: %lf\n",sqrt(M*M+m*m));
	}
	return;
}
```

###### 3. 多项式运算：

· 给定一个多项式 y = a0 + a1·x + a2·x^2 + a3·x^3 + …… 的最大次数和每一项的系数，代入 x，计算 y

· <font color="#ffc000">代码实现：</font>
```C++
double Calculate(int n, double x)    //输入最大的次数 n 和代入的 x 值
{
	double Coef[n+1];
	double y=0;
	for(int i=0; i<=n; i++)
	{
		scanf("%lf",&Coef[i]);    //输入 i 次项的系数
	}
	for(int i=1; i<=n; i++)
	{
		if(Coef[i]==0) continue;
		else
		{
			int k=1;
			for(int j=1; j<=i; i++)
			{
				k*=x;
			}
			y+=k*Coef[i];
		}
	}
	y+=Coef[0];
	return y;
}
```

##### 3. 计时：
###### 1. 程序运行时间：

· **clock()** 函数可以返回当前程序运行的时间，单位是（ 1 / <font color="#ffff00">CLOCK_PER_SEC</font> ）秒，<font color="#ffff00">CLOCK_PER_SEC </font>通常是 1000，所以 **clock()** 函数的时间单位通常是 *毫秒（ms）*
· **clock()** 函数需要头文件声明：#include<time.h>
· **clock()** 函数的返回结果是一个整数，表示时间，通常是毫秒，其值类型为 *clock_t*

· <font color="#ffc000">代码实现：</font>
```C++
#include<stdio.h>
#include<time.h>

int main()
{
	clock_t startClock=clock();
	/*程序代码*/
	clock_t endClock=clock();
	clock_t Time=endClock-startClock;    //求代码执行时常（单位：毫秒(ms)）
	printf("%ld\n",Time);
	return 0;
}
```
```C++
另一种求差写法：
clock_t Time=(endClock-startClock)*1000/CLOCK_PER_SEC;
```

###### 2. 绝对时间秒数：

· **time()** 函数通常用来获取当前时间对应的秒数，作为随机数的种子，参数传入 NULL 即可
· **time()** 函数返回值类型是 *time_t*，被定义为一个 long long 型整数
· **time()** 函数返回的结果是从 1970 年 1 月 1 日 0 时 0 分 0 秒开始到现在的秒数
· **time()** 函数需要头文件声明：#include<time.h>

· <font color="#ffc000">代码实现：</font>
```C++
#include<stdio.h>
#include<time.h>

int main()
{
	time_t curentTime=time(NULL);    //注意 time() 函数的括号内填写"NULL"
	printf("%lld\n",curentTime);    //用于输出当前的秒数
	return 0;
}
```

##### 4. 随机数

###### 1. 伪随机数生成

· **伪随机数**即使用**确定性**的算法计算出随机数序列，即输入相同的参数可以得到相同的随机数序列
· 伪随机数并不是绝对的随机，其好处是可以复现结果
· C 的 <stdlib.h> 库中有生成伪随机数的函数：**rand()** 函数，生成的随机数服从 0 ~ 32767 的随机分布
（随机数的最大值为 RAND_MAX，这个值通常为 32767 ）

· 注意：rand() 函数使用前需要调用 *srand()* 函数设置一个 *随机数种子*，作为计算伪随机数序列的初始值
· 如果不设置随机数种子，则每次生成的伪随机数序列相同
· 通常使用 *time()* 函数返回的时间值作为初始值（注意：time() 函数返回结果的时间单位是“秒”，如果两次程序运行时间间隔极端，生成的伪随机数序列会相同）
· srand() 函数在 rand() 函数使用前调用，只需要在程序中调用一次即可，后续使用 rand() 函数时不需要再调用 srand() 函数

· <font color="#ffc000">代码实现：</font>
```C++
#include<stdio.h>
#include<time.h>
#include<stdlib.h>

int main()
{
	srand((int)time(NULL));
	int r=rand();
	printf("%d\n",r);
	return 0;
}
```
```C++
对数组 arr[] 随机赋值:
void randomAssign(int arr[], int length)
{
	for(int i=0; i<length; i++) arr[i]=rand();
}
```

###### 2. 指定区间随机数

· 有时我们需要落在区间【 low，high 】内的随机数，而 rand() 函数产生的随机数是在 0 ~ 32767 随机分布的，这时需要一个合理的分布区间收缩或扩张的算法：

1. 随机数区间收缩方法：
	1. 当区间长度非常小，比如 low=1，high=4 时，这时采用<font color="#ffff00">随机数求余</font>的方法，将每一个生成的随机数求余区间的长度（在这里是 4），得到 4 个随机数：0，1，2，3，近似认为它们的获得概率均等；将得到的随机数加上 low 的值，即为区间内随机数
	2. 当区间长度比较长时，比如 low=1，high=30000，这时如果还按照随机数求余的方式，所得的随机数 0 ~ 2767 出现的概率是 2768 ~ 30000 出现概率的两倍，容易出现*随机值偏小*的情况；此时应当采用<font color="#ffff00">舍域外值法</font>，即随机产生 rand() 函数支持范围下的值，如果这个值落在目标区间内则采纳；如果这个值未落在目标区间内，则不做任何处理，直接舍去
2. 随机数区间扩张方法：
	1. 当区间长度与 32767 相当，但超出这个范围时，比如 low=10000，high=40000 时，可以采用<font color="#ffff00">区间平移法</font>，即将 rand() 函数产生的随机数加上 10000，得到新的随机数组，再应用舍域外值法即可
	2. 当区间长度很大，比如 low=1，high=80000 时，此时采用<font color="#ffff00">随机倍数法</font>，即将 rand() 函数产生的每一个随机数乘以 1 ~ 3 的随机倍数（ 1 ~ 3 的随机倍数通过另一个 rand() 函数产生），得到一个 0 ~ 98301 均匀分布的随机数序列，再采用舍域外值法取值

· <font color="#ffc000">代码实现：</font>
1. 随机数求余法：
```C++
int Remainder(int low, int high)
{
	srand((int)time(NULL));
	int length=high-low+1;
	int k=rand();
	return k%length+low;
}
```
2. 舍域外值法：
```C++
int Omit_Outside(int low, int high)
{
	srand((int)time(NULL));
	while(1)
	{
		int k=rand();
		if(k<low||k>high) continue;
		else return k;
	}
}
```
3. 区间平移法：
```C++
int Translation(int low, int high)
{
	srand((int)time(NULL));
	while(1)
	{
		int k=rand();
		k+=low;
		if(k<low||k>high) continue;
		else return k;
	}
}
```
4. 随机倍数法：
```C++
int Random_Multiple(int low, int high)
{
	srand((int)time(NULL));
	int M=high/32767+1;    //确定最大倍数
	while(1)
	{
		int k1=rand();
		k1=k1%M+low;    //确定随机倍数
		int k2=rand();    // 用 rand() 函数生成一个随机值
		int k=k1*k2;    //随机值乘随机倍数
		if(k<low||k>high) continue;
		else return k;
	}
}
```

###### 3. 随机置乱算法：

· 将一个序列随机打乱的算法称为随机置乱算法
· 随机置乱的常用做法是**高纳德置乱算法（Knuth-Fisher-Yates）**（高纳德置乱算法由 Ronald A. Fisher 和 Frank Yates 于 1938 年发明，后来被 Knuth 在书中介绍，由此得名）

· <font color="#ffc000">算法步骤：</font>
1. 用一个大小为 n 的数组存储一个长度为 n 的序列
2. 从 n 个元素中任选一个，与第 0 位置上的元素交换（注意：这里支持第 0 位元素自我交换）
3. 当 0 位元素确定后，再从剩余的 n -1 个元素中任选一个，与第 1 位置上的元素交换
4. 依此类推，直至选取完所有的元素
（这一过程在原地实现，但其原理等同于把所有小球置于袋中，依次抽取决定顺序，得到随机置乱序列）

· <font color="#ffc000">代码实现：</font>
```C++
void Swap(int a, int b)
{
	int temp=a;
	a=b;
	b=temp;
}

void Shuffle(int arr[], int length)    //“shuffle”意为“洗牌”
{
	for(int i=length-1; i>0; i--)    //从索引为 0 ~ i 的元素之中随机选一个和 arr[i] 互换
	{
		int k=rand()%(i+1);
		Swap(&a[i],&a[k]);
	}
}
```



~~~ 参考：“CSDN”【依稀_yixy】《（一）基础算法》
~~~ 网站：https://blog.csdn.net/qq_39151563/article/details/124796994