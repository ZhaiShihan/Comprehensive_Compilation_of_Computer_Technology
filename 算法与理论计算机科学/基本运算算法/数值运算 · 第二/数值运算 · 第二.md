### 壹  浮点数

#### 述：
##### 五里短亭十里长，晨启暮宿却未央。
##### 行至长亭需三日，平分每日路何长？

##### 1. 浮点数取整：
###### 1. 浮点数的组成：
![[数值运算第二-图/数值运算第二-图一.png|600]]
                                （图一：浮点数的组成）
· 浮点数即小数，一个小数由整数部分、小数部分和小数点组成
· 浮点数最常见的运算就是转成整数，浮点数的取整有很多种，包括近似取整、向上取整、向下取整、向零取整等，这些取整在 C 标准库都有各自对应的函数

###### 2. 近似取整：

· 近似取整又称为“四舍五入”，当小数点后第一位的值小于等于 4 则直接舍去小数，当小数点后的第一位大于等于 5 则舍去小数后整数部分加一，再取最终值（相当于取最接近的整数值）
· 注意：对于负数的处理，去掉负号后按照正常的四舍五入规则，最后回添负号，例：-4.5 -> -5

· 四舍五入常用方法：

1. round() 函数法：
```C++
#include <math.h>    //注意头文件的调用

int a=round(8.9);    // a=9
int x=round(-5.6);    // x=-6
int b=round(-2.2);    // b=-2
int y=round(7);    // y=7
int c=round(0.1);    // c=0
int z=round(-4);    // z=-4
```

2. 强制转 int 法：
```C++
int Round(float p)
{
	if(p>=0.0f) return (int)(p+0.5f);
	else return (int)(p-0.5f);
}
```

3. floor() 函数法：
```C++
#include <math.h>    //注意头文件的使用

int Round(float p)
{
	return (int)floor(p+0.5f);    // floor() 函数的作用为向下取整
}
```

###### 3. 向下取整：

· 向下取整是取不大于该数的最大整数
· C/C++ 标准库对应的函数是 floor()，在头文件 <math.h> 中
· 对比：
```C++
int a=round(-7.3);    // a=-7
int b=floor(-7.3);    // b=-8
```

· 强制转 int 法：
```C++
int Floor(float p)
{
	if(p>=0.0f) return (int)p;
	else
	{
		int q=(int)p;
		if(p==q) return (int)p;
		else return (q-1);
	}
}
```

###### 4. 向上取整：

· 向上取整是取不小于该数的最小整数
· C/C++ 标准库对应的函数是 ceil()，在头文件 <math.h> 中
· 对比：
```C++
int a=round(-2.9);    // a=-3
int b=ceil(-2.9);    // b=-2
```

· 强制转 int 法：
```C++
int Ceil(float p)
{
	int q=(int)p;
	if(p==q) return (int)p;
	else
	{
		if(p>=0.0f) return (q+1);
		else return q;
	}
}
```

###### 5. 向零取整：

· 向零取整意为取整的结果更靠近零，即无论负号存在与否，直接舍去小数部分
· 强制转 int 的操作本身就是向零取整的过程：
```C++
int a=5.9;    // a=5
int b=-5.9;    // b=-5
```
· 可以说，向零取整就是正数部分向下取整，负数部分向上取整：
```C++
int Towards_Zero(float p)
{
	if(p>=0.0f) return floor(p);
	else return ceil(p);
}
```

###### 6. 判断浮点型数是不是整数：

· 如果浮点数不是一个整数，则小数部分不为 0，那么取整后和原来的值就不相等：
```C++
bool Integer_Or_No(float p)
{
	if(p==(int)p) return true;
	else return false;
}
```

###### 7. 提取整数和小数部分：

· C/C++ 标准库中 modf() 函数来将一个浮点数分为整数和小数部分，返回值为小数部分，整数部分通过参数返回，整数部分为原数向零取整

· <font color="#ffc000">代码实现：</font>
```C++
#include<stdio.h>
#include<math.h>

int main()
{
	float M;
	float F=modf(-5.3,&M);
	printf("%f\n",M);    //输出整数部分：-5.000000
	printf("%f\n",F);    //输出小数部分：-0.300000
}
```

· 向零取整实现法：
```C++
int M(float p)    //输出整数部分
{
	return (int)p;    //整数部分直接向零取整即得
}
float F(float p)    //输出小数部分
{
	return p-M(p);    //小数等于原数减去整数部分
}
```

##### 2. 整数除法：
###### 1. 整数除法的规则与整除的判定：

· 两个整数相除，如果正好除尽，则直接得到商；如果不能整除，则得到的小数 *向零取整* 得到结果
· 注意：整数除法中的除数不可为 0，否则程序运行会出错

· 判断两个整数相除是否可以除尽，可以通过求余的方法，只有余数为 0 时才能判定除尽

· <font color="#ffc000">代码实现：</font>
```C++
bool Exact(int a, int b)    //判断 a 是否能被 b 整除（a是被除数）
{
	if(a%b==0) return true;
	else return false;
}
```

###### 2. 正整数除法的向上取整：

· 两个正整数的除法，向零取整和向下取整的结果是相同的，如果向上取整可以通过（a+（b -1））/ b 来实现

· <font color="#ffc000">代码实现</font>：
```C++
int CeilDevide(int a, int b)
{
	return (a+(b-1))/b;
}
```

##### 3. 浮点数除法：
###### 1. 除法符号的特性：
· C 中的除法符号 “/” 对于前后都是整数的情况，按照整数除法来处理：
例如：
```C++
double a=1/2;    //返回结果是 0
double b=2/3;    //返回结果是 0
double c=4/3;    //返回结果是 1
```
· 如果要实现保留浮点数结果的除法，需要除号的前后有浮点数：
例如：
```C++
double d=1.0/2.0;    //返回结果是 0.5
double e=1.0/2.00;    //返回结果是 0.5
double f=1/2.0;    //返回结果是 0.5
double g=2.0/3.0;    //返回结果是 0.666667（保留六位小数的结果）
```
· 浮点数除法受限于存储方面的原因，大多除法结果会稍微有点误差，double 的精度高于 float 的精度

###### 2. 除数为 0.0 的情况：
· 整数除法中除数为零，程序运行会出错；浮点数除法中除数为“0”，程序运行会出错
· 浮点数除法中，除数可以为“0.0”：
1. 当被除数大于 0.0 时，返回结果为*无穷大（inf）*
2. 当被除数小于 0.0 时，返回结果为*负无穷大（-inf）*
3. 当被除数为 0.0 时，返回结果为*非数（nan（not a number））*

· 除数为零的浮点数除法，在某些编译器中，如果在编译期间检测到除零操作并设置了安全检查，则可能会报错

##### 4. 取模运算和求余运算：
###### 1. 整数求余运算：
· C/C++ 中“%”用于求余数，并且只能作用于两个整数类型变量，除数不能为0
在整数除法运算中：$$\frac{被除数}{除数}=商……余数$$
所以：$$余数=被除数-除数×商$$
当被除数不能被除数整除时，商如何取整，在有些编程语言中，是向下取整，而有些是向零取整，这就造成了得到的余数结果不同，分为**求余运算**和**取模运算**两种，这两种运算在除数和被除数异号时结果有所区别：

| 运算                        | 简记  | 整数除法的商 | 不能被整除时的结果符号 |
| ------------------------- | --- | ------ | ----------- |
| 取模运算（Modulus Operation）   | Mod | 商为向下取整 | 余数和除数同号     |
| 求余运算（Remainder Operation） | Rem | 商为向零取整 | 余数和被除数同号    |

· 当被除数不能被除数整除时，结果和除数同号的，为取模运算；结果和被除数同号的，为求余运算
· 在 C/C++ 中，整数除法的结果是向零取整， 所以 “%” 是求余运算，结果与被除数同号

###### 2. 浮点数求余运算：
· C/C++ 中的求余运算符 %只能用于两个整数型，不可用于浮点型，而且不可对零求模
· C/C++ 标准库中的 fmod() 函数支持浮点数求余运算，符号和被除数相同，结果为浮点数：
```C++
（引用头文件：#include <math.h>）
double a=-5.7, b=3.8;
double mod=fmod(a,b);    //返回结果为：-1.9
```
· 注意：当除数是 0 时，返回结果为“非数（nan）”



~~~ 参考：“CSDN”【依稀_yixy】《（二）基础运算》
~~~ 网站：https://blog.csdn.net/qq_39151563/article/details/102908319