### 壹  质数

#### 述：
##### 绕山两江开，山上三棵柏。
##### 柏后五人坐，七杯尽释怀。

###### · 质数：
· 质数又称"素数"，指在大于 1 的自然数中，除了 1 和它本身以外不存在其他（正）因数的数
· 1 既不是质数也不是合数
· 最小的质数是 2，最小的合数是 4
· 100 以内的质数：2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97

###### · 质数的规律：
· 若 n 为大于等于 2 的正整数，则：
1. n 到 n! 间一定存在质数
2. n 到 2n 之间一定存在质数
3. n<sup>2 </sup>到（n+1）<sup>2 </sup>之间一定存在质数
4. 对于一个足够大的整数 N，不超过 N 的质数*大约*有 N/lnN 个

###### · 质数的分布：
1. 除了 2 以外的质数都是奇数（否则一定会分解出因数 2 ）
2. 充分（不必要）条件：如果一个大于 3 的数是质数，则一定是 6 的倍数的相邻数：
![[质数第三-图/质数第三-图一.png|250]]
                          （图一：大于 3 的质数都分布在 6 的倍数邻位）

###### · 质因数：
· **质因数**即一个正自然数的因数中是质数的数
· 任何大于 1 的自然数，都成唯一表示成有限个质数乘积的形式  
· 质数就等于它本身，不能再被分解，而合数则至少可以分解成两个以上的质数的乘积
· 每个数的质因数分解形式是唯一的（不考虑因数分解出来的顺序），且一定存在的
· 公因数只有 1 的两个非零自然数叫做**互质数**，称这两个数**互质**
· **最简分数**就是分子和分母是互质数的分数，分数的约分本质就是分子和分母共同除以公因数的过程


### 贰  质数的判定

#### 述：
##### 红豆撒绿中，拣来二碗分。
##### 我却只挑红，绿者自剩存。

###### 1. 试除法和穷举：
· 对一个待判定的大于 1 的自然数 n，遍历到 n -1，查找是否存在被将 n 整除的整数
	· 如果存在一个数可以被 n 整除，则说明 n 是合数
	· 如果不存在可以被 n 整除的数，则说明 n 是质数
	· 判断是否可以整除，可以使用余数验证法
· <font color="#ffc000">代码实现</font>：
```C++
bool isPrime(int n)
{
	for(int i=2; i<=n-1; i++)
	{
		if(n%i==0) return false;
	}
	return true;
}
```

· **试除法的进一步优化：**

<font color="#00b0f0">角度1</font>：如果一个数 n 是合数，则必定有一个不大于根号 n 的因数
· <font color="#ffc000">代码实现</font>：
```C++
bool isPrime(int n)
{
	for(int i=2; i*i<=n; i++)    //将循环进行条件修改为 i 的平方小于等于 n
	{
		if(n%i==0) return false;
	}
	return true;
}
```

<font color="#00b0f0">角度2</font>：合数一定存在质因数，除了 2 和 3 外，所有的质数都分布在 6 的倍数邻位
· <font color="#ffc000">代码实现</font>：
```C++
bool isPrime(int n)
{
	if((n>3)&&(n%2==0||n%3==0)) return false;
	for(int i=6; (i-1)*(i-1)<=n; i+=6)
	//循环进行条件使用 (i-1)^2，以防最大的 6 的倍数小于根号 n 而丢解
	{
		if(n%(i-1)==0||n%(i+1)==0) return false;
	}
	return true;
}
```

· **求解不大于 N 的所有的质数**：
```C++
void findPrime(int N)
{
	if(N>=2) printf("2\n");
	if(N>=3) printf("3\n");
	for(int i=6; i-1<=n; i+=6)
	//循环进行调节使用 i-1，当最大的 6 的倍数小于 n 时，确保 6 的倍数邻位的质数全部考察到
	{
		if(isPrime(i-1)) printf("%d\n",i-1);
		if((i+1<=N)&&isPrime(i+1)) printf("%d\n",i+1);
	}
	return;
}
```

###### 2. 素数筛法：
· 素数筛是通过将范围内的合数筛除的方法找出质数
· 素数筛需要额外的空间去标记每一个数是否是质数，空间复杂度为 O(n)
· 原理：每找到一个质数，标记所有它的倍数，被标记的数一定是合数，无需进行质数检验
· 素数筛有两大典型算法：埃拉托斯特尼素数筛算法，欧拉素数筛算法（专题内分立篇目详细介绍）


### 叁  质因数分解

#### 述：
##### 荡荡河水流，摇摇扁舟渡。
##### 人多皆欲行，船少难单出。
##### 三人共一船，不出者十五。
##### 五人共一船，不出者仍五。
##### 由此能得算，舟驾与人数。
##### 六人结伴行，恰可全员出。

· 任一大于 1 的自然数，要么本身是质数，要么可以分解为几个质数的乘积，且这种分解是唯一的
· 对于一个给定的大于 1 的自然数 n，如果要将其分解成质因数乘积的形式：
1. 从 2 到 n 开始遍历，用试除法寻找质因数，找不到说明是质数
2. 当寻找到质因数时，记录这个值，将 n 除以这个值，重复第一步的操作
3. 遍历结束，寻找终止
· <font color="#ffc000">代码实现</font>：
```C++
void Prime_Factorization(int n)
{
	if(n<2)
	{
		printf("%d\n");
		return;
	}
	else
	{
		for(int i=2; i<=n; i++)
		{
			while(n%i==0)
			{
				printf("%d\n",i);
				n/=i;
			}
		}
		return;
	}
}
```

· **质因数分解的进一步优化**：
1. 质因数一定成对出现，一个小于等于根号 n，一个大于等于根号 n，故只试除到根号 n 即可
2. 因数只考虑 2、3 和 6 的倍数邻位的质数即可
3. 只试除到根号 n 的方式下，n 最后可能不归为 1，需要进行特判 n 是自己的最大因数
· <font color="#ffc000">代码实现</font>：
```C++
（ ceil() 函数需要调用头文件：#include<math.h>）

void ContinueDevide(int* n, int i)    //连除函数，用于相同质因数的重复分解
{
	while(*n %i==0)
	{
		printf("%d\n",i);
		*n /=i;
	}
}

int Square(int n)    //开根号函数（向上取整）
{
	return (int)(ceil(sqrt(n)));
}

void PrimeFactorization(int n)
{
	if(n<2)
	{
		printf("%d\n",n);
		return;
	}
	else
	{
		ContinueDevide(&n, 2);
		ContinueDevide(&n, 3);
		//单独分解出质因数 2 和 3
		for(int i=6; i-1<=Square(n); i+=6)
		{
			ContinueDevide(&n, i-1);
			ContinueDevide(&n, i+1);
		}
		if(n!=1) printf("%d\n",n);    //如果最后的 n 不是 1，则它自己是此时最大的质因数
	}
}
```



~~~ 参考：“CSDN”【依稀_yixy】《（四）质数（素数）》
~~~ 网站：https://blog.csdn.net/qq_39151563/article/details/108294687