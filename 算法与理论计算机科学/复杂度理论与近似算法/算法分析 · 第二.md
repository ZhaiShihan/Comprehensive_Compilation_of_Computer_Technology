### 壹  greedy 和 Local Search

####
#####
#####

###### · 局部考量概述：
· 贪心算法和局部搜索都是通过做出一系列优化局部选择的决策来工作的，尽管这些局部选择可能不会导致最佳的整体解决方案：
	· 贪心（Greedy）：一个解是一步一步构造的，在算法的每一步，解的下一部分是通过做出一些局部最佳可能的决策来构造的
	· 局部搜索（Local Search）：从任意可行解开始，然后检查解的局部小变化是否会导致目标函数的改进：如果是，则进行更改；当不能进一步改变时，我们有一个局部最优解
	· 这两种算法都优化了局部选择（Local choices）
	· 贪心算法是典型的“原始不可行”的算法：在算法过程中构造问题的解（(从无到有搜索 feasible solution）
	· 局部搜索算法是一种“原始可行”算法：在求解过程中始终保持问题的可行解，并对其进行修正（不断 improve feasible solution）
· Greedy 和 Local Search 的优点：实现简单、Efficient（高校）

###### · 工作日程安排（Scheduling Jobs on Machines）：
· 问题描述：给定一些必须完成的工作以及做工作需要的资源，创建一个最优日程表，尽可能完成所有的工作，保证每个任务平均花费时间最短
· 问题来源：并行处理机的任务优化、日常工作安排等；单一机器（Single machine）：电梯的运行方案等

· *先考虑 easy 模式*：
· 一个处理线程，且同一时间只能做一个工作，一旦开始一个工作，必须不带暂停地将其完成
· 给定一系列任务，每一个任务都有一个开放时间 $r_j$（不等同于开始做的时间）、一个截至时间 $d_j$、一个任务需要时长 $p_j$；
· 假定日程表的时间从零开始，每个任务的开放时间 $r_j$ 都大于零
· 如果我们完成任务 $j$ 的时刻为 $C_j$，那么这个任务的延迟时间（Lateness）$L_j=C_j-d_j$
· 目标：设计工作日程表，使得最大的 Lateness 最小，即 $minimize\ L_{max}=\max_{(j=1,\ldots,n)}L_j$
· 这是一个 NP-难 问题
· 示例：
![[复杂度理论图/复杂度理论图2-1.png|600]]
                         （图一：工作日程安排问题的一维图示化）
1. 用 Greedy 方法求解：
· 在每一个选择的时刻 t，选择当前候选集里 due data（截止日期）最小的那个，也就是优先完成“最紧急”的 job
· 该方法无常数近似比，考虑一个特殊情况，假设每一个 $d_j\leq 0$，也就是最优解永远都是正数，此时有 2-近似 的算法
· 先看最优解的下界（Lower Bound），令 S 表示 jobs 的子集，$r(S)=\min_{(j\in S)}r_j$（S 里最早来任务的时刻），$p(S)=\Sigma_{(j\in S)}p_j$（所有任务所需完成时间的总和），$d(S)=\max_{(j\in S)}d_j$（最晚的 due），令 $L^*_{max}$ 表示最优解

· 定理：对于任意的工作子集 S，有：$L^*_{max}\geq r(S)+p(S)-d(S)$
· 证明：考虑最优调度，并将其简单地视为子集 S 中任务的调度，让任务 j 成为 S 中要处理的最后一个任务，由于在 $r(S)$ 之前无法处理 S 中的任何任务，总的来说，它们需要 $p(S)$ 个时间单位来处理，因此任务 j 不能在 $r(S)+p(S)$ 时间之前完成；由于工作 j 的截止时间是 $d(j)$ 或更早，因此此调度中任务 j 的延迟时间至少为 $r(S)+p(S)-d(S)$，所以 $L^*_{max}\geq L_j\geq r(S)+p(S)-d(S)$
![[../../Pasted image 2222.png]]
（图二：单线程工作分配问题中最优解的下限推导）

· 设一个时刻 t，如果一个工作 j 的开放时间满足 $r_j\leq t$，则这个工作是可以做的
· 考虑以下自然算法：在机器空闲的每个时刻，开始处理下一个具有最早到期的开放任务，这就是所谓的最早截至（EDD）规则

· 定理：EDD 规则是一个 2-近似 算法，用于受到负截止日期约束的单线机器上的最大延迟问题，将最大延迟最小化
~~~
· 证明：
令工作 j 为这个时间表中延迟最大（在负截止日期约束下，即一定是最后做）的工作，即 Lmax=Cj-dj
寻找最早的时间 t 使得工作子集 S 都在 [t,CJ) 中，并且 t=r(S)
~~~
![[Pasted image 20240322170325.png|450]]
                            （图三：求解 EDD 规则的近似比）
~~~
因为在这个时间间隔内只处理 S 中的任务，则 p(S) = Cj-t = Cj-r(S) ≥ 0
因此 Cj ≤ r(S)+p(S)
由于 d(S) ＜ 0，可以应用定理 L*max ≥ r(S)+p(S)-d(S) 得到 L*max ≥ r(S)+p(S) ≥ Cj

另一方面，如果 S={j}，再根据上述定理：L*max ≥ r(j)+p(j)-d(j) ≥ -dj

这两个不等式（L*max ≥ Cj 和 L*max ≥ -dj）相加，得：
Lmax ≤ Cj-dj ≤ 2×L*max，变形得：Lmax/L*max ≤ 2
即近似比为 2
~~~

###### · K 中心问题（The K-center Problem）：
· 问题描述：分析问题中大数据的相似与不相似性
	· 商店买衣服收集顾客兴趣爱好
	· 政客分析选区投票倾向
	· 搜索引擎中按与用户需求的相似性，架构布局
· 这些问题被称为“聚类数据”（clustering data），The K-center Problem 就是一个 clustering 问题
· *模型陈述*：输入一个无向完全图 $G=(V,E)$，V 中每一对定点 i，j 之间的距离 $d_{ij}\geq 0$；假定 $d_{ii}=0,\ d_{ij}=d_{ji}$，并且这个距离符合几何中的三角不等式，给定常数 k；目标是找到 k 聚类，将最相似的顶点分组到一起，选择顶点 V 的一个子集 S，使得 $|S|=k$，每个顶点作为最近的聚类中心，将顶点分组到 k 个不同的聚类中；**目标**是将所有顶点到聚类中心的最大距离最小化

· 问题的一种等价的描述：目标是找到 k 个不同球的中心，这些球具有相同的半径，覆盖所有点，使半径尽可能小
· 给定 S 中的一个顶点 i，定义 S 中每个点到 i 的最小距离：$d(i,S)=\min_{(j\in S)}d_{ij}$；那么上述 S 中的最大半径等于 $\max_{j\in S}d(i,S)$；K-center problem 的目标是寻找可以达到半径最小的 k 个球心（集合） 

· K-center problem 是一个 NPC 问题
~~~
1. 证明判定问题属于 NP：
显然，给定半径限制 r，中心点集 S 和 k，验证 S 是一个 k-center 在 P 时间内可以完成（线性时间），其复杂度等于计算所有点到 S 中各点最小距离的最大值的复杂度

2. 证明 k-支配集问题（NPC）≤p k-中心问题：
· k-支配集问题：给定图 G=(V,E)，和整数 k，寻找 k 个点的集合 S（V 的子集），使得所有的点要么在 S 中，要么与 S 中的点直接相邻
· 令 G 中所有边长度为 1，则每个 k-center 的解对应一个 k-支配集的解，反之亦然
· 由于 k-支配集问题是 NPC，故 k-center 是 NPC
~~~

· 给出一个贪心 2-近似算法：
1. 选择任意一点 i 放入中心集 S 中
2. 下一个 center 要尽可能远离所有的已有 center
3. 重复操作，直到 $\lvert S \rvert=k$
~~~
· 算法伪代码：
Pick arbitrary i∈V
S ← {i}
while |S|＜k do
	j ← arg max{j∈V} d(j,S)
	S ← S∪{j}
~~~

· 定理：k-center 问题使用贪心算法是一个 2-近似算法
~~~
· 证明：
在 OPT 情况下：
	设 S*={j1,……,jk} 表示最优解，其半径为 r*；
	该解可将所有点划为 V1，……，Vk 这 k 个部分，这意味着 Vi 中的一点距离 i 中心要比其他中心都近；
	同一个聚簇中的每一对点之间的最大距离不超过 k-center 问题的直径 2r*（因为满足三角不等式）；
现在考虑贪心算法所得解 S：
	现要证明：V 上的任何一个点都会与 S 中某点的距离 ≤ 2r*；
	假设贪心算法前后两次选择的点 j' 和 j 都是 OPT 的同一个聚簇 Vi 中的点，则二者距离最大为 2r*；
	贪心选择 j 的理由是，j 距离目前已有 S 中所有的点的最小距离是最大的，这个最大距离也不大于 2r*；
	因此，所有的点到已有的 S 中的某点之间距离都小于 j 的距离，故都小于 2r*；
	当两次选择的点 j' 和 j 分别在 OPT 的 Vk 和 Vh 中，这种情况显然满足欲证条件：
		Vk 中的所有点都到 j' 距离 ≤ 2r*，Vh 中的所有点都到 j 距离 ≤ 2r*
由此可以得到，贪心算法所得 S 的半径 r ≤ 2r*，即：R ≤ 2*OPT
故 k-center 问题的贪心算法是一个 2-近似算法
~~~

· 定理：不存在一个 α-近似算法（α＜2）解决 k-center 问题，除非 P=NP
~~~
· 证明：
在之前的 k-支配集问题中，令所有有边直接连接的点距离为 1，无直接边结点之间距离为 2；
此时 k-支配集的成立意味着 k-center 问题的最优半径为 1；
如果存在一个 α＜2 的近似算法，则意味着这个算法得到的 r＜2*OPT=2，小于 2 在这里只能取整数 1；
也就是说这个近似算法得到的一定是 k-center 的一个半径为 1 的解，对应 k-支配集中的恒最优解 OPT；
由于 k-支配集的 NPC 性，这个近似算法恒得最优解是不可能的，除非 P=NP；
由此得到：除非 P=NP，不然不会存在一个 α＜2 的近似算法解决 k-center 问题
~~~

