#### 1. $k$ 供应商问题的 $3$—近似算法

###### 问题描述：

· $k$ 供应商问题类似于 $k$ 中心问题，问题的输入是一个正整数 $k$，以及一组顶点 $V$，还有任意两个顶点 $i, j$ 之间的距离 $d_{ij}$，这些距离遵循与 $k$ 中心问题相同的属性

· 现在这些顶点被划分为供应商 $F\subseteq V$ 和客户 $D=V-F$

· 目标是找到 $k$ 个供应商，使得从供应商到客户的最大距离最小化，即找到 $S\subseteq F$，$\lvert S\rvert\leq k$，使得 $max_{j\in D}\ d(j,S)$ 最小化

【a】为 $k$ 供应商问题给出一个 3—近似算法

【b】证明不存在 $\alpha\textless 3$ 的近似算法，除非 $P=NP$

###### 问题 a 求解：

1. 选择任意一个供应商顶点作为第一个供应商，将其加入集合 $S$ 中
2. 重复以下步骤直到集合 $S$ 中有 $k$ 个供应商：
	1. 对于每一个客户 $j\in D$，计算其到集合 $S$ 中最近供应商的距离 $d(j,S)$
	2. 找到距离集合 $S$ 最远的客户 $j$，然后选择距离这个客户最近的供应商 $i\in F$ 作为新的供应商，将其加入集合 $S$ 中
3. 返回结果：集合 $S$ 中的 $k$ 个供应商

· 每次选择新的供应商时，所增加的覆盖范围不会超过当前最远客户到当前集合 $S$ 的最短距离的 $2$ 倍，因此，新的供应商到任何未覆盖客户的最远距离最多是 $2\cdot d(j,S)$，加上最初的一步，最坏情况下，该算法选择的供应商集合的最大覆盖距离最多是 $3\cdot OPT$

###### 问题 b 求解：

· 使用类似于 $k$ 中心问题的证明方法，借助 $k$ 支配集（$k$-dominating set）的 $NPC$ 性来证明

· 假设存在一个 $\alpha < 3$ 的近似算法 $A$，对于给定的图 $G$，我们构造一个对应的 $k$ 供应商问题实例。对于图 $G$ 中的任意两个顶点 $i$ 和 $j$，如果 $i$ 和 $j$ 之间有边，则设定 $d_{ij} = 1$，否则设定 $d_{ij} = 2$

· 这样构造的实例中，$G$ 中存在大小为 $k$ 的支配集当且仅当这个 $k$ 供应商问题的最优半径为 $1$

· 假设存在一个 $\alpha\textless 3$ 的近似算法 $A$，那么当存在大小为 $k$ 的支配集时，算法 $A$ 必须找到一个半径为 $1$ 的解，因为任何半径小于 $3$ 的解实际上必须是半径为 $1$ 的解

· 这与 $k$ 支配集问题是 $NPC$ 问题矛盾，因此不可能存在 $\alpha < 3$ 的近似算法，除非 $P = NP$


#### 2. 相同并行机器上最小化总完工时间问题，在 $p_i\textgreater\frac{1}{3}$ 下 LPT 可得最优解

###### 问题描述：

· 证明：对于在相同并行机器上最小化总完工时间（makespan）的问题，如果每个作业的处理时间需求都超过最优完工时间的三分之一，那么使用最长处理时间优先（LPT）规则可以得到一个最优调度方案

###### 问题求解：

· 最优完工时间 $C^*_{\text{opt}}$ 是所有可能调度中机器上最后完成的作业的最短时间，故设最优调度中每台机器的最大负载为 $C^*_{\text{opt}}$

· $LPT$ 规则通过优先分配长作业，确保负载最小的机器得到较长的作业

· 因为每个作业的处理时间 $p_i\textgreater \frac{1}{3} C^*_{\text{opt}}$，那么在任何一个机器上，最多只能有两个作业，否则该机器的总负载将超过 $C^*_{\text{opt}}$
        
· 因此，每台机器上的负载最多为两个作业的总和，这意味着即使是 $LPT$ 规则下负载最小的机器，在分配完两个作业后，其负载也不会超过 $C^*_{OPT}$​

· 假设使用 $LPT$ 规则得到的最大完工时间为 $C_{\text{max}}$，根据 $LPT$ 规则的调度策略和上述分析，$C_{\text{max}}$ 不会超过 $C^*_{\text{opt}}$，因为每台机器最多只能容纳两个作业，且这些作业的处理时间和不会超过 $C^*_{\text{opt}}$

· 因此，$C_{\text{max}}=C^*_{\text{opt}}$，即 $LPT$ 规则在这种特定情况下可以得到最优调度


#### 3. 列表调度算法对于有优先顺序约束的问题是一个 $2$—近似算法

###### 问题描述：

· 考虑在相同的机器上调度作业的问题，现在作业之间存在优先顺序约束：如果在任何可行的调度中，作业 $i$ 必须在作业 $j$ 开始处理之前完全处理完毕，那么我们称 $i\prec j$

· 一种自然的列表调度算法变体是：每当一台机器空闲时，将任何可以执行的剩余作业分配到该机器上开始处理；所有使得 $i\prec j$ 的作业 $i$ 都已经完全处理完毕，则作业 $j$ 是可以执行的

· 证明这种列表调度算法对于有优先顺序约束的问题是一个 $2$—近似算法

###### 问题求解：

· 定义：
1. $C^*$：最优调度时间
2. $C_{LS}$​：列表调度算法的调度时间
3. $p_j​$：作业 $j$ 的处理时间
4. $S_j$​：作业 $j$ 的开始时间
5. $C_j$​：作业 $j$ 的完成时间

· 下界：
1. $C^*\geq \frac{\sum_{j=1}^np_j}{m}$​​：最优调度时间至少为所有作业处理时间总和除以机器数
2. $C^∗\geq max_j​\ p_j​$：最优调度时间至少为最长的作业处理时间
    
· 列表调度算法不会让任何机器在有可用作业时空闲

· 对于作业 $j$ 的完成时间 $C_j$​：$Cj_​=S_j​+p_j$​，列表调度算法保证作业 $j$ 的开始时间不会超过最优调度时间 $C^*$，所以 $S_j​\leq C^*$

· 因此：$C_j\leq ​C^*+p_j$​，因为 $p_j\leq C^*$，所以：$Cj_​\leq C^*+C^*=2C^*$
        
· 由于 $C_{LS}=max_j\ C_j$，故 $C_{LS}\leq 2C^*$，因此该算法是一个 $2$—近似算法


#### 4. 最小成本 Steiner 树问题中度量完成图法是一个 $2$—近似算法

###### 问题描述：

· 在最小成本 Steiner 树问题中，我们的输入是一个完整的无向图 $G=(V,E)$，其中所有边 $(i,j)\in E$ 的成本 $c_{ij}​\geq0$ 都是非负的

· 顶点集被划分为终端点 $R$ 和非终端点（或 Steiner 顶点）$V-R$

· 目标是找到一个包含所有终端点的最小成本树

【a】假设边的成本遵循三角不等式，即对于所有 $i,j,k\in V$，有 $c_{ij}​\leq c_{ik}​+c_{kj}​$，设 $G[R]$ 为在终端点集合 $R$ 上诱导的图，即 $G[R]$ 包含 $R$ 中的顶点和在 $G$ 中两个端点都在 $R$ 中的边，考虑在 $G[R]$ 中计算最小生成树；证明这给出了最小成本 Steiner 树问题的一个 $2$—近似算法

【b】现在我们假设边的成本不遵循三角不等式，并且输入图 $G$ 是连通的但不一定是完整的；设 $c_{ij}^{'}$​ 为 $G$ 中使用输入边成本 $c$ 的从 $i$ 到 $j$ 的最短路径成本，考虑在顶点集 $V$ 上的完整图 $G^{'}$ 中运行上述算法，其中边成本为 $c^{'}$，以得到一棵树 $T^{'}$；为了在原始图 $G$ 中计算一棵树 $T$，对于 $T^{'}$ 中的每条边 $(i,j)$，在 $T$ 中添加从 $i$ 到 $j$ 的最短路径上的所有边，使用输入边成本 $c$；证明这仍然是原始（不完整）输入图 $G$ 上最小成本 Steiner 树问题的一个 $2$—近似算法（ $G^{'}$ 有时被称为 $G$ 的度量完成（metric completion））

###### 问题 a 求解：

· 定义：
1. $T^*$：最有 Steiner 树，包含所有终端点，且成本最小
2. $T_{MST}$：在 $G[R]$ 计算的最小生成树

· 去掉 $T^*$ 中所有 Steiner 顶点 $S=V-R$ 和相关边，得到 $T^*[R]$，诱导子图 $T^*[R]$ 的成本不超过 $T^*$ 的总成本，即 $c(T^*[R])\leq c(T^*)$

· 由于 $T_{MST}$​ 是 $G[R]$ 的最小生成树，且 $T^*[R]$ 是一个生成树，因此 $c(T_{MST}​)\leq c(T^*[R])$，故有：$c(T_{MST})\leq c(T^*)$

· 对于 $T_{MST}$​ 中的每条边 $(i,j)$，由于三角不等式 $c_{ij}\leq c_{ik}​+c_{kj}​$，故用原图 $G$ 中的路径来替换 $T_{MST}$ 中的边，总成本：$c(替换后的树)\leq 2\cdot c(T_{MST})$，故 $c(替换后的树)\leq 2\cdot c(T^*)$，因此该算法是一个 $2$—近似算法

###### 问题 b 求解：

· 设 $T^*$ 是原图 $G$ 上的最优 Steiner 树

· $T^{'}$ 是在度量完成图 $G^{'}$ 上的最小生成树，因此满足 $c^{'}(T^{'})≤c^{'}(T^*)$，其中 $T^*$ 是最优 Steiner 树在 $G$ 中的映射

· 对于 $T^{'}$ 中的每条边 $(i,j)$，用原图 $G$ 中从 $i$ 到 $j$ 的最短路径替换；最短路径的总成本为 $c_{ij}^{'}$​，在替换过程中不超过 $c(T^{'})$

· 新构造的树 $T$ 的总成本 $c(T)$，满足：$c(T)=\sum_{(i,j)\in T^{'}}c_{ij}^{'}\leq c^{'}(T^{'})$

· 当替换 $T^{'}$ 中的边时，最坏情况下，每条边的最短路径可能会与另一条边共用一部分路径，这可能导致路径被重复计算，因此每条边 $c_{ij}^{'}$​ 在 $G$ 中的展开成本最多会被计算两次：$c^{'}(T^{'})\leq2\times c(T^*)$

· 故 $c(T)\leq c^{'}(T^{'})\leq2\times c(T^*)$，仍然是一个 $2$—近似算法


#### 5. 用局部搜索算法寻找度数上界为 $2\ OPT+\lceil log_2​n\rceil$ 的 Steiner 树

###### 问题描述：

· 在 Steiner 树问题中，给定一个无向图 $G=(V,E)$ 和一个终端集合 $R\subseteq V$，Steiner 树是在图 $G$ 中使所有终端相连的一棵树；非终端点不必被覆盖

· 请证明，下述局部搜索算法可以被改编，用以找到一个Steiner树，使其最大度数至多为：$$2\ OPT+\lceil log_2​n \rceil$$其中 $OPT$ 是最小度 Steiner 树的最大度数

· 算法如下：
1. 初始生成树：从一个任意的生成树 $T$ 开始
2. 局部移动：对高度节点进行局部移动，以减少其度数:
	1. 选择一个度数较高的节点 $u$，并尝试通过加入不在 $T$ 中但可以形成包含 $u$ 的环的边 $(v,w)$ 来减少其度数
    2. 如果 $max(\ d_T​(v),d_T​(w)\ )\leq d_T​(u)-2$，则进行局部移动，即将 $(v,w)$ 加入生成树，并从生成树中删除一个与 $u$ 相邻的边（节点 $v$ 和 $w$ 的度数的最大值不超过节点 $u$ 的度数减去2，如果条件满足，则进行局部移动）
    3. 这种局部移动保证了 $u$ 的度数减少，同时 $v$ 和 $w$ 的度数不会超过减少后的 $u$ 的度数
3. 局部优化：对度数较高的节点反复进行上述局部移动，直到无法再进行有效移动
4. 停止条件：如果在度数较高的节点（度数在 $\Delta(T)-\ell$ 和 $\Delta(T)$ 之间）上无法进行任何局部移动，则算法停止，生成树达到局部最优

· 其中：
1. $d_T​(x)$：节点 $x$ 在生成树 $T$ 中的度数，即与 $x$ 相连的边的数量
2. $\Delta(T)$：当前生成树 $T$ 中的最大度数，即生成树中度数最大的节点的度数
3. $\ell=\lceil log_2​n\rceil$：$n$ 是图中节点的数量，$\ell$ 是 $log_2n$ 的上取整，用于设定局部搜索的范围

###### 问题求解：

· 移除生成树中的 $k$ 条边，生成 $k+1$ 个连通分量：设 S 为连接这些连通分量的节点集合，任何 Steiner 树必须至少有 $k$ 条边连接这些连通分量，因此 $OPT\geq\frac{k}{\lvert S\rvert}$

· 设 $S_i$​ 为局部最优 Steiner 树 $T$ 中度数至少为 $i$ 的节点集合，对于 $i\geq\Delta(T)-\ell+1$，至少有 $(i-1)\lvert S_i\rvert+1$ 条不同的边与 $S_i$​ 中的节点相连
  
· 假设不存在 $i\geq\Delta(T)-\ell+1$ 使得 $\lvert S_i-1​\rvert\leq2\lvert S_i​\rvert$，这将导致矛盾，这意味着：$$\lvert S_{\Delta(T)-\ell}\rvert\textgreater 2^\ell\lvert S_{\Delta(T)}\rvert\geq 2^\ell=2^{\lceil log_2n\rceil}\geq n$$图中最多 $n$ 个节点，故这是不可能的，$i\geq\Delta(T)-\ell+1$ 必存在

· 通过以上步骤构建的下界，证明对于局部最优 Steiner 树 $T$，其最大度数 $\Delta(T)$ 满足：$$\Delta(T)\leq2\  OPT+\lceil log_2​n\rceil$$


#### 6. 用贪心 $(1-\frac{1}{e})$—近似算法求解最多包含 $k$ 个元素的子集最大化问题

###### 问题描述：

· 设 $E$ 是一组元素，对于 $S\subseteq E$，令 $f(S)$ 表示子集 $S$ 的值

· 假设希望找到一个最多包含 $k$ 个元素的 $E$ 的子集，使其值最大

· 此外假设 $f(\emptyset) = 0$，并且 $f$ 是单调和次模的

· 定义：
1. 如果对于任何 $S$ 和 $T$，满足 $S\subseteq T\subseteq E$，则 $f(S)\leq f(T)$，那么 $f$ 是单调的
2. 如果对于任何 $S$，$T\subseteq E$，满足 $f(S)+f(T)\geq f(S\cup T) + f(S\cap T)$，那么 $f$ 是次模的

· 证明如下贪心 $(1-\frac{1}{e})$—近似算法可以扩展到这个问题：

· 贪心 $(1-\frac{1}{e})$—近似算法：
1. 初始化：设定 $S=\emptyset$
2. 循环直到选出 $k$ 个元素：在每一步，选择一个能使目标函数增量最大的元素 $i$ 加入 $S$，即选择使 $v(S\cup{i})-v(S)$ 最大的 $i$
3. 返回集合 $S$

###### 问题求解：

· 引理：在每一步中，选择能最大化增量的元素 $i$，即：$f(S\cup{i})-f(S)\geq \frac{1}{k}​(f(O)-f(S))$ 其中，$O$ 是最优解

· 由次模性得出：对于任意 $S\subseteq T\subseteq E$ 和 $i\in E\backslash T$ 有：$f(S\cup{i})-f(S)\geq f(T\cup{i})-f(T)$

· 考虑最优解 $O$，令 $O\backslash S$ 为当前未被选择的最优解中的元素；由于 $O$ 最多包含 $k$ 个元素，根据次模性和贪心选择的性质，我们有：$f(S\cup{i})-f(S)\geq \frac{1}{k}\sum_{i\in O\backslash S}​(f(S\cup{i})−f(S))$ 至少有一个 $i\in O\backslash S$ 满足：$f(S\cup{i})-f(S)\geq \frac{1}{k}​(f(O)-f(S))$

· 设 $S_t$​ 是第 $t$ 步的集合，根据引理有： $f(S_{t+1}​)\geq f(S_t​)+\frac{1}{k}​(f(O)-f(S_t​))$

· 递归展开：$f(S_{t+1}​)\geq f(O)(1-(1-\frac{1}{k}​)^{t+1})$ 

· 当 $t=k$ 时：$f(S_k​)\geq f(O)(1-(1-\frac{1}{k}​)^k)$ 由于 $1-\frac{1}{k}$​ 的 $k$ 次方近似于 $e^{-1}$，得到：$f(S_k​)\geq f(O)(1-\frac{1}{e}​)$

· 故可得证贪心 $(1-\frac{1}{e})$—近似算法可以扩展到这个问题


#### 7. 用 $(1-\frac{1}{e})$—近似算法求解最大覆盖问题

###### 问题描述：

· 最大覆盖问题中，我们有一个元素集合 $E$，以及 $m$ 个元素的子集 $S_1​,S_2​,\cdots,S_m​\subseteq E$，每个子集都有一个非负权重 $w_j\geq 0$，目标是选择 $k$ 个元素，使得被覆盖的子集的权重最大化

· 如果从一个子集中选择了某个元素，则称该子集被覆盖，现要找到一个子集 $S\subseteq E$，使得 $\lvert S\rvert=k$，并且最大化那些满足 $S\cap S_j​\neq\emptyset$ 的子集 $j$ 的总权重

· 给出一个 $(1-\frac{1}{e}​)$ 近似算法来解决这个问题

###### 问题求解：

· 算法设计：
1. 初始化：从 $\emptyset$ 开始，已覆盖的权重总和为 $0$
2. 迭代选择：
	1. 在每次迭代中，我们计算每个未选择的元素 $e$ 的边际收益，即加入 $e$ 后能增加的权重
	2. 选择边际收益最大的元素加入已选择集合 $S$ 中
3. 停止条件：当选择了 $k$ 个元素后，算法停止，返回已选择的元素集合

· 近似比论证：
1. 贪心每一步选择 $e$ 使得当前增益（新覆盖的子集权重）最大化，至少为 $\frac{1}{k}​(OPT-W)$
2. 每一步选择时的递归：$W_{i+1}​\geq W_i​+\frac{1}{k}​(OPT-W_i​)$
3. 迭代累计：$W_i\geq OPT(1-(1-\frac{1}{k})^i)$
4. 第 $k$ 个元素时的“极限”：$W_k\geq OPT(1-\frac{1}{e})$

· 故上述算法可以保证 $(1-\frac{1}{e})$ 的近似比

