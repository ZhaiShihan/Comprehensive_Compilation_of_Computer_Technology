### 壹  定义性质

#### 述：
##### 一元本初生两仪，四象八卦衍太极。
##### 子子孙孙几时尽？明月万古照合离。

#### 二叉树：
##### 二叉树的类型：
###### 1. 空树
###### 2. 由一个根结点加上两棵分别称作左子树和右子树的、互不交的二叉树组成

##### 五种基本形态：
###### 1. 空树；  2. 只含根结点；  3. 右子树为空树；  4. 左子树为空树；  5. 左右均不为空树

##### 两类特殊的二叉树：
###### 1. 满二叉树：高度为 h 且含有 ( 2 ^ h ) - 1 个结点的二叉树
![[纪第八-图/纪第八-图一.png|500]]
                                            （图一：一个高度为 4 的满二叉树）
###### 2. 完全二叉树：树种所含的 N 个结点和满二叉树中编号为 1 到 N 的结点一一对应
![[纪第八-图/纪第八-图二.png|500]]
                                    （图二：删去了 13、14、15 号点的完全二叉树）

#### 二叉树的性质：
##### 1. 二叉树的第 i 层上至多有 2 ^ ( i - 1 ) 个结点 （ i >= 1，根结点所在的层数为 1 ）
###### · 数学归纳法：第一层一个结点，之后每层结点数最多为上一层的 2 倍
##### 2. 高度为 h 的二叉树上至多含有 ( 2 ^ h ) - 1 个结点  （ h >= 1 ）
###### · 2^0 + 2^1 + 2^2 + …… + 2^(h-1) = (2^h) - 1
##### 3. 对于一棵二叉树，若含有：1. N0 个叶子结点；2. N2 个度为 2 的结点，则必存在关系式：
#####            【 N0 = N2 + 1 】
###### · 总结点的个数：N = N0 + N1 + N2
###### · 二叉树上的分支总数：B = N1 + 2N2
###### · 二叉树的分支个数等于结点总数减一： B = N - 1
###### · 故有 N1 + 2N2 = N0 + N1 + N2 - 1   ------>   N0 = N2 + 1
##### 4. 具有 N 个结点的完全二叉树的高度为 log<sub>2</sub>(n+1) 的向上取整
###### · 设完全二叉树的高度为 h
###### · 根据第二条性质：2<sup>h-1</sup> - 1 < n <= 2<sup>h</sup> - 1   ------>   2<sup>h-1</sup> < n + 1 <= 2<sup>h</sup> 
###### · h - 1 < log<sub>2</sub>(n+1) <= h   ------>   h >= log<sub>2</sub>(n+1)，即对数向上取整
##### 5. 完全二叉树的性质：
##### · 将二叉树的每个结点按照从上到下且从左到右编号，根结点编号为 1，则第 i 个结点：
#####     · 如果 i = 1，则无双亲结点
#####     · 如果 i > 1，则 i 的双亲结点的编号为 (int) i/2
![[纪第八-图/纪第八-图三.png|500]]
                                    （图三：i 的双亲结点编号是自身的一半的向下取整）
#####     · 如果 2i > n，则结点 i 无左孩子；否则，左孩子结点的编号为 2i
#####     · 如果 2i +1 > n，则结点 i 无右孩子；否则，右孩子结点编号为 2i +1
##### 6. 如果根结点从 0 开始编号，则结点 i 与其父结点和子结点的关系是：
![[纪第八-图/纪第八-图四.png]]
（图四：当根结点的编号是 0 时，结点 i 左孩子的编号是 2i +1，右孩子是 2i +2，父结点是 (int) (i-1)/2 ）

##### 其他形态的二叉树：
![[纪第八-图/纪第八-图五.png]]


### 贰  顺序存储

#### 述：
##### 横扫纵延从一编，逐格对字落座看。
##### 如无结点空中段，按序列位至末完。

![[纪第八-图/纪第八-图六.png|750]]
                        （图六：用数组按照完全二叉树的编号存储每一个结点）

```C++
#define MAX_TREE_SIZE 1000
//定义二叉树的最大结点数

typedef struct
{
	int data[MAX_TREE_SIZE];    //存储数组
	int n;    //当前结点个数
} SqBTree;
```

###### · 注：此处的 int data【·】可以根据情况将数组换成其他数据类型


### 叁  二叉链表

#### 述：
##### 一父二子分，二子左右邻。
##### 问父即知子，问子父难寻。

![[纪第八-图/纪第八-图七.png|575]]
                                             （图七：二叉链表存储的原理图）
![[纪第八-图/纪第八-图八.png|450]]
                                             （图八：结点的存储结构）
```C++
typedef struct BiTNode    //结点结构
{
	int data;    //存储内容
	struct BitNode *lchild, *rchild;    //左右孩子指针
} BiTNode, *BiTree;
```
· 这里每一个左右孩子都代表一个新的结点结构，它们各自又有向下分的孩子指针
· 将 struct BiTNode 数据类型以标识符 BiTNode 代替；
 将 struct BiTNode * 数据类型以标识符 BiTree 代替
###### · 二叉链表时间复杂度：访问子结点：O ( 1 ) ；访问父结点：O ( n )


### 肆  三叉链表

#### 述：
##### 一父二子分，二子左右邻。
##### 问父能知子，问子父亦寻。

![[纪第八-图/纪第八-图九.png|575]]
                                               （图九：三叉链表存储的原理图）

```C++
typedef struct TriTNode    //结点结构
{
	int data;
	struct TriTNode *lchild, *rchild;    //左右孩子指针
	struct TriTNode *parent;    //双亲指针
} TriTNode, *TriTree;
```

###### · 这里的双亲指针指向的是父结点的结点结构：
bt = bt->lchild->parent = bt->rchild->parent
###### · 二叉链表和三叉链表也可以用静态链表表示
###### 三叉链表时间复杂度：访问子结点：O ( 1 ) ；访问父节点：O ( 1 )


### 伍  双亲链表

#### 述：
##### 一表纳一树，前列记名户。
##### 后列看左右，寻中得其父。

![[纪第八-图/纪第八-图十.png]]
（图十：双亲链表表示法下的结点结构和二叉树的表式存储原理）

· 用一个表存储整个树，一行代表一个结点（非按序编号，以检索顺序，从 0 行开始）：
	1. 第一列是结点的名字，或存放的内容
	2. 第二列表示父结点在表中的第几行，即父结点的位置
	3. 第三列表示这个结点是父结点的左子结点还是右子结点，左 L 右 R
	4. 对于根结点，它没有父结点，故第二列置 -1， 第三列为空

```C++
#define MAX_TREE_SIZE 1000

typedef struct BPTNode
{
	int data;
	int parent;    //表示双亲结点在表中的位置
	int LRTag;    //左、右孩子标识域，即存放在 BPTree“表” 中第三列的 L 和 R
} BPTNode;

typedef struct BPTree
{
	BPTNode B[MAX_TREE_SIZE];    //结构数组
	int num_node;    //结点的数目
	int root;    //根结点的位置
} BPTree;
```

###### · 双亲链表时间复杂度：访问子结点：O ( n ) ；访问父结点：O ( 1 )
###### · 双亲链表是一个非指针实现的链表


### 陆  三序遍历

#### 述：
##### 先序中序与后序，左右换位三一体。
##### 每每环迭至树末，点点寻访终全历。

![[纪第八-图/纪第八-图十一.png|600]]
                                                （图十一：三序遍历示例）

##### 先序遍历：

###### 递归实现：
```C++
void Preorder(BiTree T)
{
	if(T!=NULL)
	{
		/*访问根结点的操作(如输出data)*/
		Preorder(T->lchild);
		Preorder(T->rchild);
	}
}
```

###### 非递归实现：
· 用一个栈 S 存储根结点
· 根结点存在则入栈，并访问这个结点，考察结束出栈（D）
· 考察根结点的右子结点，若存在，则入栈，成为待考察根结点
· 再考察根结点的左子结点，若存在，则入栈，成为待考察根结点
· 由于栈是后进先出，故先进栈右子，再进栈左子，保证访问顺序是先左子再右子
· 将栈顶元素作为根结点，访问并出栈（ L -> R ）
· 当栈空时结束循环
```C++
void Preorder(BiTree T)
{
	stack <BiTree> S;
	if(T!=NULL)
	{
		S.push(T);
		while(!S.empty())
		{
			BiTree TP=S.top();
			S.pop();
			/*访问根结点TP(如输出等操作)*/
			if(TP->rchild!=NULL) S.push(TP->rchild);
			if(TP->lchild!=NULL) S.push(TP->lchild);
		}
	}
}
```

##### 中序遍历：

###### 递归实现：
```C++
void Inorder(BiTree T)
{
	if(T!=NULL)
	{
		Inorder(T->lchild);
		/*访问根结点的操作(如输出data)*/
		Inorder(T->rchild);
	}
}
```

###### 非递归实现：
· 用一个栈 S 存储根结点
· 如果第一次遇到这个根结点，入栈，不访问根结点，访问左子树（L）
· 当左子树访问结束，第二次遇到这个根结点，这个根结点出栈，访问这个根结点（D）
· 根结点出栈并访问结束后，访问它的右子树（R）
· 访问右子树时同样遵循上述入栈、出栈的规则，直至链表末端指针为空，并且栈也为空，结束循环
```C++
void Inorder(BiTree T)
{
	stack <BiTree> S;
	while(1)
	{
		while(T!=NULL)
		{
			S.push(T);
			T=T->lchild;
		}
		if(!S.empty())
		{
			T=S.top();
			S.pop();
			/*访问这个根结点T（如输出等操作）*/
			T=T->rchild;
		}
		if(T==NULL&&S.empty()) break;
	}
}
```

##### 后序遍历：

###### 递归实现：
```C++
void Postorder(BiTree T)
{
	if(T!=NULL)
	{
		Postorder(T->lchild);
		Postorder(T->rchile);
		/*访问根结点的操作(如输出data)*/
	}
}
```

###### 非递归实现：
· 用一个栈 S 存储根结点
· 将根结点入栈，考察左子结点，若左子结点存在则亦入栈，直到找不到左子结点为止
· 对栈顶元素考察它的右子结点：
1. 如果栈顶元素存在右子结点，则考察这个右子结点，遍寻其左子结点入栈
   寻找完所有的左子结点，则考察末枝下一个右子结点
   当右子结点不存在时，则这个点要么是没有左邻的右子结点，要么是最左下结点，直接访问，并标记
2. 如果栈顶元素不存在右子结点，同理，这个点就是没有左邻的右子，或最左下点，访问并标记
· 访问标记后，结点出栈，返回上一个结点，即父结点：
1. 如果标记的是左结点，则看上一个结点的右子树，令 T=T->rchild，若空，则直接访问原来的 T
2. 如果标记的是右结点，则直接访问父结点，标记用于判定右子树不存在或已经访问完毕，无需再考察
· 当栈空时，说明所有的结点已经访问结束，栈底的根结点已经弹出，结束循环
```C++
void Postorder(BiTree T)
{
	stack <BiTree> S;
	BiTree pre=NULL;    //记下之前的栈顶
	
	if(T!=NULL)
	{
		while(1)
		{
			while(T!=NULL)
			{
				S.push(T);
				T=T->lchild;
			}    //入栈的每一个结点都是有左子的，除了最后一个（栈顶）
			pre=NULL;
			while(!S.empty())
			{
				T=S.top();
				if(T->rchild==pre)
				{
					/*访问根结点T(如输出等操作)*/
					pre=S.top();
					S.pop();
				}
				else
				{
					T=T->rchild;
					break;
				}
			}
			if(S.empty()) break;
		}
	}
}
```

![[纪第八-图/纪第八-图十二.png]]
（图十二：三序遍历的“右手定则”：走“迷宫”时永远靠向右侧走，最终试探出出口）

##### 统计叶子结点数目：

###### 自下而上的递归：
```C++
int CountLeaf(BiTree T)
{
	if(T==NULL) return 0;
	if(T->lchild==NULL&&T->rchild==NULL) return 1;
	return CountLeaf(T->lchild)+CountLeaf(T->rchild);
}
```

###### 先序遍历的统计：
```C++
int sum=0;    //用于统计叶子结点的数目

void Preorder_Sum()
{
	if(T!=NULL)
	{
		if(T->lchild==NULL&&T->rchild==NULL) sum++;    //访问过程
		Preorder_Sum(T->lchild);
		Preorder_Sum(T->rchild);
	}
}
//每次使用前将 sum 归零，使用后 sum 的值即可作为叶子结点的数目
```
· 中序遍历和后序遍历的统计法同理，访问操作均为：
```C++
if(T->lchlid==NULL&&T->rchild==NULL) sum++;
```

##### 求二叉树的深度：

```C++
int Depth(BiTree T)
{
	if(T==NULL) return 0;
	else
	{
		int DepthLeft=Depth(T->lchild);
		int DepthRight=Depth(T->rchild);
		int DepthCount=(DepthLdft>DepthRight? DepthLeft: DepthRight);
	}
	return DepthCount;
}
```


### 柒  层序遍历

#### 述：
##### 根上末下排，同层从左来。
##### 每点存分子，历历队头开。

![[纪第八-图/纪第八-图十三.png|300]]
                                                    （图十三：二叉树层序遍历）
· 按层次顺序访问二叉树需要利用一个队列
· 在访问二叉树的某一个结点时，把下一层结点指针领先记忆在队列中，利用队列安排逐层访问的顺序

##### 层序遍历二叉树（队列+非递归）：

```C++
void Leverorder(BiTree T)
{
	queue <BiTree> Q;
	Q.push(T);
	while(!Q.empty())
	{
		BiTree P=Q.front();
		/*访问队首结点 P */
		if(P->lchild!=NULL) Q.push(P->lchild);    //如果左子存在，入队列
		if(P->rchild!=NULL) Q.push(P->rchild);    //如果右子存在，入队列
	}
}
```

##### 二叉树遍历的复杂度比较：

![[纪第八-图/纪第八-图十四.png]]
（图十四：各种遍历法的复杂度）
· 由图十三可见，三序遍历法无论是递归实现还是非递归实现，其复杂度相同；各遍历方式的时间复杂度相同


### 捌  字符串表示法

#### 述：
##### 百层分支多杈连，先序逐访一串牵。
##### 每遇对位各落座，无点空路符补全。

###### 字符串表示法：
![[纪第八-图/纪第八-图十五.png|450]]
                                     （图十五：字符串表示二叉树）

###### 二叉树转字符串：

1. 将每一个度不为 2 的结点补成度为 2 的结点：补的位置内容为“ # ”
2. 先序遍历补后的二叉树，逐个访问，遇到“ # ”亦输出
```C++
typedef struct BiTNode
{
	char data;
	struct BiTNode *lchild, *rchild;
} BiTNode, *Bitree;

void Preorder_to_string(BiTree T)
{
	if(T!=NULL)
	{
		printf("%c",T->data);    //不空的位置输出内容-data
		Preorder_to_string(T->lchild);
		Preorder_to_string(T->rchild);
	}
	else printf("#");    //空的位置用“#”补全
}
```

###### 字符串转二叉树：

```C++
char pre[100];    //存放字符串
int i=0;    //标记字符串，逐个字符考察

void CreateBiTree(BiTree &T)    //C++引用传参，将传进来的内容更改
{
	ch=pre[i++];
	if(i==(int)strlen(pre)) return ;
	
	if(ch=='#') T=NULL;    //置空不需要分配内存
	else
	{
		T=(BiTNode *)malloc(sizeof(BiTNode));
		T->data=ch;
		CreateBiTree(T->lchild);
		CreateBiTree(T->rchild);
	}
}

int main()
{
	BiTree head;
	CreateBiTree(head);    //建立二叉树
	
	return 0;
}
```


### 玖  线索表示

#### 述：
##### 各序有遍历，各历排线序。
##### 序左连前驱，序右引后继。

![[纪第八-图/纪第八-图十六.png]]
（图十六：将二叉树遍历的结果排成线性序列）
· 以先序为例，结点 D 的前驱是 C，后继是 E，则用两个指针分别指向 C 和 E
· 以中序为例，结点 D 的前驱是 B，后继是 C，则用两个指针分别指向 B 和 C
· 以后序为例，结点 D 没有前驱，后继是 C，则前驱指针置空，后继指针指向 C
###### · 线索保存的方法有二：前驱后继指针法，前驱后继标识域法

##### 1. 前驱后继指针法：增加前驱 Pred 指针和后继 Succ 指针

![[纪第八-图/纪第八-图十七.png|725]]
                                      （图十七：前驱后继指针法的结点结构）
```C++
typedef struct ThreadNode    //前驱后继指针法的结点结构
{
	char data;
	struct ThreadNode *lchild, *rchild;    //左子和右子指针
	struct ThreadNode *pred, *succ;    //前驱和后继指针
} ThreadNode, *ThreadTree;
```

##### 2. 前驱后继标识域法：左空指针指向前驱，右空指针指向后继

![[纪第八-图/纪第八-图十八.png|725]]
                                      （图十八：前驱后继标识法的结点结构）

```C++
typedef enum{Link, Thread} PointerThr;    //指针标识
// enum 为枚举数据类型，默认 Link=0（指针），Thread=1（线索）

typedef struct ThreadNode    //前驱后继标识法的结点结构
{
	char data;
	struct ThreadNode *lchild, *rchild;
	PointerThr LTag, RTag;
} ThreadNode, *ThreadTree;
//当左结点存在时，LTag=Link，当左结点时空时，LTag=Thread（前驱）
//当右结点存在时，RTag=Link，当右结点时空时，RTag=Thread（后继）
```

##### · 线索链表的三序遍历：

###### 线索链表的先序遍历：
```C++
ThreadTree Succ(ThreadTree T)    //下一个考察的结点
{
	if(T==NULL) return NULL;
	if(T->LTag) return T->rchild;    //如果没有左孩子，则直接取后继或右子
	return T->lchildl;    //若有左孩子，考察左孩子
}

void Preorder(ThreadTree T)
{
	for(ThreadTree P=T; P!=NULL; P=Succ(T))
	{
		/*访问结点 P （如输出等操作）*/
	}
	return ;
}
```

###### 线索链表的中序遍历：
```C++
ThreadTree firstNode(TreadTree T)    //用于寻找最左下的结点
{
	if(T==NULL) return NULL;
	ThreadTree P=T;
	while(P->LTag==Link)    //即左子树存在
	{
		P=P->lchild;
	}
	return P;
}

ThreadTree Succ(ThreadTree T)    //下一个考察的结点
{
	if(T==NULL) return NULL;
	if(T->RTag==Thread) return T->rchild;    //如果没有右孩子，则直接取后继
	return firstNode(T->rchild);    //如果有右子，返回右子树的最左下结点
}

void Inorder(ThreadTree T)
{
	for(ThreadTree P=firstNode(T); P!=NULL; P=Succ(P))
	{
		/*访问结点 P （如输出等操作）*/
	}
	return ;
}
```

###### 线索链表的后序遍历：
※ 后序遍历与先序和中序遍历不同，这里要引入一个双亲结点 struct ThreadNode * parent
```C++
ThreadTree firstNode(ThreadTree T)    //用于寻找最下的叶子结点
{
	if(T==NULL) return NULL;
	ThreadTree P=T;
	while(P->LTag==Link||P->LTag==Link)    //后根遍历，则第一个结点一定没有左右子树
	{
		while(P->LTag==Link)    //深探左子树，寻找最左结点
		{
			P=P->lchild;
		}
		if(P->RTag==Link)    //若右子树存在，则探一步右子树
		{
			P=P->rchlid;
		}
	}
	return P;
}

ThreadTree Succ(ThreadTree T)    //下一个考察的结点
{
	if(T==NULL) return NULL;
	if(T->RTag==Thread) return T->rchild;    //无右子则考察后继
	else    //如果有右子，则考察双亲结点
	{
		if(T->parent==NULL) return NULL;    //如果没有双亲结点，则返回空
		if(T=T->parent->lchild)    //如果自己是双亲的左结点
		{
			if(T->parent->RTag==Link) return firstNode(T->parent->rchild);
			//如果双亲结点有右子，则接下来考察右子的最下点
			return T->parent;    //如果双亲结点没有右子，则考察双亲
		}
		else    //如果自己是双亲的右结点
		{
			return T->parent;    //直接返回双亲结点即可
		}
	}
}

void Postorder(ThreadTree T)
{
	for(ThreadTree P=firstNode(T); P!=NULL; P=Succ(P))
	{
		/*访问结点 P （如输出等操作）*/
	}
	return ;
}
```

##### 线索链表的递归建立：

###### 中序法建立：
1. 对左子树进行线索化
2. 处理当前结点 T：设置结点 pre 和结点 T 的线索；令 pre 指向当前结点 T
3. 对右子树进行线索化
```C++
void InThreading(ThreadTree T, ThreadTree &pre)    //中序法线索化
{
	if(T!=NULL)
	{
		InThreading(T->lchild, pre);    //对左子树线索化
		if(T->lchlid!=NULL) T->LTag=Link;
		else
		{
			T->LTag=Thread;
			T->lchild=pre;    // T 的左子树为前驱
		}
		if(pre!=NULL)
		{
			if(pre->rchild!=NULL) pre->RTag=Link;
			else
			{
				pre->RTag=Thread;
				pre->rchild=T;
			}
		}
		pre=T;    //前驱指向其后继，引导下一个结点
		InThreading(T->rchild, pre);    //对右子树线索化
	}
}

void InorderThreading(ThreadTree T)    //中序法建立线索链表
{
	if(T==NULL) return ;
	ThreadTree pre=NULL;    //初始化 pre 为空
	InThreading(T, pre);    //依次遍历处理所有结点
	pre->RTag=Thread;    //收尾：最后一个结点的右子树为空
	return ;
}
```


### 拾  先序中序建立

#### 述：
##### 一父左右子，单序不尽知。
##### 先中两皆定，全树方可识。

![[纪第八-图/纪第八-图十九.png]]
（图十九：先序序列为 ABCD 的二叉树，有非常多的形态）
###### 注意：对于上图第三、第四种形态，知道先序和后序序列仍然区分不开，所以 “三序知二必有中”

· 用数组 pre【·】存放先序序列字符串，用数组 ino【·】存放中序序列字符串
· ps 表示先序序列第一个字符的位置，is 表示中序序列第一个字符的位置
· 用 n 表示字符串长度，注意 pre【】和 ino【】等长

1. 取出 pre 中第一个字符 A，并在中序序列中查询对应的位置 k（一定可以找到）
2. 建立根结点，递归地建立左右结点
![[纪第八-图/纪第八-图二十.png]]
（图二十：在中序中寻找先序首字符的位置 k ）

##### 递归建立左右结点时，需要分三种情况讨论：

· 注意讨论的都是先序序列的首元素 pre【ps】
###### 1. 如果左右子树均存在：
1. 左子树：
	a. 左子树字符串长度为 k - is（考察中序序列，一个结点前面的字符串一定都是自己的左子树）
	b. 左子树在 pre【·】中从 pre【ps +1 】开始
	c. 左子树在 ino【·】中从 ino【is】开始
2. 右子树：
	a. 右子树字符串长度为 n - ( k - is ) -1（中序序列，总长度减去左子树长度，再减去自身的“ 1 ” ）
	b. 右子树在 pre【·】中的起点：pre【ps + ( k - is ) +1 】（先序中左子树长度 + 左子树起点位置）
	c. 右子树在 ino【·】中的起点：ino【 k +1 】
###### 2. 如果无左子树，只有右子树：则  k = is
· 右子树：
	a. 右子树字符串长度为 n - 1
	b. 右子树在 pre【·】中的起点：pre【ps +1 】
	c. 右子树在 ino【·】中的起点：ino【k +1 】
###### 3. 如果无右子树，只有左子树：则  k = is + n - 1
· 左子树：
	a. 左子树字符串长度为 n - 1
	b. 左子树在 pre【·】中的起点：pre【ps +1 】
	c. 左子树在 ino【·】中的起点：ino【is 】
```C++
int Search(char *ino, char A)
{
	for(int i=0; i<=(int)strlen(ino)-1; i++)
	{
		if(ino[i]==A) return i;
	}
	return -1;    //如果在中序序列中查询不到先序首元素，说明参数错误
}

void CrtBT(BiTree &T, char pre[], char ino[], int ps, int is, int n)
//参数说明：①引用传参，要建立的二叉树T；②先序序列；③中序序列；④先序首元素；⑤中序首元素；⑥考察序列长度
{
	if(n==0) T=NULL;
	else
	{
		int k=Search(ino, pre[ps])    //在中序序列 ino[·] 中查询 pre[ps]
		if(k==-1) T=NULL;    //如果在中序序列中查询不到先序首元素，说明参数错误
		T=(BiTNode*)malloc(sizeof(BiTNode));
		T->data=pre[ps];
		if(k==is) T->lchild=NULL;    //说明没有左子树
		else CrtBT(T->lchild, pre[], ino[], ps+1, is, k-is);
		//建立左子树：①左子树；②先序序列；③中序序列；④先序左子首元；⑤中序左子首元；⑥左子树序列长度
		if(k==is+n-1) T->rchild=NULL;    //说明没有右子树
		else CrtBT(T->rchild, pre[], ino[], ps+(k-is)+1, k+1, n-(k-is)-1);
		//建立左子树：①右子树；②先序序列；③中序序列；④先序左子首元；⑤中序左子首元；⑥右子树序列长度
	}
}
```

#### 其他唯一确定二叉树的方法：

##### 中序后序建立二叉树：

1. 中序字符串 ino【·】，后序字符串 pos【·】，中序首元素位置 is，后序尾元素位置 rs，两串长度均为 n
2. 取后序尾元 pos【rs】，在 ino【·】中查询位置 k，建立根结点，递归建立左右结点
3. 仍旧分三种情况讨论：

###### 1. 如果左右子树均存在：
1. 左子树：
	a. 左子树字符串长度为 k - is（考察中序序列，一个结点前面的字符串一定都是自己的左子树）
	b. 左子树在 ino【·】中从 ino【is 】开始
	c. 左子树在 pos【·】中从 pos【rs - n + ( k - is ) 】开始（尾元素位置减去右子树长度，再减一）
2. 右子树：
	a. 右子树字符串长度为 n - ( k - is ) -1（中序序列，总长度减去左子树长度，再减去自身的“ 1 ” ）
	b. 右子树在 ino【·】中从 ino【k +1 】开始
	c. 右子树在 pos【·】中从 pos【rs -1 】开始

###### 2. 如果无左子树，只有右子树：则  k = is
· 右子树：
	a. 右子树字符串长度为 n - 1
	b. 右子树在 ino【·】中从 ino【k +1 】开始
	c. 右子树在 pos【·】中从 pos【rs -1 】开始

###### 3. 如果无右子树，只有左子树，则  k = is + n - 1
· 左子树：
	a. 左子树字符串长度为 n - 1
	b. 左子树在 ino【·】中从 ino【is】开始
	c. 左子树在 pos【·】中从 pos【rs - n 】开始
```C++
int Search(char *ino, char A)
{
	for(int i=0; i<=(int)strlen(ino)-1; i++)
	{
		if(ino[i]==A) return i;
	}
	return -1;    //如果在中序序列中查询不到先序首元素，说明参数错误
}

void CrtBT(BiTree &T, char pos[], char ino[], int rs, int is, int n)
//参数说明：①引用传参，要建立的二叉树T；②后序序列；③中序序列；④后序尾元素；⑤中序首元素；⑥考察序列长度
{
	if(n==0) T=NULL;
	else
	{
		int k=Search(ino, pos[rs])    //在中序序列 ino[·] 中查询 pos[rs]
		if(k==-1) T=NULL;    //如果在中序序列中查询不到后序尾元素，说明参数错误
		T=(BiTNode*)malloc(sizeof(BiTNode));
		T->data=pos[rs];
		if(k==is) T->lchild=NULL;    //说明没有左子树
		else CrtBT(T->lchild, pos[], ino[], rs-n+k-is, is, k-is);
		//建立左子树：①左子树；②后序序列；③中序序列；④后序左子尾元；⑤中序左子首元；⑥左子树序列长度
		if(k==is+n-1) T->rchild=NULL;    //说明没有右子树
		else CrtBT(T->rchild, pos[], ino[], rs-1, k+1, n-(k-is)-1);
		//建立右子树：①右子树；②尾序序列；③中序序列；④后序左子尾元；⑤中序左子首元；⑥右子树序列长度
	}
}
```

##### 中序层序建立二叉树：

1. 层序字符串 lev【·】，中序字符串 ino【·】，序长为 n
2. 取层序首元 lev【ls】，在 ino【·】中查询位置 k，建立根结点
3. 在中序中与根结点比较左右，选择挂在根结点的哪边，以此向下比较，直到空位置挂上

```C++
typedef struct BiTNode
{
	char data;
	struct BiTNode *lchild, *rchild;
	int place_of_inorder=-1;    //在中序序列中的位置
}

int Search(char *ino, char A)
{
	for(int i=0; i<=(int)strlen(ino)-1; i++)
	{
		if(ino[i]==A) return i;
	}
	return -1;    //如果在中序序列中查询不到先序首元素，说明参数错误
}

void Insert_BT(BiTree T, int k)    //给定位置 k，在树中进行插入
{
	BiTree P=(BiTNode*)malloc(sizeof(BiTNode));
	P->data=ino[k];
	P->lchild=NULL, P->rchild=NULL；
	
	BiTree Copy_T=T;

	while(Copy_T!=NULL)
	{
		if(Copy_T.place_of_inorder==-1)
		{
			Copy_T.place_of_inorder=Search(ino[], Copy_T.data);
		}
		if(k<Copy_T.place_of_inorder)
		{
			if(Copy_T->lchild!=NULL) Copy_T=Copy_T->lchild;
			else
			{
				P=Copy_T->lchild;
				return ;
			}
		}
		else
		{
			if(Copy_T->rchild!=NULL) Copy_T=Copy_T->rchild;
			else
			{
				P=Copy_T->rchild;
				return ;
			}
		}
	}
}

void CrtBT(BiTree &T)
{
	for(int i=0; i<n; i++)
	{
		Insert(T, lev[i]);
	}
	return ;
}
```
### 拾壹  排序二叉树

#### 述：
##### 一树撑秤杆，轻左重右边。
##### 每权逐层较，相比至末端

· 确定根结点后，将所给数值选取其一与根结点进行比较：
	· 如果比根结点大则挂在右子树
	· 如果比根结点小则挂在左子树
· 如果根结点已有两棵子树，则下一个数值根据和根结点相比的大小确定左右，与根的左或右孩子比较
· 以此类推，直到寻找到目前度不为二的结点，与之比较，有合适位置就放置，位置满就和相应位置子树比较

###### 排序二叉树的特点：每一个“根+左+右”的三结点组合都是：左<根<右
1. 若它的左子树不空，则左子树上所有结点的值均小于其根结点的值  
2. 若它的右子树不空，则右子树上所有结点的值均大于其根结点的值
![[纪第八-图/纪第八-图二十一.png|450]]
                                           （图二十一：排序二叉树的排序效果）
##### 排序二叉树的建立：
```C++
int a[100];    //存储数据
int n;    //数据的个数

void Insert_SBT(BiTree &T, int x)    //排序二叉树的结点插入
{
	BiTree P=(BiTNode*)malloc(sizeof(BiTNode));
	P->data=x;
	P->lchild=NULL, P->rchild=NULL;    //建立结点

	BiTree Copy_T=T;    // T 的“替身”

	while(Copy_T!=NULL)
	{
		if(x<Copy_T->data)
		{
			if(Copy_T->lchild!=NULL)
			{
				Copy_T=Copy_T->lchild;
			}
			else
			{
				Copy_T->lchild=P;
				return ;
			}
		}
		else
		{
			if(Copy_T->rchild!=NULL)
			{
				Copy_T=Copy_T->rchild;
			}
			else
			{
				Copy_T->rchild=P;
				return ;
			}
		}
	}
}

void CrtSortBT(BiTree T, int a[])    //排序二叉树的建立
{
	for(int i=0; i<n; i++)
	{
		Insert_SBT(T, a[i]);
	}
}
```

##### 排序二叉树的性质：

###### 性质 1：向最左端寻找可以找到最小值：
```C++
BiTree Search_min(BiTree T)
{
	if(T==NULL) return NULL;
	if(T->lchild==NULL) return T->lchild;
	else return Search_min(T->lchild);
}
```
###### 性质 2：向最右端寻找可以找到最大值：
```C++
BiTree Search_max(BiTree T)
{
	if(T==NULL) return NULL;
	if(T->rchild==NULL) return T->rchild;
	else return Search_max(T->rchild);
}
```
###### 查找单个元素：
· 递归法：
```C++
BiTree Search_node(BiTree T, int key)    //从 T 中查找 key 这个结点
{
	if(T==NULL) return NULL;
	if(key>T->data) return Search_node(T->rchild, key);
	if(key<T->data) return Search_node(T->lchlid, key);
	return T;
}
```
· 非递归法：
```C++
BiTree Search_node(BiTree T, int key)
{
	BiTree P;
	while(P!=NULL)
	{
		if(P->data==key) return P;
		P=(P->data>key? P->lchild: P->rchild);
	}
	return NULL;
}
```
· 先序遍历法：
```C++
BiTree Search_node(BiTree T, int key)
{
	if(T!=NULL)
	{
		if(T->data==key) return T;
		Search_node(T->lchild, key);
		Search_node(T->rchild, key);
	}
	else reutrn NULL;
}
```
###### 性质 3：中序遍历的输出结果就是从小到大排好序的：
```C++
int n=0;
int order[100];

void SortBT(BiTree T)
{
	if(T!=NULL)
	{
		SortBT(T->lchild);
		order[n++]=T->data;
		SortBT(T->rchild);
	}
}

//效果：在 order[·] 这个数组中，所有的数字从小到大排序
```
· 反中序遍历就是从大到小排序：
```C++
int n=0;
int order[100];

void SortBT(BiTree T)
{
	if(T!=NULL)
	{
		SortBT(T->rchild);
		order[n++]=T->data;
		SortBT(T->lchild);
	}
}

//效果：在 order[·] 这个数组中，所有的数字从大到小排序
```
