### 叁  深度优先搜索

#### 述：
##### 岔路回旋多迷惘，始发至终途漫长。
##### 过路总把刻记画，无标逐试得全相。

#### 1. 连通图的遍历
###### · 深度优先遍历连通图的过程类似于树的先根遍历：
· 从图中某个顶点 v 出发，访问此顶点，然后依次从 v 的各个未被访问的邻接点出发深度优先搜索遍历图，直至图中所有和 v 有路径相通的顶点都被访问到
![[纪第十-图/纪第十-图一.png]]
（图一：连通图的深度优先遍历和树的先根遍历很相似）
![[纪第十-图/纪第十-图二.png|450]]
                              （图二：连通图深搜的递归）
###### · 访问顶点 v：
for ( w1, w2, w3)：若该临界点 wi 未被访问，则从它出发进行深度优先搜索遍历
###### · 代码实现：
```C++
void DFS(Graph G, int v, int visit[])
//三个参数：连通图 G，起始顶点 v，访问标记数组 visit[·]
{
	visit[v]=1;
	/*对顶点 v 进行访问操作，如输出等*/
	int w=firstNeighbor(G,v);    //寻找 v 的相邻顶点
	while(w!=-1)
	{
		if(visit[w]==0)    //如果顶点 w 没有被访问过
		{
			DFS(G,w,visit);
			w=nextNeighbor(G,v,w);
		}
	}
}
```
![[纪第十-图/纪第十-图三.png]]
（图三：以 v1 为顶点，深度优先搜索图连通图 G ）

#### 2. 非连通图的遍历

###### · 算法思路：
1. 将图中每个顶点的访问标志设为 0
2. 搜索图中每个顶点，如果未被访问，则以该顶点为起始点，进行深度优先搜索遍历
3. 否则继续检查下一顶点
![[纪第十-图/纪第十-图四.png]]
（图四：连通图和非连通图）
###### · 代码实现：
```C++
void DFS_2(Graph G, int visit[])
{
	for(int v=0; v<G.numVertices; v++)
	{
		if(!visit[v]) DFS(G, v, visit);
		//非连通图可以看作整体由若干个连通图组成，故可直接调用 DFS(·) 函数
	}
	return ;
}
```

![[纪第十-图/纪第十-图五.png|300]]
                                （图五：非连通图 dfs 举例）
###### · 上述举例访问次序：0 - 2 - 6 - 3 - 5 - 7 - 4 - 1 - 8
![[纪第十-图/纪第十-图六.png|425]]
                           （图六：连通图的深搜遍历可以生成树）
   ![[纪第十-图/纪第十-图七.png|425]]
                             （图七：连通图的 dfs 生成树举例）

###### · 图的深度优先搜索遍历时间复杂度与图的形态关系很大，一般度越少的连通图 dfs 时间越短


### 肆  广度优先搜索

#### 述：
##### 三星绕一月，点点平铺列。
##### 逐层寻至末，每星各扩界。

###### · 图的广度优先搜索类似树的广度优先遍历，从某一顶点 v 出发：
1. 访问顶点 v
2. 访问 v 所有未被访问的邻接点 w1, w2, …, wk
3. 依次从这些邻接点出发，访问其所有未被访问的邻接点
依此类推，直到图中所有访问过的顶点的邻接点都被访问
###### · 关键：借助队列暂存结点

###### 代码实现：
```C++
void BFS(Graph G, int v, int visit[])
{
	queue <int> Q;
	visit[v]=1;
	/*访问顶点 v */
	Q.push(v);    //访问 v 后将 v 入队
	while(!Q.empty())
	{
		int u=Q.front();
		Q.pop();
		w=firstNeighbor(G,u);
		while(w!=-1)
		{
			if(visit[w]==0)
			{
				visit[w]=1;
				/*访问顶点 w */
				Q.push(w);
			}
			w=nextNeighbor(G,u,w);
		}
	}
	return;
}
```
![[纪第十-图/纪第十-图八.png|450]]
                         （图八：图的广度优先搜索中队列的使用）
###### · 非连通图的 BFS（·）函数调用：
```C++
void BFS_2(Graph G)
{
	for(int u=0, u<G.numVertices; v++)
	{
		if(visit[u]==0) BFS(G,v,visit);
	}
	return ;
}
```

###### · 广度优先搜索常用于寻找连通图上两点之间最短路径


### 叁  