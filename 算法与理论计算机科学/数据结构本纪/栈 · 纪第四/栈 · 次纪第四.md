### 壹  数制转换

#### 问：
##### 一数本十进，现欲八进转。
##### 何能得一法，动栈可实现？

· 例：给定十进制数字 1348，如何通过栈转换为八进制数？

###### 思路分析：
1. 算法基于原理：N = ( N div d ) × d + N mod d
2. 图示：
![[次纪第四-图/次纪第四-图一.png|500]]
                                （图一：进制转换的原理）
3. 循环实现：N mod d 压栈，N = N / d（用栈实现先计算后输出）
###### 算法过程：
1. 初始化栈
2. 依次计算当前的 d 进制数，并将其压栈
3. 依次从栈中取出计算结果并输出
4. 删除栈
###### 代码实现：
```C++
void conversion(int N, int d)    // N 为将要被转换的十进制数，d 是目标进制
{
	stack <int> S;    // 1.初始化栈
	while(N!=0)    // 2.依次计算当前的 d 进制数，并将其压栈
	{
		S.push(N%d);
		N=N/d;
	}
	while(!S.empty())    // 3.依次从栈中取出计算结果并输出
	{
		printf("%d",S.top());
		S.pop();
	}
	printf("\n");
	//    可在此处加入第四步：销毁栈
	return ;
}
```

##### 总结：
· 用栈的 LIFO 特点先算低位，后算高位，输出时由高位到低位顺序输出


### 贰  括号匹配

#### 问：
##### 始出长列乱排号，括符重重难以消。
##### 欲得一法可立断，对对相去能尽否。

· 例 1 ：给定括号序列：（【】（）），则这是可以“匹配成功”的序列
· 例 2：给定括号序列：（【】（），则这是不可以“抵消尽”的序列
· 检验括号是否匹配正确，按照最近匹配原则

###### 算法思想：
1. 凡出现左括号，则进栈；
2. 凡出现右括号，首先检查栈是否为空：
	1. 若栈空，则这个右括号一定“多余”
	2. 若栈不空，则看栈顶元素：
		1. 若和栈顶元素相匹配，则左括号出栈
		2. 若和栈顶元素不匹配，则“判错”
###### 代码实现：
```C++
char C[100];    //用于存放括号字符串
int L;    //括号字符串的长度为 L

void Judge()
{
	stack <char> S;
	for(int i=0; i<L; i++)
	{
		if(C[i]=='('||C[i]=='[') S.push(C[i]);
		else
		{
			if(S.empty())
			{
				printf("无法匹配完全\n");
				return;
			}
			else
			{
				if((C[i]==')'&&S.top()=='(')||(C[i]==']'&&C[i]=='[')) S.push(C[i]);
				else
				{
					printf("无法匹配完全\n");
					return;
				}
			}
		}
	}
	printf("可以匹配完全\n");
	return;
}
```

##### 总结：
· 利用栈的后进先出性实现相邻括号的抵消，只要“来”的是右括号，那么如果匹配则继续，若不匹配直接“判错”


### 叁  日温升落

#### 述：
##### 每日温高变，涨落皆随天。
##### 尽盼春风回，何日气更暖？

· 给定连续几天的气温（整数），如：13，14，20，16，12，18，13（给定一个数组 temperature【】）
· 要求每一天都输出一个对应的值，表示几日后气温比今日高
· 比如上述例子的输出应为：1，1，0，2，1，0，0

###### 思路分析：
· 用一个单调递减栈存储<font color="#ffc000">天数代号</font>（从零开始）：
1. 如果下一个气温比栈顶高，则栈顶出栈，直到栈顶更大，新的气温对应天数代号进栈
2. 如果下一个气温比栈顶低或相同，新的气温对应天数代号直接进栈
· 每有新气温“来”时，天数代号差反映对应日后回暖天数

###### 代码实现：
```C++
// temperature 数组已经给定，假设里面有 n 个数据，从 temperature[0] 开始存储

void How_many_days(int temperature[])
{
	stack <int> S;
	int days[n];
	for(int i=0; i<n; i++)
	{
		if(S.empty()) S.push(temperature[i]);
		else
		{
			int a=S.top();
			while(!S.empty()&&temperature[a]<temperature[i])
			{
				days[a]=i-a;
				S.pop();
				if(!S.empty()) a=S.top();
			}
			S.push(i);
		}
	}
	while(!S.empty())
	{
		int a=S.top();
		days[a]=0;
		S.pop();
	}
	for(int i=0; i<n; i++) printf("%d ",days[i]);    // 输出每日对应日后回暖天数
	return;
}
```

##### 总结：
###### · 单调栈：永远保持栈的单调性，如果出现不单调元素，则一直出栈，直到该元素符合规定的单调性
###### · 在这个例子中，单调的原则是栈 S 中存储的值映射到 temperature 数组后一直保持单调递减

