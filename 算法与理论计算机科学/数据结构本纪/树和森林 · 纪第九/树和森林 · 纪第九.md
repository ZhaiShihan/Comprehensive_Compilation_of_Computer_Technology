### 壹  定义性质

#### 述：
##### 单枝难为树，独木不成林。
##### 未见昔创苦，只羡繁荣今。

#### 树：
##### · 有关树的基本概念：
###### 1. 结点：数据元素+若干指向子树的分支
###### 2. 结点的度：分支的个数
###### 3. 树的度：树中所有结点的度的最大值
###### 4. 叶子结点：度为 0 的结点
###### 5. 分支结点：度大于 0 的结点
###### 6. 路径：由从根到该结点所经分支和结点构成
###### 7. 结点的层次：假设根结点层次是 1，第 i 层结点的子树根结点的层次为 i +1
###### 8. 结点的高度：从下向上逐层计算，叶结点高度为 1， 其他结点的高度是取它的所有子女结点最大高度加 1
###### 9. 树的深度：树中叶子结点所在的最大层次
###### 10. 树的高度：根结点的高度，与树的深度相等
##### · 树的类型定义：
###### 1. 森林：m（m >= 0）棵互不相交的树的集合
###### 2. 树的定义：任何一棵非空树都是一个二元组：
######             Tree ( root, F )
###### · root 被称为根结点，F被称为子树森林
![[纪第九-图/纪第九-图一.png|600]]
                                            （图一：树的二元组表示法下的示例）
###### 3. 有序树：子树之间存在确定的次序关系
###### 4. 无序树：子树之间不存在确定的次序关系
![[纪第九-图/纪第九-图二.png|350]]
                                                （图二：有序树举例：排序二叉树）
![[纪第九-图/纪第九-图三.png|700]]
                                   （图三：对比树型结构和线性结构的结构特点）
##### 分支方程：
###### · 如果一棵树的结点数为 N，记 N<sub>K</sub> 代表度为 K 的结点数目，树的总分支数为 B，树的度为 D，则：
1. N = N<sub>0</sub> + N<sub>1</sub> + N<sub>2</sub> + …… + N<sub>D</sub>
2. N = B + 1
3. B = 1 × N<sub>1</sub> + 2 × N<sub>2</sub> + 3 × N<sub>3</sub> + …… + D × N<sub>D</sub>
###### · 故可以得出结论：
*∑<sub>i</sub><sup>D</sup> N<sub>i-1</sub> = 0*


### 贰  双亲表示

#### 述：
##### 一点多分层层布，前在顶冠后随之。
##### 莫道族尽无得子，奈何子在父不识。

![[纪第九-图/纪第九-图四.png|350]]
                                             （图四：树的双亲表示法的示例）
###### · 树的建立与二叉树双亲链表表示法相似：
```C++
#define MAX_TREE_SIZE 1000

typedef struct PTNode    //结点结构
{
	char data;
	int parent;    //双亲位置域
} PTNode;

typedef struct
{
	PTNode N[MAX_TREE_SIZE];
	int r, k;    //根结点的位置和结点的总个数
} PTree;
```


### 叁  子女链表

#### 述：
##### 一岔多向走，节节集表构。
##### 有子一牵一，无子空床留。

![[纪第九-图/纪第九-图五.png|550]]
                                                 （图五：子女链表存储法示例）
###### · 对于一个孩子结点，child 表示自己在数组的位置，next 是指向兄弟的指针
###### · 对于双亲结点，用 data 表示内容，firstchild 是从指向左数第一个孩子的指针
###### · 对于整个树结构，用一个数组 N 表示各个结点的线性排列，r 表示根结点位置，k 表示结点总数目

```C++
#define MAX_TREE_SIZE 1000

typedef struct CTNode
{
	int child;    //这个孩子结点自己的位置
	struct CTNode *next;    //右边紧邻的兄弟
} *ChildPtr;

typedef struct
{
	char data;
	ChildPtr fitstchild;    //孩子链的头指针
} CTBox;

typedef struct
{
	CTBox N[MAX_TREE_SIZE];    //各个结点的线性排列
	int r, k;    //根结点位置和总结点个数
} CTree;
```


### 肆  广义表法

#### 述：
##### 一链头尾层套层，诸子均在父括中。
##### 同辈等层并排列，为求先序扫西东。

![[纪第九-图/纪第九-图六.png|650]]
                                            （图六：树的广义表表示法示例）
##### · 树和广义表一一对应：
###### 1. 子表的头结点是子树的根，其后链接它所有子女
###### 2. 如果子女是叶结点（单元素或原子），结点中直接赋值，否则结点中是子表的头指针

```C++
typedef struct TreeNode
{
	char data;
	struct TreeNode *head, *rear;
} TreeNode;
```


### 伍  二叉链表

#### 述：
##### 一父多子分，各自不相认。
##### 问父知长子，子晓大弟存。

![[纪第九-图/纪第九-图七.png|500]]
                                               （图七：二叉链表表示树的示例）
###### · 二叉链表表示法，即孩子-兄弟表示法，又可称“左子右邻”表示法

```C++
typedef struct CSNode
{
	char data;
	struct CSNode *firstchild, *nextsibling;
} CSNode, *CSTree;
```

##### · 树与二叉树的转换：
![[纪第九-图/纪第九-图八.png]]
（图八-树与二叉树相互转换的方法）
![[纪第九-图/纪第九-图九.png]]
（图九-树通过二叉链表表示法转换为二叉树）
###### · 由于树的结点 A 没有右邻，故转换为二叉树后 A 没有右子

##### · 森林与二叉树的转换：
###### 森林是树的集合，将森林中树的根看成兄弟，用树与二叉树的转换方法将森林与二叉树转换：
![[纪第九-图/纪第九-图十.png]]
（图十：森林转换成二叉树的图示）
<font color="#00b050">· “右斜”的枝条上，所有的结点都是原来森林中各棵树的根结点</font>


### 陆  树的遍历

#### 述：
##### 一岔多路遍寻找，逐点排查何法巧？
##### 右手为上兜兜转，左身数来层层扫。

###### <font color="#ffc000">1. 树的先根次序遍历的递归算法：</font>
```C++
typedef struct TreeNode
{
	struct TreeNode *lchild, *rsibling;
	char data;
} TreeNode, *Tree;

void Preorder(Tree T)
{
	if(T!=NULL)
	{
		/*访问根结点 T */
		Tree P=T->lchild;
		while(P!=NULL)
		{
			Preorder(P);
			P=P->rsibling;
		}
	}
}
```

![[纪第九-图/纪第九-图十一.png|475]]
                                           （图十一：树与二叉树遍历顺序的对应）

###### <font color="#ffc000">2. 树的后序遍历的递归算法：</font>
```C++
typedef struct TreeNode
{
	struct TreeNode *lchild, *rsibling;
	char data;
} TreeNode, *Tree;

void Postorder(Tree T)
{
	if(T!=NULL)
	{
		Tree P=T->lchild;
		while(P!=NULL)
		{
			Preorder(P);
			P=P->rsibling;
		}
		/*访问根结点 T */
	}
}
```

###### <font color="#ffc000">3. 树的广度优先遍历：</font>

**· 树的广度优先遍历不是递归过程
· 类似二叉树的层次遍历
· 借助队列实现遍历过程

```C++
void LevelOrder(Tree T)
{
	Queue <Tree> Q;
	if(T!=NULL)
	{
		Q.push(T);
		while(!Q.empty())
		{
			/*访问队头结点*/
			Q.pop();
			Tree P=T->lchild;
			while(P!=NULL)
			{
				Q.push(P);
				P=P->rsibling;
			}
		}
	}
}
```


### 柒  森林遍历

#### 述：
##### 多岔散路遍寻找，逐点排查无所巧。
##### 合林为树深兜转，分树为层广横扫。

##### <font color="#c3d69b">· 森林由三部分组成：</font>
###### <font color="#92cddc">1. 第一棵树的根结点</font>
###### <font color="#92cddc">2. 第一棵树的子树森林</font>
###### <font color="#92cddc">3. 其他（除第一棵树外的）树构成的森林</font>

#### 森林的遍历：

###### <font color="#ffc000">1. 森林的先根次序遍历：</font>

1. 若森林不空，则访问森林中第一棵树的根结点；
2. 先序遍历森林中第一棵树的子树森林
3. 先序遍历森林中其余树构成的森林
<font color="#f79646">【依次对森林中每一棵树进行先序遍历】</font>

###### <font color="#ffc000">2. 森林的中序次序遍历：</font>

1. 中序遍历森林中第一棵树的子树森林
2. 访问森林中第一棵树的根结点
3. 中序遍历森林中其余树构成的森林
<font color="#f79646">【依次对森林中每一棵树进行后序遍历】</font>

![[纪第九-图/纪第九-图十二.png]]
（图十二：树的遍历方式与二叉树、森林遍历方式的对应）

###### <font color="#ffc000">2. 森林的广度遍历：</font>

###### 棵棵有根统对齐，层层无差扫次序。
###### 每位子点队尾存，先来后到尽遍历。

· 与树的广度遍历方法类似：层层“扫”法，同层的为一个遍历组，共同位于第一层的是森林中所有树的根结点

![[纪第九-图/纪第九-图十三.png|600]]
                                          （图十三：森林的按层次广度遍历示意）


### 捌  最优树的概念

#### 述：
##### 节节顺挂权不同，条条布路沿至终。
##### 何以平衡全树径，各积作和最少重。

###### · 树的带权长度路径为树中所有叶子结点的带权路径长度之和，树 T 的带权长度路径记作 WPL ( T )
###### WPL ( T ) = ∑ w<sub>k</sub> l<sub>k</sub> （对所有叶子结点）

![[纪第九-图/纪第九-图十四.png]]
（图十四：两种不同构造的树的 WPS 值的计算）

###### · 最优树：在所在的 n 个叶子结点、并且带相同权值的 m 叉树中，必存在带权路径长度取最小值的树
###### · 哈夫曼树：假设有 n 个权值，构造 n 个结点的二叉树，每个叶子结点有一个权值，带权路径长度最小的二叉树称为哈夫曼树
###### · 引理：哈夫曼树一定是正则的二叉树（没有度为 1 的结点）


### 玖  哈夫曼树

#### 述：
##### 点点相列重不同，排排之中取两轻。
##### 两轻合数再比较，尽挂树间独子空。

##### <font color="#92d050">哈夫曼算法-----贪心算法:</font>
###### 1. 根据给定的权值 {w1, w2, ……, wn}，构造 n 棵二叉树的集合：
· F = {w1, w2, ……, wn}，其中每棵二叉树中只有一个带权值的结点，其左、右子树都是空树
###### 2. 在 F 中选取其根结点的权值为最小的两棵二叉树：
· 分别作为左、右子树构造一棵新的二叉树
· 置这棵新的二叉树根结点的权值为其左、右子树根结点的权值之和
###### 3. 从 F 中删去这两棵树，同时加入刚生成的新树
###### 4. 重复步骤 2 和步骤 3，直至 F 中只含一棵树为止

例：已知权值为：5，6，2，9，7
![[纪第九-图/纪第九-图十五.png|500]]
                                            （图十五：构造哈夫曼树过程举例）
· 图十五为构造的前三步
· 之后再次选择最小的 9 和 7 构成 16
· 再之后，16 和 13 构成 29
![[纪第九-图/纪第九-图十六.png|400]]
                                                （图十六：哈夫曼树构造结果）
##### 哈夫曼树的存储：
![[纪第九-图/纪第九-图十七.png]]
（图十七：哈夫曼树的静态三叉链表存储表示）

```C++
typedef struct    //静态三叉链表结点类型定义
{
	char data;
	int weight;
	int parent, lchild, rchild;
} HTNode, *HuffmanTree;
```

###### 哈夫曼树的结点性质：
· 如果有 n<sub>0</sub> 个叶结点，则整个哈夫曼树的结点个数为 2×n<sub>0</sub> -1

###### 哈夫曼树的域式存储
![[纪第九-图/纪第九-图十八.png|600]]
                                              （图十八：哈夫曼树的域式存储）

###### 构造哈夫曼树的代码实现：

```C++
typedef struct    //静态三叉链表结点类型定义
{
	char data;
	int weight;
	int parent, lchild, rchild;
} HTNode, *HuffmanTree;

void Select(HuffmanTree T, int k; int &s1, int &s2)
//  从 T[1~k] 中选择 parent 为 -1 且权值最小的两个结点，序号分别为 s1 和 s2
{
	int min1=99999, min2=99999;
	for(int i=0; i<=k; i++)
	{
		if(T[i].parent==-1)
		{
			if(T[i].weight<min1)
			{
				s1=i;
				min1=T[i].weight;
			}
		}
	}
	T[s1].weight=99999;
	for(int i=0; i<=k; i++)
	{
		if(T[i].parent==-1)
		{
			if(T[i].weight<min2)
			{
				s2=i;
				min2=T[i].weight;
			}
		}
	}
	T[s1].weight=min1;
}

void CrtHuffmanTree(HuffmanTree &T, int *w, int n)    //构建哈夫曼树
{
	T=(HuffmanTree)malloc((2*n-1)*sizeof(HTNode));    //分配一个有 2*n-1 个结点大小的空间
	for(HuffmanTree P=T, int *q=w, int i=0; i<=n-1; i++,P++,q++)
	{
		*P ={*q, -1, -1, -1};
	}

	for(int i=n; i<2*n-1; i++,P++)
	{
		int s1, s2;
		Select(T, i-1, s1, s2);
		T[s1].parent=i, T[s2].parent=i;
		T[i].lchild=s1, T[i].rchild=s2;
		T[i].weight=T[s1].weight+T[s2].weight;    //根结点的权重为两个子结点的权重加和
	}
}
```

· 注：Select 函数的其他构造方法：
```C++
typedef struct    //静态三叉链表结点基础上，记录每个结点自己的wei'z
{
	char data;
	int place;
	int weight;
	int parent, lchild, rchild;
} HTNode, *HuffmanTree;

int compare(const void* e1, const void* e2)  //qsort的比较函数（小到大）
{
	HTNode a=*(HTNode*)e1;
	HTNode b=*(HTNode*)e2;
	return a.weight-b.weight;
}

void Select(HuffmanTree T, int k, int &s1, int &s2)
{
	qsort(T, k+1, sizeof(T[0]), compare);
	s1=T[0].place;
	s2=T[1].place;
}
```

##### 哈夫曼编码：
###### · 前缀编码：任何一个字符的编码都不是同一字符集 中另一个字符的编码的前缀
![[纪第九-图/纪第九-图十九.png|600]]
                                                （图十九：前缀编码举例）
###### · 利用哈夫曼树：
	· 可以构造一种不等长的二进制编码
	· 并且构造所得的哈夫曼编码是一种最优前缀编码
	· 最优即所传电文的总长度最短
###### · 哈夫曼树的构造：
	· 将每个字符视为一个树结点，根据它们的频率构建一棵哈夫曼树
	· 构建过程中，选择两个频率最低的结点合并成一个新结点，其频率为两者之和
	· 重复这个过程，直到只剩下一个结点，即哈夫曼树的根结点

· 哈夫曼编码的赋值规则：
	1. 在哈夫曼树中，从根结点到每个叶子结点的路径上的左分支表示编码位 0，右分支表示编码位 1
	2. 叶子节点的编码，即为从根结点到达该叶子结点的路径上，所经过的所有编码位
	3. 由于构建哈夫曼树的方式，频率较高的字符对应的编码较短，频率较低的字符对应的编码较长
![[纪第九-图/纪第九-图二十.png|600]]
                                              （图二十：哈夫曼树编码示例）
<font color="#f79646">· 字母对应编码：</font>
a：000    b：001    c：010    d：011    e：100    f：101    g：110    h：111

<font color="#f79646">· 对于这个例子：</font>
	· 如果原编码为：001 000 011 001 000 110 001 000 010 111    【30 bit 】
	· Huffman 编码的结果为：10 00 1111 10 00 0111 10 00 1110 010    【23 bit 】


### 拾  堆的定义

#### 述：
##### 一根有二子，左子右子邻。
##### 名堆看其顶，小顶大顶分。

###### 对于完全二叉树：如果根结点从 0 开始编号，则结点 i 与其父结点和子结点的对应关系是：
![[纪第九-图/纪第九-图二十一.png]]
（图二十一：根结点为 0 的满编号完全二叉树，结点 i 与其父结点子结点的对应编号关系）
###### · 小根堆的特点：每一结点的值都大于父结点，小于子结点：Ki < K2i+1，Ki < K2i+2
###### · 大根堆的特点：每一结点的值都小于父结点，大于子结点：Ki > K2i+1，Ki > K2i+2
###### <font color="#00b0f0">堆的定义：</font>
```C++
#define heapSize 100    //堆的最大元素个数
typedef struct    //堆结构的定义
{
	int elem[heapSize];    //堆存储数组
	int curSize;    //当前元素个数
} minHeap;    //小根堆
```
###### <font color="#00b0f0">堆的操作：</font>
1. 小根堆的向下筛选算法：
	· 对于堆的调整，需要进行多次从上向下的交换，称为筛选（有些类似于冒泡）
```C++
void siftDown(minHeap &H, int i, int m)
{
	//从结点i开始到m为止, 自上向下比较, 将一个集合局部调整为小根堆
	int temp=H.elem[i];
	for(int j=2*i+1; j<=m; j=2*j+1)    //每次寻找这个结点的子结点
	{
		if(j<m && H.elem[j]>H.elem[j+1]) j++;    //左右比较
		if(temp<=H.elem[j]) break;    //小则不做调整
		else    //小者上移
		{
			H.elem[i]=H.elem[j];
			i=j;
		}
	}
	H.elem[i]=temp;    //放回 temp 中暂存的元素
}
```
2. 小根堆的建立：
```C++
void CreateMinHeap(minHeap &H, int arr[], int n)
{
	//将一个数组从局部到整体，自下向上调整为小根堆
	for(int i=0; i<n; i++) H.elem[i]=arr[i];  //复制
	H.curSize=n;    //当前元素个数是 n
	for(int i=(H.curSize-2)/2; i>=0; i--)    //自底向上逐步扩大小根堆
	{
		siftDown(H, i, H.curSize-1);    //从 i 到 H.curSize-1（最大编号）：局部自上向下筛选
	}
}
```
3. 小根堆删除堆顶的算法：
```C++
bool Remove_Top(minHeap &H, int &x)
{
	//删除小根堆的堆顶元素，并用引用参数 x 记录被删除的堆顶的值
	if(H.curSize==0) return false;    //如果堆空，返回“false”
	x=H.elem[0];
	H.elem[0]=H.elem[H.curSize-1];    //最后一个元素填补到根结点
	H.curSize--;
	siftDown(H, 0, H.curSize-1);    //只动了一个元素，重新调整为堆
	return true;
}
```
4. 小根堆的向上筛选算法：
```C++
void siftUp(minHeap &H, int start)
{
	//从结点 start 开始到结点 0 为止, 自下向上比较, 将集合重新调整为堆
	int temp=H.elem[start];
	int j=start, i=(j-1)/2;    // i 是 j 的子结点，根据数学关系，i 应该是 j 退一位再除以二
	while(j>0)    //沿双亲路径向上直达根
	{
		if(H.elem[i]<=temp) break;    //双亲值小，符合小根堆特点，结束
		else
		{
			H.elem[j]=H.elem[i];
			j=i, i=(i-1)/2;    //双亲的值下降到子结点位置，j 与 i 的位置上升
		}
	}
	H.elem[j]=temp;    // start 的值放置在正确位置
}
```
5. 小根堆的插入算法：
```C++
bool Insert(minHeap &H, int x)
{
	//将 x 插入到小根堆中，并重新调整形成新的小根堆
	if(H.curSize==heapSize) return false;    //如果堆满，返回插入不成功信息“false”
	H.elem[H.curSize]=x;    //将元素 x 插入到最后
	siftUp(H, H.curSize);    //从下向上调整
	H.curSize+=1;    //堆的计数加一
	return true;    //返回
}
```

