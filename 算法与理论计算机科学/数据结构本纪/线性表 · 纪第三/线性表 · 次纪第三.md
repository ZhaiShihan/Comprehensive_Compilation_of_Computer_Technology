### 壹  链表置逆

#### 问：
##### 所给成单链，前者将后牵。
##### 何以使逆转，每后指向前？

· 给定一个带头结点的单链表，请将该链表置逆

###### 思路一 · 原地置逆：
```C++
typedef struct node
{
	int data;
	struct node *link;
} ListNode, *LinkList;

void Reverse(LinkList &L)
{
	LinkList p, q;
	p=L->link;
	p->link=NULL;
	q=L->link->link;
	if(q==NULL)
	{
		printf("无需置逆操作\n")；
		return ;
	}
	while(1)
	{
		LinkList s;
		s=q->link;
		q->link=p;
		if(s==NULL) break;
		p=q;
		q=s;
	}
	LinkList head=(ListList)malloc(sizeof(ListNode));
	head->link=q;
	return ;
}
```

###### 思路二 · 逆序插入新表中：
```C++
typedef struct node
{
	int data;
	struct node *link;
} ListNode, *LinkList;

void Reverse(LinkList L, LinkList &NEW)
{
	//将 L 的内容逆序插入 NEW 中
	LinkList q=NULL;
	LinkList p=L->link;
	while(p!=NULL)
	{
		LinkList m=(LinkList)malloc(sizeof(ListNode));
		m->data=p->data;
		m->link=q;
		q=m;
		p=p->link;
	}
	NEW->link=q;    //前提要保证 NEW 是一个内容为空的头结点
	return ;
}
```

##### 总结：
###### 1. 链表原地置逆：记录一个结点的前驱和后继，指针指向前驱，自己移向后继
###### 2. 逆序插入新表：遍历原链表，逆序建立新链表


### 贰  按序归并

#### 问：
##### 今取两链来，各自小大排。
##### 归入一链中，此链序仍在。

· 一、将两个非递减有序链表归并为一个非递减有序链表

```C++
typedef struct node
{
	int data;
	struct node *link;
} ListNode, *LinkList;

LinkList p1;
LinkList p2;    //用于存储给定两个链表的头结点
/*分配内存空间*/
LinkList p;    //用于存放合并完的链表
/*分配内存空间*/

void Merge(LinkList p1, LinkList p2, LinkList &p)
{
	LinkList t1=p1->link;
	LinkList t2=p2->link;
	LinkList t=NULL;
	p->link=t;
	while((!t1)&&(!t2))
	{
		if(t1->data<t2->data)
		{
			t=(LinkList)malloc(sizeof(ListNode));
			t->data=t1->data;
			t->link=NULL;
			t=t->link;
			t1=t1->link;
		}
		else
		{
			t=(LinkList)malloc(sizeof(ListNode));
			t->data=t2->data;
			t->link=NULL;
			t=t->link;
			t2=t2->link;
		}
	}
	while(!t1)
	{
		t=(LinkList)malloc(sizeof(ListNode));
		t->data=t1->data;
		t->link=NULL;
		t=t->link;
		t1=t1->link;
	}
	while(!t2)
	{
		t=(LinkList)malloc(sizeof(ListNode));
		t->data=t2->data;
		t->link=NULL;
		t=t->link;
		t2=t2->link;
	}
	t=NULL;
	return ;
}
```

· 二、将两个非递减有序链表归并为一个非递增有序链表

```C++
typedef struct node
{
	int data;
	struct node *link;
} ListNode, *LinkList;

LinkList p1;
LinkList p2;    //用于存储给定两个链表的头结点
/*分配内存空间*/
LinkList p;    //用于存放合并完的链表
/*分配内存空间*/

void Merge(LinkList p1, LinkList p2, LinkList &p)
{
	LinkList t1=p1->link;
	LinkList t2=p2->link;
	LinkList t=(LinkList)malloc(sizeof(ListNode));
	if(t1->data>t2->data)
	{
		t->data=t1->data;
		t1=t1->link;
	}
	else
	{
		t->data=t2->data;
		t2=t2->link;
	}
	t->link=NULL;
	
	while((!t1)&&(!t2))
	{
		if(t1->data>t2->data)
		{
			LinkList tp=(LinkList)malloc(sizeof(ListNode));
			tp->data=t1->data;
			tp->link=t;
			t=tp;
			t1=t1->link;
		}
		else
		{
			LinkList tp=(LinkList)malloc(sizeof(ListNode));
			tp->data=t2->data;
			tp->link=t;
			t=tp;
			t2=t2->link;
		}
	}
	while(!t1)
	{
		LinkList tp=(LinkList)malloc(sizeof(ListNode));
		tp->data=t1->data;
		tp->link=t;
		t=tp;
		t1=t1->link;
	}
	while(!t2)
	{
		LinkList tp=(LinkList)malloc(sizeof(ListNode));
		tp->data=t2->data;
		tp->link=t;
		t=tp;
		t2=t2->link;
	}
	p->link=t;
	return ;
}
```

##### 总结：
###### · 两个非递减序列合成非递减序列，则两个链表由头到尾遍历即可，比较考察结点，每次选出较小的
###### · 两个非递减序列合成非递增序列，则两个链表有尾到头反向遍历，比较考察结点，每次选出最小的


### 叁  删除重复

#### 问：
##### 一线引穿多彩珠，中有多出有单出。
##### 何以重接序不变，能得各色唯留独？

· 一个给定单链表，里面内容重复的删去，仅保留一个
###### 代码实现：
1. 以空间换时间：
```C++
void Delete(Link L)
{
	Link p=L->next;
	Link q=L;
	int tube[10000]={0}
	while(!p)
	{
		int x=p->data;
		if(tube[x]==0) tube[x]++;
		else
		{
			q->next=p->next;
			free(p);
		}
		p=p->next;
		q=q->next;
	}
	return ;
}
```
2. 平方阶时间复杂度的二重循环：
```C++
void Delete(Link L)
{
	Link p=L->next;
	Link q=L->next;
	Link r=L->next;
	while(!p->next)
	{
		q=p->next;
		r=p;
		while(!q->next)
		{
			if(p->data==q->data)
			{
				r->next=q->next;
				free(q);
			}
			q=q->next;
			r=r->next;
		}
	}
	return ;
}
```

##### 总结：
###### · 当链表中每个结点的“data”值范围确定且比较集中时可以考虑采用空间换时间的方法实现加速
###### · 当链表中每个结点的“data”值范围未知或分布范围非常广时则用二重循环的方法最为稳妥


### 肆  回文判断

#### 问：
##### 一链头尾各中行，每步遥遥相呼应。
##### 若问何以最省力，回文可否速判定。

· 给定一个带头结点 D 的单链表，判断是否回文
· 要求时间复杂度为线性，空间上没有额外内存分配
· 可以对给定的单链表进行修改

###### 思路分析：
1. 先找出链表的中间位置结点（如果是奇数个结点，则找中间；如果是偶数个，则找前一半末）
	1. 快慢指针法：快指针走两格，同时慢指针走一格，当快指针到尾时，慢指针停在中间
	2. 长度截半法：遍历链表，统计出长度，再将长度截半，在半长位置上设立标志指针
2. 将后一半链表原地置逆
3. 将原地置逆的链表与前一半原序链表逐位比较

###### 代码实现（采用快慢指针的方式）：
```C++
//链表的头结点 D 已给定，数据域为 data，指针域为 link，结构指针为 *LinkList

void Judge(LinkList &D)
{
	LinkList s=D, t=D;
	while(t==NULL||t->link==NULL)
	{
		s=s->link;
		t=t->link->link;
	}
	LinkList p=s->link, q=D->link;
	while(p!=NULL&&q!=s)
	{
		if(p->data!=q->data)
		{
			printf("链表不回文\n");
			return;
		}
		else p=p->link, q=q->link;
	}
	printf("链表回文\n");
	return ;
}
```

##### 总结：
###### · 当处理单链表“逆行”的问题时：
1. 如果允许更改原链表，则可以采用原地置逆的方法节省空间和时间
2. 如果不允许更改原链表，则可以采用一边遍历一边额外反向建立链表的方式，得到一个逆序链表


### 伍  链环判断

#### 问：
##### 金丝贯珠成锦线，一珠一过不再串。
##### 恐有疏忽丝回走，何能知晓熟有环？

· 给定一个带空头结点的链表，头结点设为第 0 结点，判断这个链表是否存在环，若有则给出环头是第几结点

##### 一、原地循环法：
###### 思路分析：
1. 用快慢双指针法，初始置于 0 位，每次快指针走两步，慢指针走一步，循环进行，判断两指针能否“碰头”
2. 如果两指针无法“碰头”，则说明链表中不存在环
3. 如果两指针最终“碰头”，需要记录下指针前进的次数：
![[次纪第三-图/次纪第三-图一.png|450]]
（图一：快指针“走”的距离为 2x+2y，慢指针“走”的距离为 x+y，整个链表长度为 2x+y）
4. 两个指针再分别从相遇 C 处和头结点 A 处出发，以同样的速度，一次一“格”，再相遇处为入口结点 B 处

###### 代码实现：
```C++
void Search(LinkList H)    // H 为给定链表的头结点
{
	LinkList *fast=H, *slow=H;
	int step=0;    //记录慢指针移动“步数”，对应上述“图一”中的 x+y
	while(1)
	{
		if(fast->next==NULL||fast==NULL)
		{
			printf("链表无环\n");
			return;
		}
		fast=fast->link->link;
		slow=slow->link;
		if(fast==slow)
		{
			fast=H;
			while(fast!=slow)
			{
				fast=fast->link;
				slow=slow->link;
				step++;
			}
			printf("第 %d 个结点是环头结点\n",step);
			return;
		}
	}
}
```

##### 二、元素记录法：
###### 思路分析：
1. 用一个 map 容器存储对组<链表结点，指针移动步数>
2. 遍历链表，检查每一个结点地址是否在 map 中出现过，若无则存入，若有则判断有环，对组第二元素即为所求

###### 代码实现：
```C++
#include<map>
using namespace std;    //注意需要有这些引用

void Search(LinkList H)    // H 是给定链表的头结点
{
	map <LinkList*, int> M;
	LinkList *L=H;
	int step=0;    //记录指针移动“步数”
	while(L!=NULL)
	{
		L=L->link;
		step+=1;
		int p=M.count(L);
		if(p==1)    //结点存在则说明有环
		{
			printf("第 %d 个结点是环头结点\n",M[L]);
			return;
		}
		else M.insert({L, step});    //否证插入对组
	}
	printf("链表无环\n");
	return;
}
```

##### 总结：
######       可以参考《循环即止 · 卷第六》所给出的判断循环节的方法进行判定，如果考察的数据量较少，可以采用以空间换时间的方式，将每一个考察单元全部用最方便读取的方式存储，并记录其所在的位置，用一个指针遍历，每遇到一个单元则“查重”；如果考察的记录不方便开辟空间存储，则可以采用原地遍历的方法，设置快慢两个指针，利用二倍与一倍“步长”的差值，借助数学手段进行求解，得出循环节的位置。

