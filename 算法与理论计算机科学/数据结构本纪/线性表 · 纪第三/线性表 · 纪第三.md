### 壹  线性表的定义

#### 述：
##### 
##### 

#### 线性表及其特征：
###### · 线性表是一种最简单的线性结构
###### · 线性结构：一个数据元素的有序集
###### · 线性表的特征：
1. 存在唯一的第一元素
2. 存在唯一的最后元素
3. 除第一个元素外，每个元素都有唯一的前驱
4. 除最后一个元素外，每个元素均有唯一的后继
5. 同一线性表的元素具有相同的特性

#### 线性表的相关操作：

##### 一、线性表的合并：A=A∪B：
![[纪第三-图/纪第三-图一.png]]
（图一：线性表合并的举例）
###### 基本思想：
· 将存在于线性表 LB 中而不存在于线性表 LA 中的数据元素插入到线性表 LA 中去，必要时扩大线性表 LA
###### 控制程序：
· for ( int i = 1;  i <= LB_len;  i++ )
###### 算法步骤：
1. 初始化参数：LA_len=ListLength ( LA ) ;    LB_len=ListLength ( LB ) ;
2. 从线性表 LB 中依次查看每个数据元素：for ( int i = 1;  i <= LB_len;  i++ )  GetElem ( LB,  i,  e ) ;
	2.1 依次在先性表 LA 中进行查访：LocateElem ( LA,  e,  equal ( ) ) ;
	2.2 若不存在，则插入到 LA 后面：ListInsert ( LA,  n+1,  e ) ;
###### <font color="#00b0f0">程序实现简码：</font>
```C++
void Union(List &LA, List LB)
{
	LA_len=ListLength(LA);    //求 LA 的长度
	LB_len=ListLength(LB);    //求 LB 的长度
	for(int i=1; i<=LB_len; i++)
	{
		GetElem(LB, i, e);    //取 LB中的第 i 个元素赋给 e
		if(!LocateElem(LA, e, equal() ) ) ListInsert(LA, ++LA_len, e);
		//如果 LA 中不存在和 e 相同的数据元素，则插入到 LA 的尾部 
	}
}
```

##### 二、有序线性表的合并：
###### · 已知线性表 LA 和线性表 LB 中的数据元素按值非递减有序排列
###### · 要求将 LA 和 LB 归并为一个新的线性表 LC ，且 LC 中的元素仍按值非递减有序排列，LC=LA+LB
![[纪第三-图/纪第三-图二.png|750]]
                                             （图二：有序线性表的合并举例）
###### 基本操作：
· 构造线性表 LC ，从 LA 和 LB 中依次取出元素，按照非递减的顺序依次插入到表尾
###### 如何确定插入顺序？
1. 取出 LA 中当前的元素 a 和 LB 中当前的元素 b
2. 若 a<=b 则先插入 a，并将 a 的指针后移一位
3. 否则先插入 b，并将 b 的指针后移一位
###### 控制程序：
· while ( ( i <= LA_len ) && ( j <= LB_len ) )
###### 算法步骤：
1. 初始化 LC：InitList ( LC )
2. 设置 LA 和 LB 的当前指示：i = j = 1
3. 计算 LA 和 LB 的长度
4. 依次从线性表 LA 和 LB 中取出当前元素，根据上述标准判断需要插入 a 或 b，插入后将 LC 的长度加 1
5. 如果某一个表中的元素取尽，则将另外一个表的剩余元素直接插入到 LC 
###### <font color="#00b0f0">程序实现简码：</font>
```C++
void Merge_List(List LA, List LB, List &LC)    //"合并线性表”函数
{
	InitList(LC);    //初始化 LC
	i=j=1; k=0;    //设置 LA 和 LB 的当前指示值
	LA_len=ListLength(LA), LB_len=ListLength(LB);    //计算 LA 和 LB 的长度
	while((i<=LA_len)&&(j<=LB_len))
	{
		GetElem(LA, i, ai); GetElem(LB, j, bj);    //取出目前考察元素
		if(ai<=bj)
		{
			ListInsert(LC, ++k, ai);
			i++;
		}
		else
		{
			ListInsert(LC, ++k, bj);
			j++;
		}    //将 ai 和 bj 中较小的值续接插入 LC 的尾部
	}
	//后续处理部分：
	while(i<=LA_len)
	{
		GetElem(LA, i++, ai);
		ListInsert(LC, ++k, ai);
	}
	while(j<=LB_len)
	{
		GetElem(LB, j++, bj);
		ListInsert(LC, ++k, bj);
	}
}
```
###### 注：如果要求 LC 中没有重复的元素，则插入时要多加一步判定，即待插入元素与队尾是否相同：
· 如果待插入元素与队尾不同，则插入
· 如果待插入元素与队尾相同，则不插入或删除队尾
### 贰  顺序表及其操作

#### 述：
##### 一百单八座次排，诸雄按位落座来。
##### 新揽或有离席去，一发全身盘重开。
![[纪第三-图/纪第三-图三.png]]
（图三：用一组地址连续的存储单元依次存放线性表中的数据元素）
###### · 顺序映像：以 x 的存储位置和 y 的存储位置之间的某种关系表示逻辑关系 < x, y >
###### · 最简单的一种顺序映像方式：用一组地址连续的存储单元依次存放线性表中的数据元素:
【元素存储顺序与元素的逻辑顺序一致】
###### · 以“存储位置相邻”表示有序对 < a<sub>i-1</sub> , a<sub>i</sub> >，即：
LOC ( a<sub>i</sub> ) = LOC ( a<sub>i-1</sub> ) + C，【C是一个数据元素所占存储量】
###### · 所有数据元素的存储位置均取决于第一个数据元素的存储位置：
LOC ( a<sub>i</sub> ) = LOC ( a<sub>1</sub> ) + ( i -1 ) * C，【C是一个数据元素所占存储量】
###### · 读写元素方便 ，通过下标即可指定位置

#### 线性表的数据结构定义：

##### 静态定义：

```C++
#define maxSize 100;    //自定义线性表最大存储空间
typedef struct
{
	int data[maxsize];    //存储空间基址
	int n;    //当前长度（元素个数）
} SeqList;    //俗称“顺序表”
```

##### 动态定义：

```C++
#defint IniSize 100;    //线性表存储空间的初始分配量
#define ListIncrement 10;    //线性表存储空间的分配增量
typedef struct
{
	int *data;    //存储空间基址
	int maxSize;    //分配的存储容量（以 sizeof(int) 为单位）
	int n;    //线性表当前长度，即元素个数
} SeqList;    //俗称“顺序表”
```
![[纪第三-图/纪第三-图四.png]]
（图四：顺序表的动态定义存储示意）

#### 顺序表的基本操作：

##### 一、顺序表的初始化操作：

```C++
#define iniSize 100;
typedef struct
{
	int *data;
	int n;
	int maxSize;
} SeqList;    //顺序表

void IniList_Sq(SeqList &L)
{
	//构造一个空的线性表
	L.data=(int*)malloc(iniSize*sizeof(int));
	if(L.data==NULL)
	{
		printf("存储分配失败\n");
		return ;
	}
	L.n=0;
	L.maxSize=iniSize;
	return ;
}
```

##### 二、顺序表的查找操作：

###### 按值查找：在顺序表中从头查找结点值等于给定值 x 的结点
```C++
int Find(SeqList L, int x)    //返回值为所寻元素位置
{
	for(int i=0; i<L.n; i++)
	{
		if(L.data[i]==x) return i;    //查找成功则返回元素位置
	}
	return -1;    //查找失败
}
```
###### 查找算法的性能分析：最坏时间复杂度：n；期望时间复杂度：（n+1）/2（假设查找概率相等）

##### 三、顺序表的插入操作：

###### · 目的：在顺序表 L 的第 i 个元素之前插入新的元素 e，即把 e 插入到第 i 个元素的位置
###### · i 的合法范围为 1 ≤ i ≤ L.n + 1
![[纪第三-图/纪第三-图五.png]]
（图五：顺序表的插入操作示意）
###### · 操作步骤:
1. 判断插入位置是否合法
2. 将第 n 至第 i 个元素依次后移一位
3. 新元素插入第 i 个位置：表长度加一
###### · 插入算法：
```C++
bool ListInsert(SeqList &L, int x, int i)
{
	//在表中第 i (1 ≤ i ≤ n+1) 个位置插入新元素 x
	if(L.n==L.maxSize) return false;
	if(i<1||i>L.n+1) return false;
	for(int j=L.n-1; j>=i-1; j--)    //移动元素
	{
		L.data[j+1]=L.data[j];
	}
	L.data[i-1]=x;    //实际插入位置为 j-1
	L.n++;    //表的长度加一
	return true;
}
```
###### · 注意：表中的第 1 个位置是 L.data【0】，表中的第 i 个位置是 L.data【 i -1 】
· 从 第 i 个元素（ L.data【 i -1 】）开始，到最后一个元素，都要依次向后平移一格：
![[纪第三-图/纪第三-图六.png]]
（图六：顺序表的插入过程中，插入点后所有元素后移的操作示意）
###### ·注：算法的时间复杂度取决于移动元素的次数
###### <font color="#00b050">· 插入操作的算法复杂度分析：</font>
· 若假定在线性表中任何一个位置上进行插入的概率都是相等的，则移动元素的期望值为：
<font color="#00c0f0">Eis = ( 1 / ( n +1) ) * ∑<sub>i=1</sub><sup>n+1</sup> ( n - i +1 ) = n /2</font>
· 算法时间复杂度为: O ( n )
###### · 应急预案：如果存储空间已满怎么办？
```C++
#defint IniSize 100;    //线性表存储空间的初始分配量
#define ListIncrement 10;    //线性表存储空间的分配增量
typedef struct
{
	int *data;    //存储空间基址
	int maxSize;    //分配的存储容量（以 sizeof(int) 为单位）
	int n;    //线性表当前长度，即元素个数
} SeqList;    //俗称“顺序表”

void Increment(SeqList &L)    //增加存储空间
{
	if(L.n>=L.maxSize)
	{
		//当前存储空间已满，增加分配
		int *newbase=(int *)realloc(L.data, (L.maxSize+ListIncrement)*sizeof(int));
		if(newbase==NULL)
		{
			printf("存储分配失败\n")；
			return ;
		}
		L.data=newbase;
		L.maxSize+=ListIncrement;
	}
	return ;
}
```

##### 四、顺序表的删除操作：

###### · 目的：删除线性表中第 i 个元素，并将删除的元素存放在 e 中
###### · i 的合法范围为 1 ≤ i ≤ L.n
###### · 操作过程：
1. 判断参数合法性
2. 读出删除元素
3. 第 i +1 个至第 n 个元素依次前移
4. 表长度减一
![[纪第三-图/纪第三-图七.png]]
（图七：顺序表的删除操作过程示意）
###### · 代码实现：
```C++
bool ListDelete(SeqList &L, int i, int &e)
{
	//在表中删除第 i 个元素，通过 e 返回其值
	if(L.n>0&&i>0&&i<=L.n)
	{
		e=L.data[i-1];    //读出删除元素
		for(int j=i; j<L.n; j++)    //元素前移
		{
			L.data[j-1]=L.data[j];
		}
		L.n-=1;    //表的长度减一
		return true;
	}
	else return false;
}
```
· 从 第 i +1 个元素（ L.data【 i 】）开始，到最后一个元素，都要依次向后平移一格：
![[纪第三-图/纪第三-图八.png]]
（图八：顺序表的删除操作过程中，被删除元素之后所有元素前移的示意）
###### · 注：算法的时间复杂度取决于移动元素的次数
###### <font color="#00b050">· 插入操作的算法复杂度分析：</font>
· 若假定在线性表中任何一个位置上进行插入的概率都是相等的，则移动元素的期望值为：
<font color="#ffc000">Eds = ( 1 / n ) * ∑<sub>i=1</sub><sup>n</sup> ( n - i ) = ( n -1 ) /2</font>
· 算法时间复杂度为: O ( n )

#### 小结：顺序表的优缺点：

##### 优点：
###### 1. 不需要附加空间
###### 2. 随机存取任一个元素（根据下标）

##### 缺点：
###### 1. 很难估计所需要的空间大小
###### 2. 开始就要分配足够大的一片连续的内存空间
###### 3. 更新操作代价大（大量元素前移或后移）


### 叁  单链表及其操作

#### 述：
##### 逐名排队连，前者将后牵。
##### 一迈难回头，中抽各个点。

#### 单链表的定义和特点：

###### 1. 用一组地址任意的存储单元存放线性表中的数据元素
###### 2. 元素+指针（指示后继元素存储位置）= 结点（表示数据元素的映像）
###### 3. 以“结点的序列”表示线性表，称作“链表”
###### 4. 链表中第一个元素结点称为<font color="#ffff00">元首结点</font>，最后一个元素称为<font color="#ffff00">尾结点</font>，<font color="#ooffff">元首结点不是头结点</font>

##### 带头结点的单链表：
###### · 头结点位于表的最前端，本身不带数据，仅标志表头
###### · 设置头结点的目的：
	1. 统一空表和非空表的操作
	2. 简化链表操作的实现
· 在元首结点的前面是头结点，头结点里面内容为空：
![[纪第三-图/纪第三-图九.png]]
（图九：带有头结点的单链表，头结点与全表之间的关系示意）
###### · 单链表是一种顺序存取的结构，为找第 i 个数据元素， 必须先找到第 i -1 个数据元素

##### 线性链表的定义：

```C++
typedef struct node
{
	int data;    //数据域
	struct node *link;    //指针域
} LinkNode, *LinkList;

LinkList L;    // L 为单链表的头指针
```
###### · 对于 LinkNode * p：
![[纪第三-图/纪第三-图十.png]]
（图十：有关指针的一些概念）
· 注：在链表中，如果没有定义重载“++”函数，不能 使用 p++ 这样的语句进到逻辑上的下一个结点
· 一般用 p = p -> link 进到下一结点

#### 单链表中基本操作的实现：

##### 一、取第 i 个数据元素：GetElem ( L, i, &e)

###### · 基本操作：移动指针 i 次
###### · 令指针 p 始终指向线性表中第 j 个数据元素
###### · 结束条件：找到第 i 个结点，即 j = i；或者 i 大于链表长度，即 p＝null
![[纪第三-图/纪第三-图十一.png]]
（图十一：取第 i 个数据元素操作示意）
###### · 算法的基本过程：
1. p 指向第一个结点，初始化计数器 j 为 1
2. 顺时针向后查找，直到 j = i 或 p 为空
3. 如果找不到第 i 个结点（ j > i 或 p =null ），则反馈后返回
4. 取出第 i 个结点的数据，放在 e 中，返回
```C++
void GetElem(SeqList L, int i, int &e)
{
	// L 是带头结点的链表的头指针，以 e 返回第 i 个元素
	SeqList p=L->link; int j=1;    //步骤一：初始化指针和计数器
	while(p!=NULL&&j<i)
	{
		p=p->link;
		++j;
	}    //步骤二：顺指针向后查找，直到 p 指向第 i 个元素或 p 为空
	if(p==NULL||j>i)
	{
		printf("第 i 个元素不存在\n");
		return ;
	}    //步骤三：第 i 个元素不存在
	e=p->data;    //步骤四；取出第 i 个元素
	return ;    //返回
}
```
###### · 注：算法时间复杂度为: O ( ListLength ( L ) )

##### 二、在单链表中按值查找：Search ( L, x)

```C++
LinkNode *Search(LinkList L, int x)    //在 L 中查找值为 x 的元素
//另一种写法：LinkList S二arch(LinkList L, int x)
{
	//在链表中从头搜索其数据值为 x 的结点
	LinkNode *p=L->link;    // p 为检测指针
	while(p!=NULL&&p->data!=x)
	{
		p=p->link;
	}
	return p;
}
```
###### · 注意：while 循环条件 p != NULL 和  p->data != x 不能交换！

##### 三、第 i 个位置插入元素：ListInsert ( &L, i, e)

###### · 目的：在线性表第 i 个位置插入元素 e，即在第 i 个结点之前插入元素 e
###### · 结果：有序对 < a<sub>i-1</sub>, a<sub>i</sub> > 改变为 <a<sub>i-1</sub>, e > 和 < e, a<sub>i</sub> >
![[纪第三-图/纪第三-图十二.png|600]]
                              （图十二：单链表插入操作示意）
###### · 在链表中插入结点只需要修改指针
###### · 修改第 i -1 个结点的指针
###### · 基本操作：找到线性表中第 i -1 个结点，修改其后继指针
![[纪第三-图/纪第三-图十三.png]]
（图十三：找到线性表中的第 i -1 个结点，修改其后继指针，完成插入过程）
###### · 实现过程：
1. p 指向头结点，初始化计数器 j = 0
2. 查找第 i -1 个节点：顺指针向后查找，直到 j = i -1 或 p 为空
3. 如果找不到第 i -1 个结点，则反馈结果后返回
4. 创建新结点，若创建失败，则反馈结果后返回
5. 将新结点插入到 i 结点之前
###### · 代码实现：
```C++
void ListInsert(LinkList &L, int i, int e)
{
	//L 为带头结点的单链表的头指针
	LinkList p=L; int j=0;    //步骤一：初始化指针和计数器
	while(p!=NULL&&j<i-1)    //步骤二：寻找第 i 个结点
	{
		p=p->link;
		++j;
	}
	if(p==NULL||j>i-1)
	{
		printf("找不到i-1\n")；
		return ;
	}    //步骤三：找不到 i-1
	LinkList s=(LinkList)malloc(sizeof(LNode));
	if(s==NULL)
	{
		printf("创建失败\n");
		return ;
	}    //步骤四：创建新结点
	s->data=e;
	s->link=p->link;
	p->link=s;    //步骤五：插入新结点
	return ;
}
```
###### · 注：算法的时间复杂度为 O ( ListLength ( L ) )

##### 四、删除第 i 个结点：ListDelete ( &L, i, &e)

###### · 基本操作：找到线性表中第 i -1 个结点，修改其指向后继的指针
###### · 实现过程：
1. p 指向第一个结点，初始化计数器 j
2. 查找第 i 个结点，并令 p 指向其前驱
3. 如果找不到第 i 个结点，则反馈后返回
4. 从表中删除结点 i（修改指针）
5. 将结点 i 的值赋给变量 e，并<font color="#ffff00">释放结点 i 所占的内存</font>
6. 返回
###### · 代码实现：
```C++
void ListDelete(LinkList &L, int i, int &e)
{
	LinkList p=L; int j=0;    //第一步：初始化指针和计数器
	while(p->link!=NULL&&j<i-1)
	{
		p=p->link;
		++j;
	}    //第二步：寻找第 i 个结点，并令 p 指向其前驱
	if(p->link==NULL||j>i-1)
	{
		printf("位置不合理\n");
		return ;
	}    //第三步：讨论位置不合理的情况
	LinkList q=p->link;
	p->link=q->link;    //第四步：删除结点
	e=q->data;
	free(q);    //第五步：记录被删除的内容并释放结点
	return ;    //第六步：返回
}
```
###### · 注：算法的时间复杂度为 O ( ListLength ( L ) )

##### 五、重置空表操作：ListClear ( &L )

###### · 操作目的：将单链表 L (带头结点) 重新置为一个空表
```C++
void ListClear(LinkList &L)
{
	//将单链表 L (带头结点) 重新置为一个空表
	LinkList p=L->link;
	while(p!=NULL)
	{
		LinkList q=p->link;
		free(p);
		p=q;
	}    //依次释放各个结点
	L->link=NULL;
}
```
###### · 注：算法的时间复杂度为 O ( ListLength ( L ) )

##### · 不带头结点的单链表插入操作：

```C++
bool LinkInsert(LinkList &L, int i, int x)
{
	LinkList newnode;
	newnode=(LinkList)malloc(sizeof(LNode));
	newnode->data=x;
	if(i==1)
	{
		newnode->link=L;
		L->newnode;
	}
	else(i<=L.n+1)
	{
		LinkList p=L;
		int j=1;
		while(p!=NULL&&j<i-1)
		{
			p=p->link;
			++j;
		}
		newnode->link=p->link;
		p->link=nwenode;
	}
	else
	{
		return false;
	}
	L.n+=1;
	return true;
}
```

##### · 不带头结点的单链表删除操作：

```C++
bool ListRemove(LinkList &L, int i, int &e)
{
	//在单链表中删除第 i 个结点
	LinkList q=L;
	if(i==1)
	{
		L=L->link;
	}
	else if(i<=L.n)
	{
		int j=1;
		while(q!=NULL&&j<i-1)
		{
			q=q->link;
			++j;
		}
		LinkList s=q->link;
		e=s->link;
		q->link=s->link;
		free(s);
	}
}
```

#### 单链表的其他（非基本）操作：

##### 一、带头结点的单链表的建立：
###### · 要求：逆序输入 n 个数据元素
###### · 生成链表的过程是一个结点“逐个插入”的过程
###### <font color="#00b0f0">前插法</font>操作步骤：
1. 建立一个“空表”
2. 输入数据元素 a<sub>n</sub>，建立结点并插入
3. 依此类推，直至输入 a<sub>1</sub> 为止
![[纪第三-图/纪第三-图十四.png]]
（图十四：前插法建立头结点的第一步示意）
###### · 代码实现：
```C++
int con_elem[100];    //倒序存放数据元素
int n;    //数据元素个数

void ListCreate(LinkList &L, int *con_elem, int n)
// con_elem[] 是倒序存储数据的数组，n 是元素个数
{
	LinkList p=L;
	for(int i=1; i<=n-1; i++)
	{
		LinkList q=(LinkList)malloc(sizeof(ListNose));
		q->data=con_elem[i];
		q->link=p;
		p=q;
	}
	LinkList Head=(LinkList)malloc(sizeof(ListNode));
	Head->link=p;    //头结点置空
	return ;
}

int main()
{
	LinkList L;
	L=(LinkList)malloc(sizeof(ListNode));
	L->link=NULL;
	L->data=con_elem[0];
	L.n=n;
	ListCreate(L, con_elem, n);
	return 0;
}
```
###### <font color="#00b0f0">后插法</font>基本思想：
（顺序输入 n 个数据元素，建立带头结点的单链表）
1. 每次将新结点加在插到链表的表尾
2. 设置一个尾指针 r，总是指向表中最后一个结点， 新结点插在它的后面
3. 尾指针 r 初始时置为指向表头结点地址
![[纪第三-图/纪第三-图十五.png]]
（图十五：后插法建立链表的前两步示意）
###### · 代码实现：
```C++
int elem[100];    //正序存放数据元素
int n;    //数据元素个数

void ListCreate(LinkList &L, int *elem, int n)
{
	LinkList p=L;
	for(int i=0; i<=n-1; i++)
	{
		LinkList s=(LinkList)malloc(sizeof(ListNode));
		s->data=elem[i];
		s->link=NULL;
		p->link=s;
		p=p->link;
	}
	return ;
}

int main()
{
	LinkList head=(LinkList)malloc(sizeof(ListNode));
	ListCreate(head, elem, n);
	return 0;
}
```

##### 二、遍历带头结点的单链表：

```C++
void ListTraverse(linkList L)    //从元首元素开始遍历线性表
{
	LinkList p=L->link;
	while(p!=NULL)
	{
		/*访问结点 p，如输出内容等操作*/
		p=p->link;
	}
	return ;
}
```


### 肆  扩展域的单链表

#### 述：
##### 按位逐排队，前引后盲随。
##### 各自知首尾，不知前人谁。
![[纪第三-图/纪第三-图十六.png]]
（图十六：扩展域的单链表每个结点结构示意）
```C++
typedef struct node    //扩展域的单链表结点结构
{
	struct node *head;    //指向头结点
	struct node *tail;    //指向尾结点
	int len;    //表示链表长度
	sturct node *current;    //指向当前被访问的结点的指针（初始位置指向头结点）
} ListNode, *LinkList;
```
![[纪第三-图/纪第三-图十七.png]]
（图十七：扩展单链表的结构初始化和销毁结构复杂度）
![[纪第三-图/纪第三-图十八.png]]
（图十八：扩展单链表的引用型操作复杂度 Ⅰ ）
![[纪第三-图/纪第三-图十九.png]]
（图十九：扩展单链表的引用型操作复杂度 Ⅱ ）
![[纪第三-图/纪第三-图二十.png]]
（图二十：扩展单链表加工型操作复杂度）

##### · 操作：将元素 e 插在当前指针之后

```C++
void InsAfter(LinkList &L, int e)
{
	//若当前指针在链表中，则将数据元素 e 插入在线性链表 L 中当前指针所指结点之后
	//当指针指向新结点，直接返回；否则，反馈后返回
	if(L.current==NULL)
	{
		printf("这是一个空结点\n");
		return ;
	}    //合法性判断
	LinkList s=(LinkList)malloc(sizeof(ListNode));
	if(s==NULL)
	{
		printf("新结点创建失败\n");
		return ;
	}    //创建新结点的检验
	s->link=L.current->link;
	L.current->link=s;
	if(L.tail==L.current) L.tail=s;    //若修改尾指针，则尾指针域也要随之修改
	L.current=s;    //修改当前指针
	L.len+=1;    //表的长度加一
	return ;
}
```


### 伍  静态链表

#### 述：
##### 方阵何流转？双列得归一。
##### 以左达其意，以右引东西。

###### · 用数组实现的链式结构，称为静态链表
```C++
#define MAXSIZE 1000    //链表的最大长度
typedef struct
{
	int data;    //存储内容
	int cur;    //当前指针所指向的结点，即这个点的下一个点的位置域
} component, SLinkList[MAXSIZE];    //"component"意为“组成、构成”
SLinkList *space;
```
![[纪第三-图/纪第三-图二十一.png|200]]
                             （图二十一：静态链表的数组结构）
###### · 备用空间链表：
![[纪第三-图/纪第三-图二十二.png]]
（图二十二：备用空间链表示意）
· 备用空间链表的建立：
```C++
void InitSpace_SL()
{
	//建备用空间链表
	// space 为头指针，0 为空指针
	for(int i=0; i<MAXSIZE-1; i++)
	{
		space[i].cur=i+1;
		space[MAXSIZE-1].cur=0;
	}
	return ;
}
```
###### · 从备用链表中获取一个结点：
![[纪第三-图/纪第三-图二十三.png]]
（图二十三：从备用链表中获取一个结点）
```C++
int Malloc_SL()
{
	//若备用空间链表非空，返回分配结点的下标，否则返回零
	if(space[0].cur==NULL) return 0;
	int i=space[0].cur;    //取出第一个备用结点
	space[0].cur=space[i].cur;    //修改备用表
	return i;
}
```
###### · 将结点回收到备用链表中：
```C++
void Free_SL(int k)
{
	//将下标为 k 的结点回收到备用空间链表（头）
	space[k].cur=space[0].cur;
	space[0].cur=k;
}
```
###### · 静态链表的插入算法：
![[纪第三-图/纪第三-图二十四.png|700]]
                          （图二十四：静态链表的插入图示）
###### <font color="#00b050">操作步骤：</font>
1. 寻找第 i -1 个元素结点，设其下标为 k
2. 在备用空间中申请一个新结点：m = Malloc_SL ()；  space【m】.data = e；
3. 插入新结点：space【m】.cur = space【k】.cur；  space【k】.cur=m；
```C++
int Malloc_SL()
{
	//若备用空间链表非空，返回分配结点的下标，否则返回零
	if(space[0].cur==NULL) return 0;
	int i=space[0].cur;    //取出第一个备用结点
	space[0].cur=space[i].cur;    //修改备用表
	return i;
}

void ListInsert_SL(int S, int i, int e)
// S 为静态链表头结点的下标，在第 i 个元素前插入 e
{
	int k=S;
	int j=0;    //寻找第 i-1 个元素结点
	while(k!=0&&j<i-1)
	{
		k=space[k].cur;
		++j;
	}
	if(k==0||j>i-1)
	{
		printf("目标位置寻找失败\n");
		return ;
	}
	int m=Malloc_SL();    //分配新结点
	if(m==0)
	{
		printf("新结点创建失败\n");
		return ;
	}
	space[m].data=e;
	space[m].cur=space[k].cur;
	space[k].cur=m;
	return ;
}
```
###### · 静态链表的删除：
![[纪第三-图/纪第三-图二十五.png]]
（图二十五：静态链表删除指定元素的示意）
```C++
void Free_SL(int k)
{
	//将下标为 k 的结点回收到备用空间链表（头）
	space[k].cur=space[0].cur;
	space[0].cur=k;
}

void ListDelete_SL(int S, int i, int &e)
// S 为静态链表头结点的下标，删除第 i 个元素，并用 e 记录被删除的值
{
	int k=S;
	int j=0;    //寻找第 i-1 个元素结点
	while(k!=0&&j<i-1)
	{
		k=space[k].cur;
		++j;
	}
	if(k==0||j>i-1)
	{
		printf("目标位置寻找失败\n");
		return ;
	}
	int m;
	m=space[k].cur;
	space[k].cur=space[m].cur;
	e=space[m].data;
	Free_SL(m);
	return ;
}
```


### 陆  循环与双向链表

#### 述：
##### 身前身后皆为邻，进进退退任可动。
##### 再访尾末又见首，兜兜转转竟无终。

###### · 单链表的弊端：
1. 只能从前驱寻找后继，无法从后继寻找前驱
2. 当遍历至末，直接结束，无法再遍历前面的元素

##### 一、单向循环链表：

###### · 单向循环链表就是最后一个结点的指针域的指针又指回第一个结点的链表
![[纪第三-图/纪第三-图二十六.png]]
（图二十六：单项循环链表的特点图示）
###### · 单项循环链表和单链表的差别仅在于，判别链表中最后一个结点的条件：
	· 单链表判别最后一个结点的条件是：后继是否为空
	· 单向循环链表判断最后一个结点的条件是：后继是否为头结点
###### · 如果插入与删除仅在链表的两端发生，可采用<font color="#ffff00">带表尾指针的循环链表</font>结构：
	1. 在表尾可直接插入新结点，时间复杂度为 O（1）
	2. 在表尾删除时要找前驱，时间复杂度为 O（n）
	3. 在表头插入相当于在表尾插入
	4. 在表头可直接删除，时间复杂度为 O（1）
· 表尾指针永远指向线性表的“最后一个”结点：
![[纪第三-图/纪第三-图二十七.png]]

##### 二、双向链表：

```C++
typedef struct DuLNode
{
	int data;    //数据域
	struct DuLNode *leftlink;    //指向前驱的指针域
	struct DuLNode *rightlink;    //指向后继的指针域
	int freq;    //访问计数
} DblNode, *DblList;
```
![[纪第三-图/纪第三-图二十八.png]]
（图二十八：双向链表的工作原理）
###### · 对于双向链表的有关操作：
1. “查询”和单链表相同
2. “插入”和“删除”时需要同时修改两个方向上的指针
![[纪第三-图/纪第三-图二十九.png|600]]
                                        （图二十九：双向链表的插入操作示意）
![[纪第三-图/纪第三-图三十.png|600]]
                                          （图三十：双向链表的删除操作示意）

##### 三、双向循环链表：

###### · 双向循环链表兼有头指针、尾指针、前驱指针和后继指针
![[纪第三-图/纪第三-图三十一.png]]
（图三十一：双向循环链表的工作原理）
![[纪第三-图/纪第三-图三十二.png|400]]
                         （图三十二：双向循环链表中间结点的指针域）
· 指针 llink 指向前驱结点；指针 rlink 指向后继结点
### 柒  顺序表和链表的比较

#### 述：
##### 
##### 

###### · 顺序表的主要特点：
1. 没有使用指针，不用花费额外开销
2. 线性表元素的读访问非常简洁便利
3. 插入、删除运算时间代价 O ( n )
###### · 链表的主要特点：
1. 无需事先了解线性表的长度，允许线性表的长度动态变化
2. 插入、删除运算时间代价 O ( 1 )，但找第 i 个元素运算时间代价 O ( n )
3. 每个元素都有结构性存储开销
###### · 结论：
· 顺序表：适合存储静态数据
· 链表：适合存储动态变化数据
###### · 线性表应用场合的选择：
· 顺序表不适用的场合：
	1. 经常插入删除时，不宜使用顺序表
	2. 线性表的最大长度也是一个重要因素
· 链表不适用的场合：
	1. 当读操作远多于插入、删除操作时，不应选择链表
	2. 当指针的存储开销远大于数据内容时，应该慎重选择
###### · 线性表存储密度：
· n 表示线性表中当前元素的数目
· P 表示指针存储单元大小
· E 表示数据元素存储单元大小
· D 表示可在数组中存储的线性表元素的最大数目
· 空间需求：
	· 顺序表的空间需求为：D × E
	· 链表的空间需求为：n × ( P + E )
· n 的临界值：使得 D × E = n × ( P + E )
	· n 大于临界值，顺序表的空间效率就更高
	· 如果 P = E，则临界值为 D / 2


### 捌  一元多项式的表示

#### 述：
##### 
##### 
![[纪第三-图/纪第三-度三十三.png]]
（图三十三：一元多项式的常见形式）
###### · 在计算机中，一元多项式（ Polynomial ）可以用一个线性表表示：P = ( p<sub>0</sub>, p<sub>1</sub>, ……, p<sub>n</sub> )
###### · 一元稀疏多项式：P<sub>n</sub> ( x ) = p<sub>1 </sub>* x<sup>e1</sup> + p<sub>2</sub> * x<sup>e2</sup> + …… + p<sub>n</sub> * x<sup>en</sup> 
###### （ 其中：p<sub>i</sub> 是指数为 ei 的项的非零系数，0 ≤ e1 < e2 < …… < em = n ）
###### · 稀疏多项式举例： S(x) = 1 + 3X<sup>10000</sup> – 2X<sup>20000</sup>

<font color="#00ffff"> · 稀疏多项式可以用线性表表示：( (p<sub>1</sub>, e1),  (p<sub>2</sub>, e2), ……, (p<sub>n,</sub> n) )</font>
<font color="#00ffff">（例如：P<sub>999</sub>(x) = 7x<sup>3</sup> - 2x<sup>12</sup> - 8x<sup>999</sup> 这一一元多项式可以用线性表 ( (7, 3), (-2, 12), (-8, 999) ) 表示 ）</font>

###### · 【名词解释】ADT：
· 全称为：abstract data type，意为“抽象数据类型”
· ADT 包括两个主要部分：
	· 数据：描述了抽象数据类型的数据成员，这些成员的类型和组织方式
	· 操作：描述在抽象数据类型上执行的一组操作，这些操作定义了对数据进行哪些操作，而非如何进行操作
![[纪第三-图/纪第三-图三十四.png|600]]
                        （图三十四：抽象数据类型一元多项式）
###### · 用带表头结点的有序链表表示多项式：
```C++
typedef struct    //项的表示
{
	float coef;    //系数
	int expn;    //指数
} term;
```

