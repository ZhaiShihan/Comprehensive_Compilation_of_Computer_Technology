### 壹  基础火柴棍等式

###### · 说明：
基础火柴棍等式形式：
$$a\star b=c$$其中 “$\star$” 仅表示加号 “$+$” 和减号 “$-$”，$a,b,c$ 均是一位整数（$0到9$）
Input the 1st number:（输入第一个操作数 a）
Input the operator:（输入符号，当符号不合法会报错）
Input the 2nd number:（输入第二个操作数 b）
Input the number behind the equal sign:（输入等号后的数字 c）
等待输出，输出为火柴棍移动的全部解

###### · 算法思想：
- 对于火柴棍问题，这些数字具有以下的“移动特点”：

· $0$ 能加成 $8$，能平动成 $6$ 和 $9$，但不能减
· $1$ 能加为 $7$，但是不能减，也不能平动
· $2$ 不能加，不能减，但是能平动为 $3$
· $3$ 能加成 $9$，能平动成 $2$ 和 $5$，但是不能减
· $4$ 不能加不能减，不能平动，所以只要有 $4$ 出现，直接排除改 $4$ 的可能性
· $5$ 能加成 $6$ 或 $9$，能平动成 $3$，但不能减
· $6$ 能加成 $8$，能平动成 $9$ 和 $0$，能减成 $5$
· $7$ 不能加不能平动，只能减为 $1$
· $8$ 不能加不能平动，可以减成 $0$，$6$，$9$
· $9$ 能加成 $8$，能平动成 $0$ 和 $6$，能减成 $3$ 和 $5$

- 对于 a（+/-）b=c：
1. 首先考察是否本来就成立
2. 当 a 加一时，考虑 + 变 - 或 b 减一或 c 减一
3. 当 a 减一时，考虑 - 变 + 或 b 加一或 c 加一
4. 当 a 平动时，考察是否成立
5. 当 b 加一时，考虑 + 变 - 或 c 减一
6. 当 b 减一时，考虑 - 变 + 或 c 加一
7. 当 b 平动时，考虑是否成立
8. 当 c 加一时，考虑 + 变 -
9. 当 c 减一时，考虑 - 变 +
10. 当 c 平动时，考虑是否成立

- 每次找到一个解后不退出程序，继续寻找下一个解，直到把上面十种情况考虑完全

###### · 代码实现：
```C++
#include<iostream>
using namespace std;

typedef struct
{
	int num1;    //加一笔能到的数字有几个
	int num0;    //不加笔画能到达的数字有几个
	int num_1;    //减一笔能到的数字有几个
	int n1[9];
	int n0[9];
	int n_1[9];
} stu;

stu N[10];

void initial()
{
	N[0].num1=1, N[0].n1[1]=8;
	N[0].num0=2, N[0].n0[1]=6, N[0].n0[2]=9;
	N[0].num_1=0;
	
	N[1].num1=1, N[1].n1[1]=7;
	N[1].num0=0;
	N[1].num_1=0;
	
	N[2].num1=0;
	N[2].num0=1, N[2].n0[1]=3;
	N[2].num_1=0;
	
	N[3].num1=1, N[3].n1[1]=9;
	N[3].num0=2, N[3].n0[1]=2, N[3].n0[2]=5;
	N[3].num_1=0;
	
	N[4].num1=0;
	N[4].num0=0;
	N[4].num_1=0;
	
	N[5].num1=2, N[5].n1[1]=6, N[5].n1[2]=9;
	N[5].num0=1, N[5].n0[1]=3;
	N[5].num_1=0;
	
	N[6].num1=1, N[6].n1[1]=8;
	N[6].num0=2, N[6].n0[1]=0, N[6].n0[2]=9;
	N[6].num_1=1, N[6].n_1[1]=5;
	
	N[7].num1=0;
	N[7].num0=0;
	N[7].num_1=1, N[7].n_1[1]=1;
	
	N[8].num1=0;
	N[8].num0=0;
	N[8].num_1=3, N[8].n_1[1]=0, N[8].n_1[2]=6, N[8].n_1[3]=9;
	
	N[9].num1=1, N[9].n1[1]=8;
	N[9].num0=2, N[9].n0[1]=0, N[9].n0[2]=6;
	N[9].num_1=2, N[9].n_1[1]=3, N[9].n_1[2]=5;
}

int calculate(int a, char o, int b)
{
	if(o=='+') return a+b;
	else if(o=='-') return a-b;
	else
	{
		cout<<"Operator error!"<<endl;
		return -999;
	}
}

void Moving(int a, char o, int b, int c)
{
	if(calculate(a,o,b)==c)
	{
		cout<<"Already balanced!"<<endl;
		return;
	}
	else
	{
		for(int i=1; i<=N[a].num1; i++)
		{
			if(o=='+')
			{
				if(calculate(N[a].n1[i],'-',b)==c)
				{
					cout<<N[a].n1[i]<<'-'<<b<<'='<<c<<endl;
				}
			}
			for(int j=1; j<=N[b].num_1; j++)
			{
				if(calculate(N[a].n1[i],o,N[b].n_1[j])==c)
				{
					cout<<N[a].n1[i]<<o<<N[b].n_1[j]<<'='<<c<<endl;
					return;
				}
			}
			for(int j=1; j<=N[c].num_1; j++)
			{
				if(calculate(N[a].n1[i],o,b)==N[c].n_1[j])
				{
					cout<<N[a].n1[i]<<o<<b<<'='<<N[c].n_1[j]<<endl;
				}
			}
		}
		for(int i=1; i<=N[a].num_1; i++)
		{
			if(o=='-')
			{
				if(calculate(N[a].n_1[i],'+',b)==c)
				{
					cout<<N[a].n_1[i]<<'+'<<b<<'='<<c<<endl;
				}
			}
			for(int j=1; j<=N[b].num1; j++)
			{
				if(calculate(N[a].n_1[i],o,N[b].n1[j])==c)
				{
					cout<<N[a].n_1[i]<<o<<N[b].n1[j]<<'='<<c<<endl;
				}
			}
			for(int j=1; j<=N[c].num1; j++)
			{
				if(calculate(N[a].n_1[i],o,b)==N[c].n1[j])
				{
					cout<<N[a].n_1[i]<<o<<b<<'='<<N[c].n1[j]<<endl;
				}
			}
		}
		for(int i=1; i<=N[a].num0; i++)
		{
			if(calculate(N[a].n0[i],o,b)==c)
			{
				cout<<N[a].n0[i]<<o<<b<<'='<<c<<endl;
			}
		}
		
		for(int i=1; i<=N[b].num1; i++)
		{
			if(o=='+')
			{
				if(calculate(a,'-',N[b].n1[i])==c)
				{
					cout<<a<<'-'<<N[b].n1[i]<<'='<<c<<endl;
				}
			}
			for(int j=1; j<=N[c].num_1; j++)
			{
				if(calculate(a,o,N[b].n1[i])==N[c].n_1[j])
				{
					cout<<a<<o<<N[b].n1[i]<<'='<<N[c].n_1[j]<<endl;
				}
			}
		}
		for(int i=1; i<=N[b].num_1; i++)
		{
			if(o=='-')
			{
				if(calculate(a,'+',N[b].n_1[i])==c)
				{
					cout<<a<<'+'<<N[b].n_1[i]<<'='<<c<<endl;
				}
			}
			for(int j=1; j<=N[c].num1; j++)
			{
				if(calculate(a,o,N[b].n_1[i])==N[c].n1[j])
				{
					cout<<a<<o<<N[b].n_1[i]<<'='<<N[c].n1[j]<<endl;
				}
			}
		}
		for(int i=1; i<=N[b].num0; i++)
		{
			if(calculate(a,o,N[b].n0[i])==c)
			{
				cout<<a<<o<<N[b].n0[i]<<'='<<c<<endl;
			}
		}
		
		for(int i=1; i<=N[c].num1; i++)
		{
			if(o=='+')
			{
				if(calculate(a,'-',b)==N[c].n1[i])
				{
					cout<<a<<'-'<<b<<'='<<N[c].n1[i]<<endl;
				}
			}
		}
		for(int i=1; i<=N[c].num_1; i++)
		{
			if(o=='-')
			{
				if(calculate(a,'+',b)==N[c].n_1[i])
				{
					cout<<a<<'+'<<b<<'='<<N[c].n_1[i]<<endl;
				}
			}
		}
		for(int i=1; i<=N[c].num0; i++)
		{
			if(calculate(a,o,b)==N[c].n0[i])
			{
				cout<<a<<o<<b<<'='<<N[c].n0[i]<<endl;
			}
		}
	}
	return;
}

int main()
{
	int a, b, c;
	char o;
	cout<<"Input the 1st number:"<<endl;
	cin>>a;
	cout<<"Input the operator:"<<endl;
	cin>>o;
	cout<<"Input the 2nd number:"<<endl;
	cin>>b;
	cout<<"Input the number behind the equal sign:"<<endl;
	cin>>c;
	
	initial();
	if(o!='+'&&o!='-')
	{
		cout<<"Operator error!"<<endl;
		return 0;
	}
	Moving(a,o,b,c);
	
	return 0;
}
```

