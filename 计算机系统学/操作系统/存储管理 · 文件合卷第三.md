### 壹  存储器管理

#### 述：
#####
#####

###### 1. 存储器管理概述：
![|325](OS%20图/OS%20图3-1.png)
                      （图一：存储器体系示意图（存储容量从下到上递减））
· 磁带 -> 光盘 -> 硬盘 -> 固态硬盘 -> 主存 -> cache（高速缓存）-> 寄存器

· *存储器体系*：
	· 快速的、昂贵的 cache
	· 中速的、价格中等的内存
		· 实存（Real memory）
		· 虚存（Virtual memory）
	· 慢速、大容量、低价格的磁盘存储器
· 存储器管理的目的：方便用户使用；提高存储器利用率

· *存储器管理的功能*：
	· <font color="#00ffb0">存储器分配</font>：解决多道程序共享内存问题
	· <font color="#00ffb0">地址转换</font>：研究地址变换方法及地址变换机构
	· <font color="#00ffb0">存储器保护</font>：保证各道程序在内存中互补干涉的运行
	· <font color="#00ffb0">存储器共享</font>：并发执行的进程共享程序和数据
	· <font color="#00ffb0">存储器扩充</font>：实现虚拟存储器

· 存储器保护：
![|500](OS%20图/OS%20图3-2.png)
                          （图二：基址加寄存器实现存储器保护）
· 存储器共享：
	· 允许多个进程共享同一个主存区
	· 既可以是数据区，也可以是程序区

###### 2. 程序的装入与链接：
![|325](OS%20图/OS%20图3-3.png)
                   （图三：C 程序的编译过程：源程序 -> 编译 -> 链接 -> 加载）
![|325](OS%20图/OS%20图3-4.png)
                   （图四：C 程序编译过程中的三个阶段：编译、加载、运行）

· *程序名空间*：程序中各种符号名的集合所限定的空间
· *地址空间*：
	· 地址空间：经编译或链接后目标代码所限定的地址域
	· 相对地址（逻辑地址、虚地址）：地址空间中的各个地址
· *存储空间*：
	· 存储空间：物理存储器中全部物理单元的集合所限定的空间
	· 绝对地址（物理地址、实地址）：存储空间中的各个地址

· *地址重定位*（地址映射、地址变换）：
	· 将地址空间的逻辑地址转换为存储空间的物理地址
	· 定位方式：地址变换时间与技术不同：
		· 静态重定位
		· 动态重定位
![|425](OS%20图/OS%20图3-5.png)
                       （图五：逻辑地址与物理地址的映射（地址重定位））

· *程序的链接*：
	· 链接方式（根据链接时间划分）：
		· 静态链接
		· 装入时动态链接
		· 运行时动态链接
	· <font color="#00ffb0">静态链接</font>：
		· 在程序运行之前，将所有编译生成的目标模块和所需库函数链接成一个完整的装配模块，以后不再拆开
		· 需解决的问题：对相对地址进行修改；变换外部调用符号
	· <font color="#00ffb0">装入时动态链接</font>：
		· 编译后的目标模块，在装入内存时边装入边链接
		· 优点：各目标模块分开存放，便于修改和更新；便于实现对目标模块的共享
	· <font color="#00ffb0">运行时动态链接</font>：
		· 将对某些模块的链接推迟到执行时才进行
		· 执行时未调用的目标模块不会被装入
· 此后不区分何种链接方式，都认为是一个逻辑上的整体

· *程序的装入*：
	· 装入模块的装入方式：
		· 绝对装入方式
		· 可重定位装入方式
		· 动态运行时装入方式
	· <font color="#00ffb0">可重定位装入方式</font>：
		· 多道程序环境下，目标模块的起始地址通常由 0 开始，程序中的其他地址均相对于该起始地址进行计算，采用可重定位装入方式
		· 静态重定位：
			· 在程序装入时，装入程序把用户程序地址空间中的指令和数据的相对地址全部转换成存储空间的绝对地址
		· 转换工作在程序执行前一次完成，不能更改和移动
		· 优点：无需硬件支持，易于实现；为每个进程分配一个连续的存储区
![|375](OS%20图/OS%20图3-6.png)
                                （图六：静态重定位示例）
		· 缺点：进程占有连续的存储区；程序执行期间不允许主存移动；不能共享存储空间
	· <font color="#00ffb0">动态运行时装入方式</font>：
		· 在将程序装入内存后，并不立即把程序地址空间中的相对地址转换为绝对地址，而是将地址转换推迟到程序真正执行时才进行
		· 装入内存后所有地址都仍是相对地址
		· 动态重定位：
			· 由硬件地址转换机构——<font color="#00b0f0">重定位寄存器</font>实现
			· 转换工作在程序执行过程中进行
		· 优点：
			· 执行期间可移动用户程序，移动后只需修改重定位寄存器即可
			· 进程不必占用连续的存储空间
			· 便于共享存储空间
			· 主存利用率高
![|375](OS%20图/OS%20图3-7.png)
                                （图七：动态重定位示例）

###### 3. 分区式存储管理：
1. <font color="#ffc000">固定式分区</font>：
	· 适合多道程序的最简单的存储管理方式
	· 将主存预先划分成几个分区：大小相等 / 大小不等
	· 进程到达时选择一个适合程序要求的空闲区
	· 若没有可用的空闲分区，进程在分区队列中等待（不是没有空闲空间，而是预先规定好的分区不合理，导致这组中进程过多时预先划分的区域没有空间，而其他分区有空闲空间却没划分给这组进程）
	（一个大空间分配给 1 个人，一个小空间分配给 100 人，100 人坐不下会等待，但不会去 1 个人那边空余的非常多空间）
	· 特点：
		· 每个分区设置独立等待队列：
			· 进程按大小排入各队列等待，易造成某个队列拥挤
		· 全部分区设置一个等待队列
	· 实现：设置主存使用情况表描述主存使用情况；内存管理过程
	· 优点：简单、易于实现
	· 缺点：主存利用不充分
![|300](OS%20图/OS%20图3-8.png)
                      （图八：固定式分区用情况描述表描述主存使用情况）
2. <font color="#ffc000">可变式分区</font>：
	· 根据进程的大小动态地划分区域，使分区的大小正好等于进程大小
	· 程序要求运行时，由系统从可用的空闲存储空间划分一大小正好等于进程大小的存储器分配给程序
	· 提高了存储器的使用效率，分配与释放复杂
	· 注意：已经分配空间的程序是不能更改地址的
![|450](OS%20图/OS%20图3-9.png)
                            （图九：可变式分区的简单示例）
	· 问题：分区大小不定；分区数目不定
	· 管理方式：分区说明表（静态表）；空闲区链（链表）
	· 分区说明表：两个 —— 已分配区表，未分配区说明表
		· 分配：从空闲区表中找一个足以容纳该进程的空闲区，若该分区较大，则一分为二，一部分分配给进程，另一部分仍作为空闲区留在空闲区表中；在已分配区表中找一个空表目，填入新分配进程的信息
		· 回收：回收分区登记在未分配区表中；若有相邻接的空闲区，合并后再登记；将该进程占用的已分配区表目置空
![|450](OS%20图/OS%20图3-10.png)
                        （图十：可变式分区在内存分配中的体现）
· 可变式分区的优点：直观、简单
· 可变式分区的缺点：分区个数不定，难以确定分区表长度

· *空闲区链*：
· 将表格信息附加在分区中：
	· 状态信息：0 表示空闲，1 表示已分配
	· 该区的大小（以字或块为单位）
	· 指针：分别指向其上 / 下一分区
![|375](OS%20图/OS%20图3-11.png)
                       （图十一：空闲区链表将表格信息附加在分区中）

· *动态分区分配算法*：
- <font color="#00ffb0">首次适应法</font>：
	- 空闲区按照起始地址的大小从小到大排列
	- 分配：
		- 从链首开始扫描空闲区链，直至找到一个足够大的空闲区
		- 按照进程大小，从分区中划出满足要求的空间分配给请求者，剩余空间仍保留在空闲链中
		- 若无满足要求的分区则分配失败（等待）
	- 优点：
		- 优先利用低址空闲区，保留高址大空闲区
	- 缺点：
		- 低址部分不断被划分，留下许多难以利用的、很小的空闲分区
		- 每次查找均从低址部分开始，增加了查找空闲分区的开销
	- 改进：
		- 循环首次适应算法
- <font color="#00ffb0">最佳适应（best fit）法</font>：
	- 分配：
		- 扫描整个链表，将最接近进程需求量的空闲区分配给进程
	- 缺点：
		- 每次查找整个链表，效率低
		- 浪费更多的存储空间，将主存划分为较多小的、无用的碎片
	- 改进：
		- 空闲区按容量大小从小到大排列
- <font color="#00ffb0">最坏适应（worst fit）法</font>：
	- 分配：
		- 扫描整个链表，直到找到该链中能满足进程要求且为链中最大的空闲区为止
		- 把这个最大空闲区一分为二，一部分分给进程，另一部分仍留在链中
![|450](OS%20图/OS%20图3-12.png)
                          （图十二：几种动态分区分配算法比较）

· 可变式分区的回收方法：
· 若释放区与空闲区相邻接，要进行合并
![|400](OS%20图/OS%20图3-13.png)
                        （图十三：进程 X 终止时邻接的存储区情况）

3. <font color="#ffc000">分区管理的低址重定位</font>：
	· 固定式分区：通常固定分区采用静态重定位，进程运行时使用主存绝对地址
	· 可变式分区：采用动态重定位，进程运行时 CPU 给出的是相对地址
4. <font color="#ffc000">分区管理的存储器保护</font>：
	· 上下限寄存器：
		· 用于静态重定位
		· 下界寄存器内容 <= 访问内存的地址 <= 上界寄存器内容
	· 基址 + 限长寄存器：
		· 用于动态重定位
		· 基址（重定位）寄存器：分区首址
		· 限长寄存器：分区长度
5. <font color="#ffc000">分区管理的优缺点</font>：
	· 优点：
		· 实现了多道程序共享主存
		· 实现分区管理的系统设计相对简单，不需要更多的系统软硬件开销
		· 实现存储保护的手段比较明显
	· 缺点：
		· 主存利用不充分，存在碎片：
			· 内部碎片：存在于进程存储空间内部
			· 外部碎片：存在于整个内存中
			· 解决方法：1. 紧凑化；2. 程序不再占用连续的主存空间
		· 程序地址空间大于存储空间时，程序无法运行，即程序的地址空间受到实际存储空间的限制，无法对主存进行扩充
			· 解决方法：1. 覆盖与交换；2. 虚拟存储器

###### 4. 覆盖与交换技术：
1. <font color="#ffc000">覆盖（Overlay）</font>：
	· 同一主存区可被不同的程序段重复使用
	· 原理：一个程序由若干功能独立的程序段组成，程序运行时，一些程序段不会同时执行，可以共用同一主存区
	· <font color="#00ffb0">覆盖区</font>：可以共享的主存区
	· <font color="#00ffb0">覆盖段</font>：程序执行时不要求同时装入主存的程序段（覆盖）组成一组，叫做覆盖段，并分配同一个主存区（覆盖区）
	· 覆盖结构由用户实现，无需 OS 特殊支持
	· 难点是如何设计覆盖结构
	· 通常用于系统程序的主存管理中
![|400](OS%20图/OS%20图3-14.png)
                            （图十四：覆盖技术的实现图示）
2. <font color="#ffc000">交换</font>：
	· 系统根据需要把主存中暂时不运行的某个（或某些）进程部分或全部移到外存，而把外存中的某个（或某些）进程移到相应的主存区，并使其投入运行
	· 交换的时机：
		· 进程用完时间片或等待输入输出
		· 进程要求扩充存储而得不到满足时
	· 关键：在外存保留副本，每次仅修改变换部分
	· （标准）交换发生在进程间，覆盖发生在进程内
![|375](OS%20图/OS%20图3-15.png)
                            （图十五：交换操作发生在进程间）
![|375](OS%20图/OS%20图3-16.png)
                             （图十六：四个进程交换的示例）
![|375](OS%20图/OS%20图3-17.png)
                            （图十七：利用 page 进行交换）

###### 5. 页式存储管理：

1. **页式管理的实现原理**：
· 页面与物理页框：
	· 物理页框（frame）：
		· 将物理存储空间划分成的大小相等的若干存储块
		· 大小为 $2$ 的整次幂，大小在 $4KB$ 到 $1GB$ 之间
	· 逻辑页面（page）：
		· 将进程的逻辑地址空间划分成的与物理页框大小相同的若干片
	· 为进程分配内存时，以页 / 页框为单位将进程的若干逻辑页分别装入多个可以不相邻接的物理页框中
· 地址计算：
	· 逻辑地址空间的大小是 $2^m$
	· 每一页的大小是 $2^n$ 个逻辑地址单元
	· 页号与页内位移计算公式：
		· 逻辑地址空间中的地址为 $A$
		· 每一页的大小为 $L=2^n$，则：
			· 页号：$P=A\ div\ L$
			· 页内地址：$d=A\ mod\ L$
· 地址结构：
	· 页号（P）：用做页表的索引，包含了每一页在物理内存中的起始地址
	· 页内位移（d）：页号与页内位移各占多少位，与页的大小与主存最大容量有关
	· 地址分离工作由硬件实现
![|400](OS%20图/OS%20图3-18.png)
                            （图十八：页号+页内位移结构）
![|400](OS%20图/OS%20图3-19.png)
                            （图十九：页式管理的实现例题）
· 在图十九中，该进程需要 7 个物理页框，但是 7×1024>6150，说明分页技术会产生内部碎片，并且这个碎片一定会产生在最后一页

· 页表也是存储在内存里的，一个页表占的存储空间大小 = 页表项数（页数）× 每一项占用字节（物理页框号），如果逻辑地址用长度为 $m$ 的二进制数表示，其逻辑页号在前 $m-n$ 位，其页内位移为 $n$ 位，其物理地址的长度是 $k$，则页表项数为 $2^{m-n}$
![|400](OS%20图/OS%20图3-20.png)
                    （图二十：32 字节内存，页面大小为 4 字节分页示例）
· 页表：
	· 记录进程的逻辑页与主存中物理页框的对应关系，实现从页号到物理页框号的地址映射
	· 进程地址空间的*每一页对应一个表目*，指出该逻辑页在主存中的物理页框号
	· 页表存放于*主存*，页表的主存地址与页表长度保存在*进程控制块*中
	· 控制寄存器：
		· 页表基址寄存器（PTBR）：指向页表
		· 页表长度寄存器（PTLR）：页表长度

2. **页式动态地址变换**：
· 变换过程：
	· 将进程的页表始址和页表长度送入控制寄存器中
	· 比较程序计数器内的页号 p 与控制寄存器中的页表长度，若页号小于页表长度则继续，否则产生地址越界，终止程序运行
	· 将程序计数器中的页号 p 与控制寄存器中的页表始址相加，得到该访问操作的页号在页表中的入口地址
	· 以该地址访问页表，获得该页所对应的物理页框号 f
	· 将物理页框号 f 与程序计数器中的页内偏移相拼接，得到该操作所在主存的物理地址：f×L+d
	· 根据这个物理地址，完成指定操作
· 存在的问题：
	· 执行一次访问操作至少要两次访问主存：
		· 访问页表
		· 实现指定操作
![|400](OS%20图/OS%20图3-21.png)
                           （图二十一：页式管理地址变换过程）
![|350](OS%20图/OS%20图3-22.png)
                           （图二十二：页式动态地址变换例题 Ⅰ）
![|350](OS%20图/OS%20图3-23.png)
                           （图二十三：页式动态地址变换例题 Ⅱ）

3. **快表和联想存储器**：
· 快表：为了提高存储速度，在地址变换机构中设置的具有*并行查找能力*的专用高速缓冲寄存器组（32~1024 个寄存器），用来存放页表的一部分
· 快表结构：

| 页号  | 物理页框号 | 访问位 | 状态位 |
| :-- | :---- | :-- | :-- |
| $0$ | $5$   | $1$ | $1$ |
| $1$ | $7$   | $0$ | $1$ |
| ……  | ……    | ……  | ……  |

· 页号：程序当前访问的地址空间的页号
· 物理页框号：该页所对应的主存物理页框号
· 访问位：指示该页最近是否被访问过：
	· 0：未被访问
	· 1：访问过
· 状态位：指示该寄存器是否被占用：
	· 0：空闲
	· 1：占用

· 地址变换过程：
	· 硬件地址转换机构在进行地址变换时，有两个变换过程：
		· 利用快表进行的快速变换过程
		· 利用主存页表进行的正常变换过程
	· 一旦快表中与查找的页号相符合时，则将快表中的物理页框号与 CPU 给出的页内位移相拼接，得到访问主存的绝对地址，结束快表查找工作
	· 若利用快表进行变换时，没有找到要查询的页，则继续正常的转换过程，直到形成访问主存的绝对地址
	· 将从主存页表中取出的物理页框号和 CPU 给出的页号一起*写入快表*中状态位为 0 的一行中
	· 若没有这样的行存在，则写入访问位为 0 的某一行中，并同时置状态位和访问位为 1（置换）
![|425](OS%20图/OS%20图3-24.png)
                      （图二十四：使用快表后的页式管理地址变换过程）
· TLB（Translation Lookaside Buffer）命中率
	· 页号在 TLB 中被查找到的百分比
	· 示例：假设查找 TLB 需要 20 ns，访问内存需要 100 ns，则内存数据访问时间：
		· 页号位于 TLB：20+100=120 ns
		· 页号不在 TLB：20+100+100=220 ns
		· TLB 命中率为 80%：0.8×120+0.2×220=140 ns
		· TLB 命中率为 98%：0.98×120+0.02×220=122 ns

4. **多级页表**：
· 问题提出：
	· 一个具有 32 位地址空间的计算机系统，如果系统的页大小位 $4KB$（$2^{12}$），则一个页表可以包含 $2^{32}/2^{12}=2^{20}$ 个表项，若一个表项占用 $4B$，则每个进程需要 $4MB$ 连续物理地址空间存储页表
· 解决方法：*页表不连续存储*
	· 将页表再分页
![|500](OS%20图/OS%20图3-25.png)
                              （图二十五：将页表再分页）
![|350](OS%20图/OS%20图3-26.png)
                               （图二十六：两级页表结构）
![|350](OS%20图/OS%20图3-27.png)
                          （图二十七：具有两级页表的地址变换机构）
![|350](OS%20图/OS%20图3-28.png)
                             （图二十八：多级分配的示例 Ⅰ）
![|350](OS%20图/OS%20图3-29.png)
                             （图二十九：多级分配的示例 Ⅱ）
![|450](OS%20图/OS%20图3-30.png)
                             （图三十：多级分配的示例 Ⅲ）
![|400](OS%20图/OS%20图3-31.png)
                        （图三十一：64 位逻辑地址的计算机系统）

· 哈希页表：
	· 超过 32 位地址空间的常用方法
	· 哈希表：
		· 以逻辑页号作为哈希值
		· 哈希页表的每一个表项都包括一个链表，链表中的元素哈希为同一个位置
		· 每个元素包含 3 个域
			· 逻辑页号
			· 映射的物理页框号
			· 指向链表下一元素的指针
	· 地址映射：
		 · 逻辑地址中的逻辑页号转换到哈希表中，用逻辑页号与链表中的每一卦元素的第一个域进行比较
			 · 若匹配，则利用该元素的第 2 个域形成物理地址
			 · 若不匹配，则与链表中的下一个节点进行比较，直至找到一个匹配的页号
![|350](OS%20图/OS%20图3-32.png)
                                 （图三十二：哈希页表）
	· 群集页表（clustered page table）：
		· 64 位地址的变换依赖群集页表
		· 类似于哈希，但每个条目指向几页（如 16 页）而不是 1 页
		· 特别适用于*稀疏*地址空间（其中内存引用是分散而不连续的）

· 反向页表（Inverted Page Table）：
	· 向前映射页表（Forward-mapped page table）：
		· 每个进程拥有一个页表，每个逻辑页占据页表一项
	· 不是每个进程都有一个页表并跟踪所有可能的逻辑页，而是跟踪所有物理页
	· 系统中只有一个页表，每个实际的内存页都有一个条目
	· 条目由存储在实际内存中的页的虚拟地址以及拥有该页的进程的信息组成
	· 减少了存储每个页表所需的内存，但增加了发生页引用时搜索表所需的时间
	· 使用哈希表将搜索限制为一个或最多几个页表条目
		· TLB 可以加速访问
![|350](OS%20图/OS%20图3-33.png)
                                （图三十三：反向页表）

5. **页式管理的主存分配**：
· 数据结构：
	· 页表：每个进程一张，用于将页的逻辑地址转换成内存的物理地址
	· 进程控制块：进程的页表在主存的起始地址以及页表长度
	· 存储空间使用情况表：记录存储空间的使用情况；存储分快表 / 位示图
· 存储分块表：
	· 记录存储器中各物理页框的状态
	· 第一项指出当前主存空闲页框总数
	· 第二项是指向第一个空闲页框指针
	· 分配：
		· 检查存储分块表能否满足进程要求
		· 若不能满足，则进程等待
		· 若能满足，由存储分块表的第一项中减去本次分配块数，再由第二项空闲块指针找到所需各块，并为进程建立页表、修改存储分块表第二项的空闲块指针
	· 回收：
		· 将进程占用主存块归还系统，并修改存储分块表的有关各项
![|174](OS%20图/OS%20图3-34.png)
                              （图三十四：存储分块表的示例）
![|425](OS%20图/OS%20图3-35.png)
                            （图三十五：页式管理的存储分配）

· 位示图：
	· 使用一个位向量，磁盘中的每个页框占用其中的一位
	· 表中为 0 的位相应于空闲页框，为 1 的位相应于已被占用的页框
	· 分配：分配主存时，查找位示图中位为 0 的个数能否满足进程的要求；若能满足，则将查到的字节、位转换成主存相应页框号，并将相应的位置 1
	· 回收：释放主存时，系统应将主存页框转换为位示图中的字节、位，并将相应的位置 0
![|191](OS%20图/OS%20图3-36.png)
                                （图三十六：位示图的示例）

6. **页式管理的保护**：
· 越界保护：
	· 页号与页表长度寄存器存放的值进行比较
· 访问保护：
	· 在页表中为每个物理页框设置保护位：
		· 读写保护
		· 有效-无效保护
![|350](OS%20图/OS%20图3-37.png)
                              （图三十七：页式管理的保护）

7. **页式管理的共享**：
![|350](OS%20图/OS%20图3-38.png)
                            （图三十八：页式管理的共享示意）

###### 6. 段式存储管理：

1. **段式管理的实现原理**：
· 分段管理方式的引入：
	· 满足用户（程序员）在编程和使用上多方面的要求
		· 方便编程：逻辑地址由段名和段内偏移决定
		· 信息共享：程序和数据的共享以信息的逻辑单位为基础
· 分段：
	· 按照程序自身的逻辑关系将程序的地址空间划分成的若干部分
	· 每个段都有自己的名字
		· 主程序段 MAIN
		· 子程序段 X
		· 数据段 D
		· 栈段 S
	· 每个段都占有从 0 开始编址的连续地址空间
![|300](OS%20图/OS%20图3-39.png)
                        （图三十九：从逻辑地址空间看段式管理的原理）
· 二位地址空间结构：
	· 段号：内部段号
	· 段内位移
![|400](OS%20图/OS%20图3-40.png)
                             （图四十：二位地址空间结构）
· 段式存储分配以段为单位进行，为程序的每一个分段分配一个连续的主存空间，各段之间可以不连续
![|350](OS%20图/OS%20图3-41.png)
                           （图四十一：分段管理存储分配示意图）
· 段表：
	· 记录进程分段与物理存储空间的对应关系，实现从逻辑分段到物理内存的地址映射
	· 每个逻辑分段对应一个表目，指出该逻辑分段在主存中的起始地址和段的长度
	· 段表存放于主存
	· 段表的主存始址与段表长度：
		· 保存在进程控制块中
	· 控制寄存器：
		· 段表基址寄存器（STBR）：指向段表
		· 段表长度寄存器（STLR）：段表长度
![|400](OS%20图/OS%20图3-42.png)
                               （图四十二：段表示意图）

2. **段式动态地址变换**：
· 把进程的段表始址和段表长度送入控制寄存器中
· 比较逻辑地址（S，W）中的段号 S 与控制寄存器中的段表长度，若 S > 段表长度，则产生*越界中断*；否则将段号 S 与控制寄存器的段表始址相加，形成访问段表相应表项的主存地址
· 访问段表，比较段内位移 W 与相应表项中的段长，若 W > 段长，则产生*越界中断*；否则将该段的起始地址与段内位移相加，形成访问主存的物理地址
![|400](OS%20图/OS%20图3-43.png)
                            （图四十三：段式地址变换过程）
![|400](OS%20图/OS%20图3-44.png)
                            （图四十四：段式动态地址变换）

3. **段式管理的存储保护**：
· 利用控制器的段表长度对段号越界进行第一级保护
· 利用段表中的段长对逻辑地址中的段内位移进行检查，实现第二级保护
· 通过在段表中增加相应的操作方式字段，对相应的段规定读、写、执行是否许可的操作权限，实现第三级保护

4. **段式管理的共享**：
![|350](OS%20图/OS%20图3-45.png)
                             （图四十五：段式管理的共享）

5. **段式管理的主存分配**：
· 类似于可变式分区
	· 首次适应法
	· 最佳适应法
	· 最坏适应法
· 可变式分区管理以进程为单位分配一个连续分区；段式管理以段为单位分配分区，各段之间可以占有不连续的分区
· 存在碎片问题

6. **段式管理与页式管理的比较**：
· *段*是信息的*逻辑单位*，它根据用户需要进行划分，对用户是*可见*的；*页*是信息的*物理单位*，它为了方便管理主存而划分，对用户是*透明*的
· *段式管理*向用户提供的是*二维地址空间*，*页式管理*向用户提供的则是*一维地址*空间，确定其页号和页内偏移由机器硬件实现
· *页*的*大小固定*不变，由系统决定；*段*的*大小不固定*，由其完成的功能决定
· 分段作为信息的逻辑单位，便于进行存储保护和信息共享；分页的存储保护和信息共享则受到限制
· *段式管理*与分区管理一样可能产生*主存碎片*，而页式管理则很好地消除了外部碎片
· 段式管理与页式管理都需要在程序运行前将*全部信息装入主存*，不能充分利用存储器
· 为实现地址变换，段式管理与页式管理都要花费较大的开销

###### 7. 段页式管理：
· 结合分段原理与分页原理
· 先将用户程序分成若干个段，再把每个段分成若干个页，并为每个段赋予一个段名
· 地址结构由三部分构成：段号、页号、页内位移
· 地址变换：
	· 三次访问内存
	· 快表
![|400](OS%20图/OS%20图3-46.png)
                      （图四十六：MULTICS 的段页式管理地址变换过程）

###### 8. 虚拟存储器：

1. **虚拟存储器基本概念**：
· 实存管理技术：
	· 特点：一次性、驻留性
	· 实存管理技术的缺点：
		· 进程请求的内存空间超过内存总容量，进程不能全部装入内存，无法运行
		· 内存容量不足以容纳大进程，只能先运行小进程，大进程等待
· 虚拟存储技术：
	· 虚拟存储器：
		· 具有请求调入功能和置换功能，能从逻辑上对内存容量加以扩充的一种存储器系统
		· 逻辑容量（虚拟内存容量）
		· 运行速度接近于内存速度
		· 特征：多次性、对换性、虚拟性
![|400](OS%20图/OS%20图3-47.png)
                             （图四十七：虚拟存储器示意）
	· 虚拟内存容量：
		· 底层的 Intel 第四代 CPU 架构支持完全的 $64$ 位虚拟和物理地址空间，但现在的（以及可预见的未来的）Core i7 实现支持 $48$ 位虚拟地址空间和 $52$ 位物理地址空间，页大小是 $4KB$
			· Core i7 支持的虚拟内存，$2^{48}B$，物理内存：$2^{52}B$
			· 页表项里有 $40$ 位记录页框号，页表项大小是 $8B$
	· 虚拟存储技术的基础：
		· 局部性原理：1968，Denning P：程序在执行时将呈现出局部性规律，即在一较短时间内，程序的执行仅局限于某个部分；相应地，它所访问的存储空间页局限于某个区域
		· 时间局限性：循环
		· 空间局限性：互斥执行

2. **页式虚拟存储器管理**：
· 实现原理：
	· 页式管理 + 交换技术
	· 将进程信息的副本存放在外存中，并在页表中指出各页对应的外存地址；当进程被调度运行时，先将进程中的较少页装入主存，在执行过程中，访问不在主存的页时，再将其调入
· 页表：
	· 页号
	· 物理页框号
	· 状态位：指示该页是否在主存（0：不在，缺页中断；1：在）
	· 外存地址：指示该页在外存上的地址
	· 访问位：指示该页最近是否被访问过（0：未访问；1：访问）
	· 修改位：指示该页调入主存后是否修改过（0：未修改过；1：修改过）
![|400](OS%20图/OS%20图3-48.png)
         （图四十八：32 位 Windows，页大小 4 KB，页表项 4 字节的页式虚存管理示例）
· 缺页中断处理：
	· 操作系统接到此中断信号后，就调出缺页中断处理程序；如果内存中有空闲页框，则分配给该页，根据页表中给出的外存地址，将新调入页装入内存，并修改页表中相应页表项的状态位及相应的内存页框号，使进程继续运行下去
· 若此时内存中没有空闲页框，则要淘汰某页，若该页在内存期间被修改过，则要将其写回外存
· 由于从外存向主存调入一页需要的时间较长，故在调页过程中应将请求调页的进程设置为阻塞状态，但此时进程的页绝不允许被换出，否则无法装入所需的页
· 该页装入主存后，将等待进程唤醒
· 在产生缺页中断时，一条指令并没有执行完，在操作系统进行缺页中断处理后，应重新执行被中断的指令
![|450](OS%20图/OS%20图3-49.png)
                            （图四十九：缺页中断处理步骤）
![|450](OS%20图/OS%20图3-50.png)
                        （图五十：请求页式管理地址变换过程）

· <font color="#ffc000">页面置换算法</font>：
· 抖动（Thrashing）：刚被淘汰的页面马上又要用，因而又要调入；调入不久再被淘汰，淘汰不久再次装入；如此反复，使整个系统出于频繁地调入调出状态，大大降低系统的处理效率
· 算法假设：
	· 一个进程分配的主存块数固定不变
	· 采用局部淘汰（淘汰一页时，只考虑在本进程内部实施淘汰）
· 算法性能：
	· 进程 $P_i$ 共有 $m$ 页，系统分配给它的主存块为 $n$ 块，$m\textgreater n$
	· 开始时，主存没有装入任何一页信息
	· 如果进程 $P_i$ 在运行中成功访问的次数为 $S$，不成功的访问次数为 $F$（产生缺页中断的次数），则进程执行过程中总的访问次数为 $A=S+F$
	· 进程 $P_i$ 执行过程中的缺页率 $f=\frac{F}{A}$
· 理想调度算法：选择以后不再访问的页或经过很长时间之后才可能访问的页进行淘汰
· 置换算法：
	· 最佳算法（OPT，Optimal）
	· 先进先出算法（FIFO）
	· 最近最久未用算法（LRU，Least Recently Used）
	· 时钟页面置换算法
· 页面序列（$A=12$）：$1,2,3,4,1,2,5,1,2,3,4,5$
![|425](OS%20图/OS%20图3-51.png)
                              （图五十一：最佳置换算法）
![|425](OS%20图/OS%20图3-52.png)
                            （图五十二：先进先出置换算法）
![|425](OS%20图/OS%20图3-53.png)
                           （图五十三：最近最久未用置换算法）

· 页式虚拟存储器管理的硬件实现：
	· 系统设置一个 64 位的硬件计数器 C，每当一条指令饮用后都自动计数
		· 页表的每一项必须含有足够大的字段存放该计数器的值；每次访问主存后，将计数器 C 的值存入刚被访问过的页的相应字段
		· 产生缺页中断时，操作系统查看所有页表，找出计数值最小的页作为最近最少使用的页
	· LFU（Least Frequently Used）与 LRU：
		· 页面序列 $2,1,2,1,2,3,4$
		· $T=10min$，每分钟发生一页调页
![|350](OS%20图/OS%20图3-54.png)
                         （图五十四：LRU 与 LFU 算法的对比）
· 页式虚拟存储器管理的软件实现：
	· 栈式页面置换算法：
		· 主存维护一张运行进程所需页链表
		· 利用栈记录页的使用；正在引用的页放在栈顶，最近最久未用的页放在栈底
		· 为了便于栈中元素移动，可采用双向链
![|400](OS%20图/OS%20图3-55.png)
                           （图五十五：LRU 算法的特性讨论）
· 具有 LRU 算法特性的一类算法，都具有这样的性质：$$M(m,r)\leq M(m+1,r)$$
· 这里 $m$ 随进程分配的主存块而变，$r$ 是引用串的索引；这个公式表明，主存块为 $m+1$ 时，在任何时刻 $t$，存于主存中的一串页面中必然包含有主存块为 $m$ 时存于主存中的各页
· 这种关系对所有的 $m$ 和 $r$ 都成立，它绝不会出现 FIFO 算法中的 Belady 异常

· 时钟（CLOCK）页面置换算法：
	· 将进程所访问的页像时钟一样存放于一个循环链中
	· 设置一个指针指向最早进入主存的页
	· 产生缺页中断时，按照下列原则选择某一页面进行淘汰
		· 检查其访问位，如果为 0，则淘汰该页，新装入的页插入到该位置，指针向前移动一个位置
		· 如果为 1，则将访问位置 0，并将指针前进一个，继续检查页的访问位（第二次机会）
		· 重复该过程，直到找到访问位为 0 的页
![|450](OS%20图/OS%20图3-56.png)
                            （图五十六：时钟页面置换算法 Ⅰ）
![|400](OS%20图/OS%20图3-57.png)
                            （图五十七：时钟页面置换算法 Ⅱ）
![|400](OS%20图/OS%20图3-58.png)
                            （图五十八：时钟页面置换算法 Ⅲ）

3. **页式管理设计中的问题**：
· 确定页面大小：
	· 页面越大，无用程序装入主存就越多，从而使主存浪费严重
	· 页面越小，程序需要的页就越多，页表越大
	· 最佳页尺寸：设进程平均大小为 $s$ 字节，页大小为 $p$ 字节，页表项占 $e$ 字节，则：
		· 进程所需页数近似为 $s/p$ 页
		· 页表占用空间为 $se/p$ 字节
		· 进程内部碎片浪费空间平均为 $p/2$
		· 因此页表和内部碎片引起的系统的总开销为 $se/p+p/2$
		· 页表开销中，页越小，页表越大
		· 内部碎片开销中，页越大，内部碎片越大
		· $\frac{d(\frac{se}{p}+\frac{p}{2})}{dp}=\frac{-se}{p^2}+\frac{1}{2}$
		· 令上式为 $0$，可得最佳页面大小为：$p=\sqrt{2se}$
· 确定最小物理块数：
	· 保证进程正常允许所需的最小物理块数
	· 物理块分配算法：
		· 可变分配
		· 固定分配：
			· 平均分配
			· 按比例分配：
				· 系统中有 $n$ 个进程，每个进程的页面数为 $S_i$，系统中各进程页面数总和为 $S$
				· 系统中可用物理块总数为 $m$，每个进程能分配到的物理块数为 $b_i$，则：$S=\Sigma S_i$，$b_i=\frac{S_i}{S}*m$
			· 按优先权分配
· 页面置换策略：局部置换，全局置换
![|425](OS%20图/OS%20图3-59.png)
                      （图五十九：页面置换策略中的局部置换与全局置换）
· 物理页框分配+页面置换策略：
	· 固定分配局部置换：
		· 为每个进程分配多少个物理块难以确定（太少会频繁产生缺页中断，降低系统吞吐量；太多会使得内存驻留进程减少，可能造成资源空闲，且进程交换时会耗费更多时间）
	· 可变分配局部置换
	· 可变分配全局置换：
		· 有更好的系统吞吐量，易于实现，较为常用
· 调页时机：
	· 预调页：根据空间局部性，将不久之后会被访问的页面预先调入内存（成功率仅有 50%，主要用于进程的首次调入）
	· 请求调页：进程运行时，发现其所访问的程序页面不在内存，请求系统将所需页面调入内存（系统开销大，易于实现；虚拟存储器大多采用此策略）
· 交换区的管理：
	· 交换区是 OS 利用磁盘扩充主存的主要方法
	· 系统使用交换区的方法：用交换区保存进程运行的整个映像，存储分页系统可能被淘汰的页
· 交换空间的设置：
	· 从文件系统中分割一部分空间作为一个大文件使用
	· 占用一个独立的磁盘或磁盘分区
· 抖动与工作集：
	· 产生抖动的原因：同时在系统中运行的进程太多，因此分配给每一个进程的物理块太少，不能满足进程正常运行的基本要求，使得进程运行时频繁出现缺页，从而产生抖动
	· 工作集：理论基础：1968 年由 Denning 提出，基于程序运行时的局部性原理；概念：在某段时间间隔里，进程实际所要访问的页面的集合
	· “工作集”的定义：
		· 进程在时间 $t$ 的工作集为 $w(t,\Delta)$
		· 进程在时间间隔 $(t-\Delta,t)$ 中引用页面的集合
		· 变量 $\Delta$ 为工作集的“窗口尺寸”
		· 实例：$\Delta=10$
![|500](OS%20图/OS%20图3-60.png)
                             （图六十：工作集的定义示意）
![|450](OS%20图/OS%20图3-61.png)
                         （图六十一：引用页序列和窗口大小示例）
	· 抖动的预防：
		· 采用局部置换策略：
			· 限制影响范围
			· 效果不佳，会延长其他进程缺页中断的处理时间
		· 把工作集算法融入到处理机调度中：
			· 当造成处理机利用低的原因是“内存分配中分配的物理块数不够”
		· 工作集页面置换算法：
			· 利用 “$L=S$”准则调节缺页率
			· $L$ 是缺页之间的平均时间，$S$ 为平均缺页服务时间
			· $L>>S$，表示很少发生缺页
			· $L<S$，表示频繁发生缺页
			· $L\approx S$，表示磁盘与处理机均能达到其最大利用率
			· 旋转暂停的进程
· 页面共享：
	· 写时复制：
		· 内存共享技术
		· 当两个进程要读写相同内容的内存时，允许两个进程共享同一物理页框，这些物理页框标记为写时复制页
		· 若两个进程对该页框只读，则二者共享
		· 若某一进程对该页框写，则系统将该物理页框复制到主存的另一物理页框中，并更新该进程的页表指向该物理页框
![|450](OS%20图/OS%20图3-62.png)
                         （图六十二：写时复制技术对页修改时）
· 存储分配方式：
![|450](OS%20图/OS%20图3-63.png)
                        （图六十三：操作系统存储分配方式总览）

###### · --- 本章要点 ---：
- 逻辑地址、物理地址与地址映射
- 静态重定位与动态重定位
- 存储器保护
- 交换与覆盖
- 动态分区存储管理算法
- 分页管理方式
- 分段管理方式
- 段页式管理方式
- 请求分页管理方式
- 最佳置换算法
- 先进先出置换算法
- 最近最久未用置换算法
- 时钟置换算法
- 程序局部性原理
- 工作集


### 贰  文件系统

#### 述：
#####
#####

###### 1. 文件和文件系统：

· 文件的基本概念：
	· 文件是具有符号名和相关信息的集合：源程序，一批数据，各种语言的编译程序、各种编辑程序，银行账目、公司记录等

· 文件的基本特征：
	· 文件的内容为一组信息：分 有结构 和 无结构 两大类
	· 文件具有保存性：长期保存、多次使用
	· 文件可以实现按名存取：每个文件都有唯一的标识符，可以通过该标识符存取文件中的信息，无需了解文件在存储介质上的具体位置

· 文件的分类：
	· 按用途：
		· 系统文件
		· 库文件
		· 应用程序文件
		· 用户文件
	· 按保护方式：
		· 只读文件
		· 读写文件
		· 无保护的文件
	· 按信息流向：
		· 输入文件
		· 输出文件
		· 输入 / 输出文件
	· 按信息保存期限：
		· 临时文件
		· 永久文件
		· 档案文件
	· 按文件所在设备：
		· 硬盘文件
		· 磁带文件
		· 光盘文件
	· UNIX 系统中，按组织和处理方式划分：
		· 普通文件：
			· 系统文件
			· 应用程序文件
			· 库文件
			· 用户的各种文件
		· 目录文件
		· 特殊文件：
			· 由系统中所有输入、输出和输入/输出型设备组成
			· 输入、输出设备：字符型特殊文件
			· 输入/输出型设备：字符块特殊文件

· 文件属性：
	· 文件名（扩展名）
	· 文件标识符
	· 文件类型
	· 文件大小
	· 文件的建立时间
	· 文件的物理信息
	· 文件的保护信息
![|450](OS%20图/OS%20图3-64.png)
                         （图六十四：文件类型、扩展名及其功能）
![|450](OS%20图/OS%20图3-65.png)
                           （图六十五：文件标识符及其含义）
![|291](OS%20图/OS%20图3-66.png)
                        （图六十六：macOS 的一个文件信息窗口示例）

· 文件系统：
	· 为了方便用户使用软件资源，由 OS 提供的管理文件的软件机构
	· 文件系统既包括 OS 中用于管理文件的程序，也包括运行这些程序所需的各种数据结构
	· 一个理想的文件系统应具备的功能：
		· 管理磁盘、磁带等组成的文件存储器
		· 实现用户的按名存取，负责名字空间到存储空间的映射
		· 具有灵活多样的文件结构和存取方法
		· 向用户提供一套使用方便、简单的操作命令
		· 保证文件信息的安全性
		· 便于文件的共享

###### 2. 文件目录项和文件目录结构：

· 文件目录：
	· 文件的说明信息与控制信息
	· 文件目录表：
		· 一张记录所有文件的名字及其存放物理地址的映射表
		· 每个文件占据文件目录表中的一个表项
	· 文件目录项：
		· 文件控制块（FCB）：
			· 文件存在的唯一标识
			· 存放文件的全部控制信息
			· 存放文件名和文件存取位置
![|500](OS%20图/OS%20图3-67.png)
                         （图六十七：文件目录项和文件目录结构）

· 文件控制块（File Control Block，FCB）：
	· 基本信息：
		· 文件名：唯一性
		· 文件类型
		· 文件物理位置：
			· 设备名
			· 文件在外存上的起始盘块号
			· 文件长度：文件占用的盘块数和字节数
	· 文件逻辑结构
	· 文件物理结构
	· 存取控制信息：
		· 文件主的存取权限
		· 其他用户的存取权限
	· 使用信息：
		· 文件的建立时间
		· 上一次的修改时间
		· 当前使用信息
![|212](OS%20图/OS%20图3-68.png)
                           （图六十八：文件控制块（FCB）的结构）

· 文件目录的实现：
	· 线性表：
		· 存储文件名和数据块指针
		· 编程较简单，但运行较费时
		· 缺点：查找文件时需要进行线性搜索
		· 改进：B+ 树 / 红黑树
		· 目录查询技术——线性搜索
	· 哈希表：
		· 使用线性表存储目录，并使用哈希数据结构，并根据文件名进行哈希
		· 优点：减少了目录搜索时间
		· 缺点：冲突问题；哈希表大小固定及哈希函数对大小的依赖性
		· 改进：Chained-overflow 哈希表
![|400](OS%20图/OS%20图3-69.png)
                  （图六十九：线性搜索的示例：查找 /usr/ast/mbox 的步骤）

· Linux 文件目录：
	· 把通常的文件目录项分成简单目录项和索引节点两部分：
		· 简单目录项包含了文件名和索引节点号等，可以提高文件目录的检索速度，其特点是提高了文件目录的检索速度和文件系统的使用效率
		· 文件的管理控制信息存放在索引节点中：系统只保留一个索引节点，就可实现多条路径共享文件，减少信息冗余
![|400](OS%20图/OS%20图3-70.png)
                            （图七十：Linux 的目录项结构）

· Linux 文件类型：
	· 0，不可知
	· 1，普通文件
	· 2，目录文件
	· 3，字符设备文件
	· 4，块设备文件
	· 5，有名管道
	· 6，套接字文件
	· 7，符号链接
· Linux 文件名：
	· name，存放文件名，最多 255 个字符
	· name_len，文件名实际长度
	· 文件名长度不同，但必须是 4 字节的整数倍
	· 不足时，以字符 '\0' 填充
· Linux 目录项长度：至少占 12 个字节
![|400](OS%20图/OS%20图3-71.png)
                    （图七十一：Linux 文件目录操作示例：目录项的删除）

· 目录管理的要求：
	· 实现“按名存取”
	· 提高对目录的检索速度
	· 文件共享
	· 允许文件重名
· 文件目录结构：
	· 一级目录结构
	· 二级目录结构
	· 多级目录结构

· 一级目录结构：
	· 为文件存储器上保存的全部文件建立一张目录表，每个文件在表中占有一项
	· 创建文件 / 删除文件
	· 优点：目录结构管理简单
	· 缺点：不允许文件重名，否则将出现二义性；文件较多时，查找目录耗时太多；限制了对文件的共享
· 二级目录结构：
	· 为每个用户建立独立的目录结构
	· 由一个主文件目录和若干用户文件目录组成
	· 主目录中的目录项记录各用户目录的名字及目录文件所在的磁盘地址
	· 创建新用户：系统为新用户在主文件目录表中找一个空表目，并为其分配一个存放用户文件目录的区域，然后把用户名和该区域的起始地址填写在该对应表目中
	· 创建新文件：用户建立一个新文件时，文件系统先按用户名在主目录中找到相应的文件目录的地址，然后在用户目录表中为其建立一个目录项，填上文件名以及文件的管理和控制信息
	· 访问文件：先按用户名在主目录中找到相应文件目录项（地址信息）；按文件名在用户文件目录中找到文件的相关信息；完成制定的文件操作
	· 删除文件：按用户名在主目录中找到相应文件目录项（地址信息）；按文件名在用户文件目录中找到相应文件目录项，释放文件所占用的块并撤销该目录项；当该用户的文件目录中的文件都被撤销时，将其所占目录表区释放，并将该用户在主目录表中的目录项撤销
	· 优点：解决了文件的重名（用户名 | 文件名）问题和文件共享问题
	· 缺点：增加了系统开销；对用户进行隔离
![|350](OS%20图/OS%20图3-72.png)
                         （图七十二：一级目录结构和二级目录结构）
· 多级目录结构（层次型/树型）：
	· 有一个主目录（又称根目录），在根目录下又有许多子目录和普通文件的记录，每个子目录下依次也有许多子目录或文件作为其目录项
	· 优点：
		· 层次结构清晰，解决重名问题
		· 便于管理和保护
		· 有利于文件分类
		· 提高文件检索速度
	· 缺点：
		· 禁止共享文件和目录
		· 按路径名逐层查找文件，需多次访问磁盘，影响速度
	· 绝对路径：
		· 文件的固有名由根（或主目录）到文件通路上所有目录与该文件的符号名拼接而成
	· 相对路径：
		· 当前目录（工作目录）
		· 文件名由“当前目录”到欲访问文件之间的所有符号名拼接而成
	· 增加目录与删除目录
· 无环图目录结构：
![|350](OS%20图/OS%20图3-73.png)
                              （图七十三：无环图目录结构）

###### 3. 文件操作命令：
- CREATE：创建一个文件
	- 在指定设备上为文件产生一个目录项，分配必要的外存空间，并设置文件相关属性
- DELETE：删除一个文件
	- 当一个文件不再需要时，可用此命令将它删除
	- 文件删除后，其对应的目录项不再存在，并回收该文件占用的存储空间
- READ：读文件
	- 调用者必须指出要读取的文件名，数据大小以及存放数据的主缓冲区地址
- WRITE：写文件
	- 将主存缓冲区中的数据写到指定的文件中，通常是写在当前位置
	- 如果当前位置是文件尾，则文件内容增加，否则将覆盖已存在的数据
- APPEND：追加命令
	- 将数据追加到文件尾
- SEEK：重新定位
	- 将文件的读写指针由当前位置重新定位到指定位置，以便随机存取文件中任意位置的数据
- OPEN：打开文件
	- 进程在使用文件前，必须先打开该文件
	- 打开：将文件的目录项复制到主存一个专门区域，从而建立进程与文件的联系，加快进程对文件的存取速度
- CLOSE：关闭文件
	- 当进程对文件的所有存取完成后，该文件在主存专用区对应的目录项就不再需要，应该将它关闭，以便释放这部分主存空间，让以后需要打开的文件占用
	- 若该目录项调入主存后修改过，还要复制到磁盘
	- 文件关闭后，不能再使用
- GET ATTRIBUTES：获取文件属性
- SET ATTRIBUTES：设置文件属性
- RENAME：更改文件名字
![|450](OS%20图/OS%20图3-74.png)
                         （图七十四：文件的打开和读取操作）

###### 4. 文件逻辑结构和文件访问方法：
· 文件结构：
	· 文件的组织形式
	· 用户使用角度：
		· 文件的逻辑结构：用户如何组织和使用文件
	· 系统实现角度：
		· 文件的物理结构：文件的物理存储
· 文件系统的重要作用：
	· 在用户逻辑文件和相应存储设备上的物理文件之间建立映射，实现二者之间的相互转换
· 文件逻辑结构的基本要求：
	· 能够提高检索速度
	· 便于修改
	· 降低文件的存储费用
· 文件逻辑结构分类：
	· 无结构的字符流
	· 有结构的记录式文件（记录指一组相关联的数据项，包括定长记录和变长记录）
![|450](OS%20图/OS%20图3-75.png)
                         （图七十五：字节流文件和记录式文件）
· 文件访问方法：
	· 顺序访问：
		· 严格按照字符流或记录排列的先后次序依次访问
		· 对文件的每一次访问都在前一次访问的基础上进行
		· 系统设置两个位置指针指向其中要读写的字节位置或记录位置；根据要读写的字节个数或记录长度，系统自动修改指针位置
		· 通常对于变长记录文件采用顺序访问取法
	· 直接访问（随机访问）：
		· 通常针对定长记录文件
		· 在请求对某个文件进行访问时，要指出访问的记录号
	· 按键访问：
		 · 按给定的字段值进行访问
		 · 广泛应用于数据库系统
	· 索引化顺序访问方法：
![|400](OS%20图/OS%20图3-76.png)
                            （图七十六：索引化顺序访问方法）

###### 5. 文件物理结构和文件存储介质：

1. **文件物理结构**：
· 文件的物理结构：
	· 指一个文件在文件存储器上存储方式及其与文件逻辑结构的关系
	· 说明：
		· 物理块：将文件存储器的存储空间或分成若干个大小相等的块
		· 物理文件：文件存储器的文件
		· 物理记录：存放文件记录的物理块
			· 无结构的字符流
			· 记录文件：假定逻辑记录长度的物理块大小相等
![|350](OS%20图/OS%20图3-77.png)
                            （图七十七：文件的磁盘物理结构）
· 文件的物理结构：<font color="#ffc000">连续，链接，索引</font>

· *连续文件*：
	· 把逻辑上连续的文件信息存储在连续的物理块中的一种组织方式
	· 优点：
		· 实现简单：只要记住文件的第一块所在位置及文件包括的块数即可
		· 存取速度快：只要访问一次文件的管理信息，就可以方便地存取到任一记录
	· 缺点：
		· 不灵活：要求在文件创建时，就给出文件的最大长度，文件不能动态扩散
		· 产生碎片：当文件被删除时，文件存储空间可能出现许多小的无法利用的碎块
![|325](OS%20图/OS%20图3-78.png)
                            （图七十八：文件的连续分配示意）
![|400](OS%20图/OS%20图3-79.png)
                        （图七十九：文件连续分配情况下的释放问题）

· *链接文件*：
	· 把逻辑上连续的信息文件存储在不连续的物理块中，存放信息的物理块中另设一个指针指向下一个物理块
	· 文件最后一个物理块的指针通常是 0 或 -1，以指示该块是链尾
	· 优点：
		· 提高磁盘空间利用率，不存在外部碎片问题
		· 有利于文件插入和删除
		· 有利于文件动态扩充
	· 缺点：
		· 链接指针需要额外空间
		· 不利于随机存取
	· 改进：
		· 把指针字从文件的各物理块中取出，放在一个表中，此表叫做盘文件映射表
		· MS-DOS 就使用这种方式分配和管理磁盘空间，并将该表叫做*文件分配表 FAT*
		· 优点：既能方便地实现顺序存取，而且也很容易实现随机存取
		· 缺点：不缓存 FAT 将花费大量磁头寻道时间；缓存 FAT 则系统工作期间整个表必须在主存，占用内存太多
![|325](OS%20图/OS%20图3-80.png)
                            （图八十：文件的连接分配示意）
![|325](OS%20图/OS%20图3-81.png)
                           （图八十一：文件分配表 FAT 示意）

· <font color="#ffc000">示例</font>：假定磁盘块大小为 1KB，磁盘空间的管理采用文件分配表 FAT，对一个 512MB 的硬盘，需要占用多少磁盘空间？
· <font color="#00ffb0">解</font>：磁盘块大小为 1KB 时，该盘可划分的盘块数为 512MB÷1KB=512K 块；512K 块要用 19 位二进制位表示，也即一个盘块号要用 19 位才能表示出来；19÷8≈2.5B，即一个表项占用 2.5B；所以占用的磁盘块为：1280KB/1KB=1280

· *索引文件*：
	· 在文件目录表中为每个文件保留一个索引表块号，该索引块指出文件的逻辑块与物理块的映射关系
	· 优点：
		· 允许文件动态修改，增加了使用的灵活性
		· 允许用户按照要求，直接对文件进行随机存取
	· 缺点：
		· 索引表要占用额外空间
		· 降低了文件存取速度（至少需要访问存储器两次，一次访问索引表，一次访问文件信息）
	· 多级索引
	· 混合索引
![|325](OS%20图/OS%20图3-82.png)
                            （图八十二：文件的索引分配示意）
![|325](OS%20图/OS%20图3-83.png)
                             （图八十三：文件的多级索引）
![|325](OS%20图/OS%20图3-84.png)
                         （图八十四：UNIX 系统的混合索引结构）
![|400](OS%20图/OS%20图3-85.png)
                        （图八十五：NUIX 系统 Ext2 文集卷结构）
· UNIX 系统的混合索引结构：
	· 索引表：是一个有 15 个元素的数组，每个元素占 4B
	· 数组的 15 个元素有 4 种类型：
		· 最初的 12 个元素是直接索引项，给出文件最初的 12 个逻辑块号对应的物理块号
		· 索引 12 是一次间接索引块，对应的文件逻辑块号从 12 到 (b/4)+11，b 是盘块大小
		· 索引 13 是二次间接索引块，对应的文件逻辑块号从 (b/4)+12 到 (b/4)^2+(b/4)+11
		· 索引 14 是三次间接索引块，对应的文件逻辑块号从 (b/4)^2+(b/4)+12 到 (b+4)^3+(b/4)^2+(b/4)+11
	· 符号链接文件：
		· 如果文件路径名小于 60 个字符，直接存放在 `i_block[]` 中
		· 如果大于 60 个字符，需要一个单独的数据块
	· 设备文件、管道文件、套接字文件：
		· 所有必要信息都存放在索引节点中，不需要额外的数据块

2. **文件存储设备**：
· 文件存储设备：
	· 磁带：顺序存取设备
	· 磁盘、光盘：直接存取设备
	· 特点：存储容量大，存取速度高，以块为单位进行存取访问
![|400](OS%20图/OS%20图3-86.png)
                 （图八十六：文件存取设备、存取方法以及物理结构之间的关系）
· 文件存储介质的主要参数：容量、物理记录尺寸、可拆卸性、潜在时间、寻找时间、传输速度

· DOS 文集卷的结构：
	· 硬盘低级格式化：
		· 将磁盘划分成若干磁道、扇区，有生产厂家完成
		· 扇区的头标记录其柱面号、磁头号和扇区号
	· 硬盘分区（FDISK 命令）：
		· 硬盘主引导扇区：硬盘的 0 面 0 道 1 扇区，属于整个硬盘而不属于某个独立的分区
	· 分区格式化（FORMAT 命令）：
		· 对分区进行具体数据组织，即制作文件系统
	· 硬盘主引导扇区：
		· 硬盘主引导程序：位于该扇区 0-1BDH 处
		· 硬盘分区表 DPT：位于该扇区 1BEH - 1FDH 处：
			· 每个分区表占用 16B，共有 4 个分区表
			· 16B 意义如下：0 为自举标志（80H 为可引导分区，00H 为不可引导分区）；1-3 是分区的起始地址（磁头号-扇区号-柱面号）；4 是分区类型（07H 为 NTFS 分区）；5-7 是分区的结束地址；8-11 是分区首扇区的绝对扇区号；12-15 是分区占用的总扇区数
		· 主引导扇区的有效标志：位于该扇区 1FEH - 1FFH 处，固定值为 AA55H
	· 分区规范规定：
		· 一个硬盘可以有多个主分区，但最多只能有一个扩展分区
		· 一个扩展分区可以划分为多个逻辑分区，所以一个硬盘最多只能划为 4 个主分区或者 3 个主分区和一个扩展分区
		· 扩展分区只作为数据盘使用
	· DOS 卷的组成：
		· 引导或保留扇区
		· 文件分配表 1 / 文件分配表 2
		· 根目录区
		· 文件数据区

###### 6. 文件存储器存储空间管理：
· 文件存储器存储空间的基本分配单位为磁盘块/簇
· <font color="#00ffb0">常用的管理方法</font>：
	· 空白文件目录
	· 空闲块链表
	· 位映像表（bit map）或位示图

· *空白文件目录*：
	· 空白文件：
		· 一个连续未用的空闲盘块区
	· 空白文件目录：
		· 为所有空白文件建立一张表，用来记录整个文件存储器的空闲未用空间，每个空白文件占用其中一个标目
	· 适合于文件的静态分配（连续分配）
	· 存储空间的分配与回收：

| 第一个物理块号 | 空白块个数 |
| :------ | :---- |
| 15      | 4     |
| 23      | 10    |
| …       | …     |

· 空白块链表：
	· 适合文件动态分配
	· 将所有空闲块链接成一个链，在主存保留一个链头指针
	· 存储分配与回收：
		· 直接从链头取出相应数量的空闲块分配
		· 释放的空闲块依次放入链头
	· 优点：
		· 管理简单
	· 缺点：
		· 工作效率较低，分配和释放空闲块时要多次访问磁盘，读写几个盘块才能完成对链的修改工作
![|250](OS%20图/OS%20图3-87.png)
                               （图八十七：空白块链表示意）

· 成组空闲块链表：
	· 利用盘上的空闲块管理空闲块
	· 每个磁盘块记录尽可能多的空闲块而组成一组，各组之间也用链指针链在一起，在主存保留该链表的链头指针
	· 存储分配：
		· 将链头指针所指的组块读入主存，从中找到一个空闲块进行分配；当未满足分配要求时，再从链中将记录下一组空闲块的盘块读入内存，再进行分配
	· 回收：
		· 将释放的盘块记录在主存的组盘块中即可；若该块已满，除将该块内容写回磁盘外，可用刚释放块记录其他要释放块，并将其放到链头即可
	· 使用结构：连续结构、链接结构、索引结构
![|400](OS%20图/OS%20图3-88.png)
                            （图八十八：空闲块成组链表示意）

· 位映像表（位示图 Bti Vector）：
	· 适合文件静态和动态分配的最简单方法
	· 使用一个位向量，磁盘中的每个块占用其中的一位
	· 表中为 0 的位相应于空闲块，为 1 的位相应于已被占用的块
	· 优点：
		· 比较容易找到一个或几个连续的空白块
		· 尺寸固定，对于小磁盘，位映像表可以保存在主存中，从而可高速地实现文件的分配和回收工作
	· 转换工作：
		· 将位映像表中的字位号转换成相应盘的物理地址（即磁头号、磁道号和扇区号）
			· 磁盘的相对块号=字节号×n+位号
		· 反转换：
			· 字节号=相对块号/n（商）
			· 位号=相对块号%n（余数）

###### 7. 文件共享与保护：
· 文件共享：
	· 允许多个用户共同使用一个文件
	· 既节省外存空间，又能减少 I/O 信息量和主存中文件的副本
· 文件保护：
	· 防止数据丢失和被无权使用的用户窃取
· 文件存取控制：
	· 一个用户对其文件所做的“谁能使用和如何使用”的规定，主要对文件共享加以限制

1. **文件共享**：
	· 基于索引节点的共享（链接计数）：
		· 索引节点：存放文件的物理地址和文件的属性等信息
		· FCB：存放文件名及指向索引节点的指针
		· 链接计数：
			· 存放在索引节点中
			· 记录链接到本索引节点的用户数目
		· 共享方式：
![|375](OS%20图/OS%20图3-89.png)
                        （图八十九：基于索引结点的文件共享示例图）
	· 基于符号链的共享：
		· 由系统创建一个 LINK 类型的新文件，新文件中只包含被链接文件的路径名
		· 只有文件主拥有指向被共享文件索引结点的指针，其他用户只拥有路径
		· 文件拥有者删除共享文件后，其他用户试图通过符号链访问该共享文件将失败
		· 优点：可以链接任意文件
		· 缺点：耗费磁盘空间，增加启动磁盘的频率
![|280](OS%20图/OS%20图3-90.png)
                            （图九十：基于符号链的文件共享）
![|350](OS%20图/OS%20图3-91.png)
                   （图九十一：基于符号链的文件共享选择题例题）

2. **文件保护**：
	· 防止文件的丢失和破坏：
		· 解决方法：复制 / 恢复：
			· 周期性的全量转存
			· 增量转储
	· 防止其他用户对文件的有意破坏或窃取：
		· 增设防护措施：
			· 防止由计算机病毒引起的文件破坏
			· 用户的鉴别——口令
			· 对文件加密
			· 物理鉴定

3. **文件的存取控制**：
	· 防止核准的用户误用文件和未核准的用户存取文件
	· 文件目录中有关文件存取控制信息部分规定了各类用户对各个文件的存取权限
	· 存取控制方法：
		· 保护域
		· 存取控制表

· 保护域：
	· 规定了进程对一组对象的存取权限
	· 一个域是一组对象，存取权限)偶对，每一个偶对说明一个对象和允许对其施加的一组操作
	· 一个对象可以在多个保护域中
![|500](OS%20图/OS%20图3-92.png)
                       （图九十二：文件的存取控制——保护域法）

· 存取控制矩阵：
![|400](OS%20图/OS%20图3-93.png)
                       （图九十三：文件的存取控制——存取访问矩阵）

###### 8. 文件系统结构：
![|180](OS%20图/OS%20图3-94.png)
                             （图九十四：文件系统组织结构）
· 文件系统是用户和外存设备之间的接口
· 文件系统的层次结构：
	· 应用程序接口
	· 逻辑文件系统
	· 文件组织模块
	· 基本文件系统
	· I/O 调度及控制模块
· 应用程序接口
	· 检查由用户提供的命令句法的正确性和参数的合法性
· 逻辑文件系统
	· 复制目录的管理和维护，按照命令给定的文件名查找目录
	· 创建文件：增加目录项
	· 打开文件：检查各级目录，找到相应的目录项
	· 读/写文件：检查文件是否已经以读/写的方式打开
· 文件组织模块：
	· 负责将文件的读/写位置转换成文件中的相对块号，进而转换成在存储器中的物理块号
	· 管理磁盘空闲空间
	· 将上层传下来的命令转换成对基本文件系统的调用
· 基本文件系统：
	· 将上层传下来的命令和物理块转换成对设备驱动程序的调用
· I/O 调度和控制模块：
	· 由设备驱动和中断处理模块组成
	· 将上层传来的命令转换成硬件设备的专用 I/O 指令和设备地址，控制设备完成与主存之间的信息传输
	· 负责多个读/写命令的排队和调度
![|600](OS%20图/OS%20图3-95.png)
                      （图九十五：文件系统不同层次的工作协同）

###### 9. 存储器映射文件：
· 允许进程分配虚存的一部分地址空间，将磁盘商的一个文件映射到该控件
· 对文件块的存取通过访问虚存的一个也实现，当访问的页不在主存时，产生缺页中断，将其读入主存
· 当需要对存储器映射文件存取时，才实际传输文件数据
· OS 提供映射文件的系统调用
![|450](OS%20图/OS%20图3-96.png)
                       （图九十六：利用存储器映射文件实现文件共享）
![|400](OS%20图/OS%20图3-97.png)
                              （图九十七：存储器映射文件）

###### · --- 本章要点 ---：
- 文件与文件系统
- 文件目录与文件目录结构
- 文件目录项 / 文件控制块
- 文件逻辑结构和文件访问方法
- 文件物理结构
- 文件存储空间管理
- 文件共享
- 文件保护

