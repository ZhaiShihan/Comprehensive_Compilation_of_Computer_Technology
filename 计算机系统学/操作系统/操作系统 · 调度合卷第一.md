### 壹  操作系统概论

#### 述：
##### 人间清闲何处觅？风雨将息，澜涛聚，一波平又起。
#####     辗转乱意，更漏扰心悸，滴滴。
##### 忧思隐隐几时去？心绪怎比，问春江，一潮断又续。
#####     知音无觅，茫茫海天碧，凄凄。

###### 1. 操作系统的定义：

1. **计算机系统的组成**：
![|400](OS%20图/OS%20图1-1.png)
                           （图一：计算机系统组成的抽象视图）

2. **操作系统的作用**：
· 用户角度：作为用户与计算机硬件系统之间的接口，其设计目标为：有效性、方便性
· 计算机系统设计者角度：作为计算机系统资源的管理者，其设计目标为：提高资源利用率

3. **操作系统的定义**：
· 操作系统是计算机系统中的一个系统软件，是一些程序模块的集合
· 它们能以尽量有效、合理的方式组织和管理计算机的软、硬件资源，合理地组织计算机的工作流程，控制程序的执行并向用户提供各种服务功能，使得用户能够灵活、方便、有效地使用计算机，使整个计算机系统能高效地运行（计算机与用户间的接口）
· “在计算机上始终运行的一个程序”是内核，它是操作系统的一部分
· 其他的一切要么是系统程序（随操作系统一起提供，但不是内核的一部分），要么是应用程序，所有与操作系统无关的程序
· 今天用于通用和移动计算的操作系统还包括中间件（middleware，一组软件框架，为应用程序开发人员提供额外的服务，如数据库、多媒体、图形）

###### 2. 操作系统的形成与发展：

1. **无操作系统的计算机系统**：
· 程序员直接使用计算机硬件系统，效率低下
· 单用户独占全机
· CPU 等待人工操作：人工负责输入输出、计算机的调度、编排作业的运行顺序

2. **单道批处理操作系统**：
· 以*常驻内存的监控程序*代替人工调度和作业安排，减少人工干预和等待时间，加快作业运行速度
· 硬件结构：
	· 早期联机批处理：作业的输入、计算和输出都在 CPU 控制下进行，CPU 利用率低
	（输入输出的工作额外耽误 CPU 处理任务的进程）
	· 早期脱机批处理：小型卫星机控制外部设备的输入和输出
![|400](OS%20图/OS%20图1-2.png)
                （图二：早期联机批处理和早期脱机批处理在输入输出上的处理方式）
· 单道批处理系统的优点：
	· 系统自动化程度高、吞吐量大、资源利用率高
	· 减少了 CPU 的空闲时间
	· 提高了 I/O 速度
· 单道批处理的缺点：
	· CPU 与外部设备串行（CPU 在外部设备上耽搁时间）
	· 作业周转时间长，用户无法实现对作业的控制

3. **多道批处理操作系统**：
· 多道程序设计的引入：CPU 与外部设备并行执行，提高 CPU 利用率
· 在内存中同时存放若干道程序，使之在系统中同时处于交叉运行状态
· 特点：内存多道，宏观上并行（不同的作业分别在 CPU 和外部设备上执行），微观上串行（在 CPU 上交叉运行（单 CPU 时，下面不特殊强调则默认））
![|400](OS%20图/OS%20图1-3.png)
                           （图三：单道程序与多道程序示意图）
· 多道批处理操作系统能够提高 CPU 的利用率，充分发挥系统设备的并行性（程序之间并发执行、CPU 与设备之间并行、设备与设备之间并行）

· 单道程序设计示例：主存中有一道程序，读写一个记录各需 0.0015s，处理一个记录（执行 100 条指令）需要 0.0001s，则 CPU 利用率为多少？
· 0.0001 /（0.0015 + 0.0001 + 0.0015）≈ 3.2%

· 多道程序设计示例：若一个计算机系统有 256 KB 内存（不包含 OS），1 个磁盘，1 个终端和 1 台打印机；内存中装有的 3 个作业对资源的使用情况如下：
![|450](OS%20图/OS%20图1-4.png)
                    （图四：多道程序设计实例的 3 个作业对资源使用情况）
· 如果采用单道批处理，则：
	· 作业 1 运行 5 分钟
	· 作业 2 等待 5 分钟，运行 15 分钟
	· 作业 3 等待 20 分钟，运行 10 分钟
	· 总用时 30 分钟
· 如果采用多道批处理，则：
	· 作业 1 在 CPU 中运行 5 分钟
	· 作业 2 无需等待直接进行 I/O 任务 15 分钟
	· 作业 3 无需等待直接进行 I/O 任务 10 分钟
	· 三个作业同时装入主存，由于几乎不同时使用同类资源，在 15 分钟内将全部完成
· 单道/多道批处理程序设计方式下的资源利用率：
![|450](OS%20图/OS%20图1-5.png)
                         （图五：单道/多道程序设计方式下的资源利用率）

· 衡量批处理系统的性能指标：
	1. 资源利用率：给定时间内系统中某一资源（存储器、CPU、外设等）实际使用时间所占比率
	2. 吞吐量：单位时间内系统所处理的信息量，通常以每小时或每天所处理的作业个数进行度量
	3. 周转时间：从作业进入系统到作业退出系统（即完成）所用的时间
	4. 平均周转时间：系统运行的多个作业的周转时间的平均值

· 多道批处理系统的特点：
	· 有效地提高了系统资源的利用效率
	· 提高了系统的吞吐量
	· 用户与作业之间无法交互
	· 作业平均周转时间较长
	· 适合处理计算量大的成熟的作业

· 批处理操作系统的典型系统：
	· <font color="#ffc000">IBM OS/360</font>：首次将操作系统与计算机相分离，从专用走向通用的操作系统

· 批处理系统的缺点：
	· 用户不能直接控制作业运行
	· 作业周转时间太长

4. **分时与多任务操作系统**：
· 产生分时系统的原因：用户需求（交互+响应）
· 分时概念：多个用户分时使用 CPU 时间，即将 CPU 的单位时间划分成若干时间段（每个时间段称为一个<font color="#ffc000">时间片</font>），各用户按时间片轮流占用 CPU

· 分时系统的特点：<font color="#ffc000">同时性</font>、<font color="#ffc000">独立性</font>、<font color="#ffc000">交互性</font>、<font color="#ffc000">及时性</font>（响应时间为 2-3 s）
· <font color="#ff337d">口诀</font>：<font color="#00ffb0">“同读交集”</font>
· 响应时间是衡量分时系统的主要指标，影响响应时间的因素：用户数目，时间片

· 批处理系统与分时系统对比：

| 批处理系统            | 分时系统         |
| :--------------- | :----------- |
| 处理对象为作业          | 处理对象为作业      |
| 目标是提高系统资源利用率     | 目标是对用户请求快速响应 |
| 适用于比较成熟的大型作业     | 适用于短小作业      |
| 可在后台执行，不需要用户频繁干预 | 终端键入命令       |

· 分时操作系统的典型系统：
· 第一个分时系统 <font color="#ffc000">CTSS</font>（Compatible Time Sharing System）
· 典型的具有重要意义的分时系统 <font color="#ffc000">MULTICS</font>（Multiplexed Information and Computing System）
· <font color="#ffc000">UNIX</font> / <font color="#ffc000">LINUX</font>
![](OS%20图/OS%20图1-6.png)
（图六：分时与多任务操作系统的演进）

· <font color="#ffc000">DOS</font> / <font color="#ffc000">Windows</font>
· <font color="#ffc000">macOS</font>
![](OS%20图/OS%20图1-7.png)
（图七：图形化接口操作系统的历史进程）

5. **实时系统**：
· 实时概念：系统对外部特定输入信号的响应时间足以控制发出实时信号的设备
· 实时系统分类：
	· 应用需求：实时控制系统 / 实时信息处理系统
	· 实时任务的截止时间：硬实时 / 软实时

· 实时系统的特点：实时性、可靠性、可确定性
· 实时系统适合于一些不强调资源利用效率的专用系统
· 实时系统以数据或信息作为处理对象

---

6. **嵌入式操作系统**：
· 嵌入式操作系统：
	· 以应用为中心，以计算机技术为基础，软件可裁剪的专用计算机系统
	· 基本都是实时操作系统，只要满足实际需要的有限功能，如任务调度、同步与通信、主存管理、时钟管理等
	· 特点：软件要求固化存储，高质量、高可靠性、高实时性
	· 典型系统：Linux，FreeRTOS

7. **智能移动终端操作系统**：
· 智能移动终端操作系统：
	· 在受限的计算能力上提供丰富的用户体验
	· 在受限的供电能力上改善系统的能源效率
	· 在存储大量用户敏感信息场景下保证用户信息的隐私和安全
	· 典型系统：Android、iOS、Harmony

8. **分布式系统**：
· 分布式系统的定义：
	说法一：分布式系统是一组独立计算机的集合，在用户看来是一个统一的系统
	说法二：分布式系统是指位于联网计算机上的硬件或软件组件系统，执行通信和协作功能

9. **国产操作系统**：
· <font color="#00ffb0">启蒙阶段</font>：
	· 国产操作系统主要以概念学习与初步尝试为主，停留在实验室阶段
	· 1983 年 8 月底，电子工业部 6 所，中国第一款自主研发的操作系统 CCDOS
	· CCDOS 的基础是微软的 DOS，在中国 PC 发展史上有程碑式的意义
	· “八五”计划提出打造我国自主版权操作系统，制定了以 UNIX 为技术路线的计划
	· 在 1989 年，中软开发了中国第一款通用操作系统 COSIX1.0，之后在 1994-1995 年推出 COSIX V2.0 操作系统
· <font color="#00ffb0">发展阶段</font>：
	· 国产操作系统渐渐步入实用化阶段
	· 1999 年 4 月 8 日，中国第一款基于 Linux/Fedora 的国产操作系统 Xteam Linux 1.0 发布，开启了新阶段的操作系统国产化之路；蓝点、红旗、中软三足鼎立，分别推出 Linux 产品：
		· 1999 年 7 月，蓝点（BluePoint） Linux 中文版（预览版）横空出世
		· 1999 年 8 月，以中科院院士倪光南、中科院软件研究所副所长孙玉芳为首的一批科学家，推出国产操作系统—红旗 Linux
		· 1999年 9 月，中国软件总公司第一个中文 Linux 版本发布
	· 1999 年也称为基于 Linux 内核的国产操作系统元年
· <font color="#00ffb0">壮大阶段</font>：
	· 更多成熟的国产操作系统诞生
	· 2001 年，国家 863 计划重大攻关科研项目支持的银河麒麟（Kylin）操作系统诞生，但体验感较差
	· 2006 年 12 月 4 日，中国科学技术部宣布，研制成功当时中国通过认证的安全等级最高、拥有自主知识产权的操作系统——“银河麒麟”服务器操作系统，成为国产操作系统发展中的重要里程碑
	· 2010 年 12 月，民用“中标 Linux”与“银河麒麟”正式在上海合并为中标麒麟 Neokylin；中标麒麟系统在我国国防、航天、电力、能源、政务等众多重要行业得到广泛应用，并多年成为我国 Linux 市场占有率第一的操作系统
	· 2010 年，华为在公司内部发布服务器操作系统 EulerOS，开始在公司内部的云产品及 ICT 产品规模化使用
· <font color="#00ffb0">攻坚阶段</font>：
	· 国产操作系统经历多代技术迭代，软件生态持续壮大
	· Deepin 深度操作系统：累计下载超过 8000 万次，成为中国民用市场最为成功的本土化桌面操作系统之一
	· UOS 是由统信软件开发的一款基于 Linux 内核的操作系统，可以说其脱胎于深度操作系统，主要分为统一桌面操作系统和统一服务器操作系统
	· OpenEuler 是面向数字基础设施的操作系统，是华为公司基于 CentOS 制作的 Linux 发行版，支持服务器、云计算、边缘计算、嵌入式等应用场景，支持多样性计算,致力于提供安全、稳定、易用的操作系统
	· OpenHarmony

· 华为鸿蒙系操作系统 HarmonyOS：
	· 华为自主设计研发的国产操作系统
	· 是一款全新的面向未来、面向全场景的分布式操作系统
	· 创造一个超级虚拟终端互联的世界，将人、设备、场景有机地联系在一起，将消费者在全场景生活中接触的多种智能终端实现极速发现、极速连接、硬件互助、资源共享，用合适的设备提供场景体验
	· 2019 年 8 月 9 日，华为开发者大会上，HarmonyOS 1.0 正式 面世，是一款全新的面向全场景的分布式OS（宣布开源）
	· 2020 年 9 月 10 日，华为正式发布 HarmonyOS 2.0 商用版本，成功在智能手机、平板电脑和智 能穿戴设备等多个设备上首次应用，实现了 “1+8+N” 全场景战略
	· 2021 年 9 月 23 日晚间，华为官宣鸿蒙系统升级用户已经突破 1.2 亿，平均每天超 100 万用户升级鸿蒙，已经成为迄今全球用户增长速度最快的移动操作系统
	· 2022 年 7 月 27 日，华为正式发布鸿蒙3（HarmonyOS 3）操作系统
	· 2023 年 8 月 4 日，华为终端 BG CEO 余承东在华为终端开发者大会上正式宣布，华为鸿蒙 4（HarmonyOS 4）操作系统正式发布
	· 2023 年 8 月 4 日，华为公司自研操作系统 HarmonyOS NEXT，是鸿蒙抛弃 Linux 内核及安卓开放源码项目等代码后的首个大版本，不再兼容安卓应用

· HarmonyOS 与 OpenHarmony
· 开放原子开源基金会（Openatom Foundation）
	· 中国第一家开源基金会，旨在推动全球范围科技与产业的发展
	· 该基金会的成立标志着中国在开源领域取得了重要进展，并得到了多家龙头科技企业的联合发起支持
	· 开源鸿蒙项目是开放原子开源基金会正在孵化的项目之一；在这个项目中，华为将 HarmonyOS 的基础能力捐赠给了开源基金会，形成了OpenHarmony 的初始版本；而 HarmonyOS 则是基于 OpenHarmony 的首个商业发行版本
![|500](OS%20图/OS%20图1-8.png)
               （图八：国家首个开放原子开源基金会的 OpenHarmony 开源项目）
![|500](OS%20图/OS%20图1-9.png)
                        （图九：OpenHarmony 的发展历程）
![|600](OS%20图/OS%20图1-10.png)
                          （图十：OpenHarmony 的架构）
· OpenHarmony 架构：
	· 内核层：多内核设计内核子系统 + 驱动子系统系统
	· 服务层：HarmonyOS 的核心能力集合为应用系统开发提供了服务调用功能
	· 框架层：为 HarmonyOS 的应用开发提供了不同语言程序调用的接口
· OpenHarmony 特点：
	· 分布式架构：多设备之间的连接和协同工作
	· 统一开发平台：提供统一开发平台与工具，简化应用开发的流程
	· 高效性能：支持异构多核技术，充分利用多核处理器的性能优势
	· 面向全场景：适用多种终端设备，提供流畅的全场景体验
	· 保护安全隐私：采用安全内核、安全通信、安全存储，保护安全隐私
![|450](OS%20图/OS%20图1-11.png)
                       （图十一：OpenHarmony 三大核心特性）
A. 一次开发，多端部署：
	· 提供了用户程序框架、Ability 框架以及 UI 框架，在不同设备间迁移，并完成自适应布局实现
	· 同一应用一次开发，多端部署
	· 开发者只需关注业务逻辑，提升代码复用率
B. 统一OS，弹性部署：
	· 通过组件化和小型化等设计方法，支持多种终端设备按需弹性部署，能够适配不同类别的硬件资源和功能需求
	· 支撑通过编译链关系去自动生成组件化的依赖关系，形成组件树依赖图，支撑产品系统的便捷开发，降低硬件设备的开发门槛
C. 分布式安全：
	· 确保正确的人、用正确的设备、正确使用数据
	· 当用户进行解锁、付款、登陆等行为时系统会主动拉出认证请求，并通过分布式技术可信互联能力，协同身份认证确保正确的人
	· 能够把手机的内核级安全能力扩展到其他终端，进而提升全场景设备的安全性，通过设备能力互助，共同抵御攻击，保障智能家居网络安全
	· 通过定义数据和设备的安全级别，对数据和设备都进行分类分级保护，确保数据流通安全可信

10. **操作系统的发展趋势**：
· 操作系统与网络高度融合：端、边、云的 OS 架构和关键技术将越来越趋同
· 一种设备类型一个 OS 的情况将难以为继：统一 OS 将装载在各种形态的硬件设备商，OS 不但与硬件充分解耦，与生态和应用充分解耦，其自身也将充分解耦
· OS 可以调度所有连接在一起的硬件资源，将彻底推动 OS 计算调度机制、存储层次的改变
· OS 将成为物理世界与数字世界融合的底座

###### 3. 操作系统的基本特性：

· **并发性**：两个或多个事件在*同一时间间隔*内发生，它们都已经被启动执行，而且都还没有完成执行
（并行性：两个或多个事件在同一时刻发生）
· **共享性**：互斥共享（同学们共享一间教室，但不共享一个座位）
· **虚拟性**
· **异步性**

###### 4. 操作系统的主要功能：

· **处理机管理**：进程控制 / 进程同步 / 进程通信 / 进程调度
· **存储器管理**：内存分配 / 内存保护 / 地址映射 / 内存扩充
· **文件管理**：文件存储空间的管理 / 目录管理 / 文件的读写管理和保护
· **设备管理**：缓冲管理 / 设备分配

###### 5. 操作系统提供的服务：

· 用户接口：
	· 命令级接口：Graphical User Interface/TouchScreen Interface/Command-Line Interface
	· 程序级接口（也称系统调用）
· 执行程序
· I/O 操作
· 文件系统操作
· 通信服务：共享内存 / 消息传递
· 错误检测和处理
· 资源分配
· 登录和记账
· 保护和安全
![|575](OS%20图/OS%20图1-12.png)
                            （图十二：操作系统提供的服务）

###### 6. 操作系统的用户接口：

1. **操作接口**：
	· 命令行（命令解释程序）
		· OS 内核的一部分（DOS）
		· 特殊程序，任务开始或用户登录时，该程序运行（UNIX 的 Shell）
		· 作用：执行命令
			· 命令解释程序执行（DOS）
			· 系统程序实现（UNIX 的 Shell）
	· Graphical User Interface：具有窗口界面的解释程序（Windows 的 Explorer.exe）
	· Touch Screen Interface：Gesture，Voice Command

2. **编程接口**：
	· 系统调用：请求操作系统服务或资源
	· 常以 API 形式出现：
		· 适用于 Windows 系统的 Win32 API
		· 适用于 POSIX 系统的 POSIX API：POSIX: Portable Operating System Interface of UNIX
		· 设计运行于 Java 虚拟机的 Java API
	· 应用领域接口：Android/iOS 应用接口、汽车领域 AUTOSAR
![|450](OS%20图/OS%20图1-13.png)
                    （图十三：Windows 和 UNIX 系统的用户接口示例）
![|400](OS%20图/OS%20图1-14.png)
                         （图十四：系统调用与操作系统的关系）
![|250](OS%20图/OS%20图1-15.png)
                       （图十五：C 中 “printf” 的系统调用过程示例）

###### 7. 操作系统的运行方式：

· 双重模式操作：
	1. 内核模式（OS 内核程序）：
		· 允许执行全部指令
		· 允许访问所有的寄存器和缓冲区
	2. 用户模式（用户程序，系统外层应用程序）：
		· 只能执行*非特权指令*
		· 只能访问指定的寄存器和存储区

· 特权指令：
	· 能引起损害的机器指令
	· E.g. I/O 控制，定时器管理，中断管理
		· 有关对 I/O 设备使用的指令 ：启动 I/O 设备指令、测试 I/O 设备工作状态和控制 I/O 设备动作的指令等
		· 有关访问程序状态的指令 ：操作程序状态字（PSW）的指令等
		· 存取特殊寄存器指令 ：存取中断寄存器、时钟寄存器等指令

· 计算机硬件提供*模式位*：
![|575](OS%20图/OS%20图1-16.png)
                        （图十六：用户模式到内核模式的切换）

· 两种模式的转换情况：
	· 用户模式 —> 内核模式：
		· 中断、异常、系统调用
	· 内核模式 —> 用户模式：
		· 完成中断或异常的处理
		· 新进程或线程启动
		· 进程调度选择执行新的进程
		· 操作系统向进程发送信号

###### 8. 操作系统的结构设计：

1. **操作系统的机制与策略**：
· 目的：降低操作系统设计的复杂性
· 设计原则：策略与机制分离：
	· 策略（Policy）：做什么
	· 机制（Mechanism）：怎么做
	· 操作系统可仅通过调整策略来适应不同应用的需求
· 示例：调度：
	· 策略：调度算法，FCFS，RR
	· 机制：调度队列的设计，调度算法（线程）的表示

2. **操作系统复杂度管理方法**：
	1. 模块化（Modularity）：
		· 分而治之
	2. 抽象（Abstract）：
		· 接口与内部实现分离
	3. 分层（Layering）：
		· 按层次划分，减少模块之间的交互
	4. 层级（Hierarchy）：
		· 将功能相似的子系统组成一个具有清晰接口的自包含子系统，子系统递归形成大系统

3. **操作系统的内核架构**：
![|500](OS%20图/OS%20图1-17.png) （图十七：操作系统内核架构的频谱：简要结构（如 DOS），宏内核（如 UNIX 和 Linux），微内核、外核和多内核）

 · *简要结构*：
	· 功能简单的操作系统，将应用程序和操作系统放置在同一个地址空间中，无须底层硬件提供复杂的内存管理、特权级隔离等功能
	· 模块化与层次结构
		· 将操作系统按其功能划分为若干个具有一定独立性和大小的模块和子模块
		· 各模块间通过接口实现交互
			· 模块间调用关系无序
			· 模块间耦合紧密
	· 优点：
		· 提高了 OS 设计的正确性、可理解性和可维护性
		· 增强了 OS 的适应性
		· 加速了 OS 的开发过程
	· 缺点：
		· 系统结构不清晰
		· 系统可靠性降低
		· 未能区分共享资源和独占资源
![|450](OS%20图/OS%20图1-18.png)
                        （图十八：简要结构—MS-DOS 结构示意）

· *宏内核架构*：
	· <font color="#ffc000">操作系统内核的所有模块均运行在内核态</font>（单内核），具备直接操作硬件的能力
	· UNIX / LINUX，FreeBSD 等
![|450](OS%20图/OS%20图1-19.png)
                             （图十九：宏内核的基本结构）
![|425](OS%20图/OS%20图1-20.png)
                           （图二十：传统 UNIX 系统架构）
![|200](OS%20图/OS%20图1-21.png)
                              （图二十一：Linux 系统架构）
· 宏内核架构的模块化：
	· 内核有一组核心部件，以及在启动或运行时对附加服务的动态链接
	· 内核提供核心服务，并能动态实现特定的功能
	· 可加装内核模块 LKM（Loaded Kernel Module）机制
	· 现代操作系统广为采用模块化：UNIX / Linux / Windows
![|350](OS%20图/OS%20图1-22.png)
                           （图二十二：宏内核架构的模块化）
· 宏内核架构的抽象：
	· UNIX：一切皆是文件（Everything is a file），将数据、设备、内核对象等均抽象为文件，并 为上层提供统一接口
· 宏内核架构的分层：
	· 宏内核架构的操作系统一开始就采用了分层结构
	· 引入原因：模块间有序调用
	· 设计原则：
		· 将功能模块排列成若干层
		· 各层之间的模块只能单向调用，每一层都仅使用其底层（或内层）模块所提供的功能和服务
		· 每一层的同层模块之间不存在相互调用关系
		· 最底层（第 0 层）是计算机硬件；最高层（第 N 层）是用户接口
	· 分层的优点：模块化，易于实现，增加了系统的可靠性
· 分层架构的示例：
	· 1972 年图灵奖获得者 Edsger Dijkstra 提出 “THE” 操作系统
![|350](OS%20图/OS%20图1-23.png)
                        （图二十三：“THE” 操作系统的分层结构）
	· Linux 的文件系统：
![|350](OS%20图/OS%20图1-24.png)
                         （图二十四：Linux 文件系统的分层结构）
	· 分层的困难：难以确切地定义每一层
	· 分层的缺点：效率低
![|450](OS%20图/OS%20图1-25.png)
                           （图二十五：OS/2 分层结构示意）

· 宏内核架构的虚拟机：
![|450](OS%20图/OS%20图1-26.png)
                        （图二十六：非虚拟机与虚拟机系统模型）
![|350](OS%20图/OS%20图1-27.png)
                            （图二十七：VMware 的结构）

· 宏内核架构的层级：
	· 广泛应用于内核的资源管理中
		· 调度子系统中对进程优先级的分类
		· 内存分配器对不同内存的分类

· *微内核架构*：
	· 微内核结构：
		· 操作系统从内核转移到“用户”空间
		· 以客户 / 服务器模式为基础
		· Server：实现某种服务的程序
		· Client：通过发送请求并等待应答来使用服务
	· 微内核的基本功能：
		· 进程管理：
			· 进程作为资源分配的基本单位
			· 线程作为独立运行和调度的基本单位
			· 进程与线程间的同步
		· 存储器管理：
			· 为进程分配必要的运行空间
			· 提供虚拟存储器管理
			· 处理缺页中断
		· 进程通信管理：
			· 用户模块之间通过传递消息进行通信
		· I/O 设备管理
			· 设备驱动程序
	· 微内核结构的实现方式：
		· 将最基本、最本质的 OS 功能保留在核中
		· 用户空间包含所有 OS 服务进程和用户应用进程
		· 每一 OS 功能均以单独的服务器进程形式存在
		· 进程以发送消息的方式通过微内核向服务器进程提出服务请求
		· 服务器进程处理完请求服务后，以发送消息的形式通过微内核将结果返回客户进程
	· 微内核的优点：
		· 策略与机制进一步分离
			· 易于扩展
			· 易于移值
		· 服务与服务之间完全隔离
			· 更可靠
			· 更安全
	· 缺点：性能
![|450](OS%20图/OS%20图1-28.png)
                              （图二十八：微内核的结构）
![|450](OS%20图/OS%20图1-29.png)
                           （图二十九：Windows NT 结构）

· 微内核架构的发展：
	1. 第 1 代：Mach
		· RickRashid，Rochester+CMU
		· 对进程间通信（IPC）的设计过于通用，使得其性能弱于同时期的宏内核
	2. 第 2 代：L4
		· Jochen Liedtke，德国国家信息技术研究中心
		· 极大提升了 IPC 的性能
		· 微内核最小化：一个操作系统内核的功能只有在其放在内核态以外会影响整个系统功能时，才能被放置在内核态
	3. 第 3 代：增强安全性
		· Gernot Heiser
		· 将能力（Capability）机制引入微内核操作系统
			· 通过 Capability 进行 IPC 的权限判断
		· 代表系统：
			· seL4：第一个完成形式化验证的内核
			· Google Fuchsia
			· MINIX：教学用微内核

· *外核架构*：
	· 引入：操作系统内核对硬件资源进行了抽象
		· 过度抽象会带来性能损失
		· 通用抽象对具体应用往往不是最优选择
	· 解决方案：
		· 不提供硬件抽象
			· “只要内核提供抽象，就不能实现性能最大化”
			· 只有应用才知道最适合的抽象
		· 不管理资源，只管理应用
			· 保证应用之间的隔离
			· 负责应用与资源的绑定
	· ExoKernel
		· 1995 年，MIT 的 Dawson Engler 和 Frans Kaashoek 等提出提出库操作系统（LibOS）概念
			· 将对硬件的抽象封装到 LibOS 中，以库形式提供，与应用直接链接
			· 按应用领域特点高度定制化，不同应用动态组装成最适合该领域的 LibOS，获得更高性能
			· 操作系统内核很小，多个LibOS之间具有强隔离性，提高安全性与可靠性
![|300](OS%20图/OS%20图1-30.png)
                             （图三十：外核操作系统的架构）

· 外核架构的优点：
	· OS 无抽象，能够在理论上提供最优性能
	· 应用对计算有更精确的实时等控制
	· LibOS 在用户态更易调试
· 外核架构的缺点：
	· 对计算资源的利用效率主要由应用决定
	· 定制化过多，维护难度增加
	· 缺乏跨场景的通用性，应用生态差

· 外核架构的应用：
	· 一些功能受限、对操作系统接口要求不高但对性能和时延特别敏感的嵌入式场景，可以将数据面与控制面分离
	· Unikernel（单内核）：
		· 虚拟化环境下的 LibOS：每个虚拟机只使用内核态，内核态中只允许一个应用+LibOS，通过虚拟化层实现不同实例间的隔离
		· 适合容器等新的应用场景：每个容器就是一个虚拟机，运行定制的 LibOS 以提高性能

· *多内核架构*：
	· 背景：硬件结构呈现异构众核特点
	· 多内核架构：
		· 苏黎世联邦理工学院、微软研究院、雷恩高等师范学校等联合提出一种实验型操作系统内核架构
		· 基本想法：
			· 将一个众核系统看成一个由多个独立处理器核通过网络互联而成的分布式系统
			· 假设硬件处理器提供全局共享内存语义
			· 为不同处理器核交互提供了一层基于进程间通信的抽象
		· 在每个 CPU 核上运行一个独立的操作系统节点，节点间的交互由操作系统节点之上的进程间通信来完成
![|450](OS%20图/OS%20图1-31.png)
                          （图三十一：多内核操作系统的架构）
![|500](OS%20图/OS%20图1-32.png)
                       （图三十二：操作系统的架构组合及其严谨）

· *混合内核架构*：
	· 宏内核+微内核：
		· 将需要性能的模块重新放回内核态：
			· Windows NT = 微内核+内核态的系统服务+系统框架
			· macOS / iOS = Mach 微内核+BSD4.3+系统框架
![|425](OS%20图/OS%20图1-33.png) （图三十三：混合内核架构示例图：左：苹果的 macOS 和 iOS 操作系统的架构；右：Darwin 结构）

4. **操作系统框架**：
· Android：分层+Linux 内核
![|200](OS%20图/OS%20图1-34.png)
                         （图三十四：Google's Android 的架构）

###### 9. 计算机系统体系结构：

1. **核（core）**：核是执行指令和寄存器以在本地存储数据的组件

2. **单处理器系统**：如果只有一个具有单个处理核心的通用 CPU，则该系统是单处理器系统

3. **多处理器系统**：
	· 传统上，这样的系统有两个（或更多）处理器，每个处理器都有一个单核 CPU
	· 处理器共享计算机总线，有时共享时钟、内存和外围设备
	· 类型：
		· 非对称多处理器（Asymmetric Multiprocessing）：每个处理器被分配一个特殊的任务
		· 对称多处理器（Symmetric MultiProcessing，SMP）：
			· 每个处理器执行所有任务
			· 所有处理器在系统总线上共享物理内存
	· 随着时间推移，多处理器的定义不断发展，现在包括多核系统，其中多个计算核心驻留在单个芯片上
![|375](OS%20图/OS%20图1-35.png)
                           （图三十五：对称多处理器体系结构）
![|375](OS%20图/OS%20图1-36.png)
                       （图三十六：同一个芯片上右两个核心的多核设计）

· **计算机系统组件定义**：
· CPU：执行指令的硬件
· Processor（处理器）：包含一个或多个 CPU 的物理芯片
· Core（核）：CPU 的基本计算单元
· Multicore（多核）：在同一个 CPU 上包含多个计算核心
· Multiprocessor（多处理器）：包含多个处理器

###### · --- 本章要点 ---：
· 操作系统的定义
· 操作系统的特性和基本功能
· 操作系统的形成与发展
· 多道程序设计的概念和特点
· 操作系统的分类：批处理系统、分时系统、实时系统
· 操作系统的性能指标：资源利用率、系统吞吐量、作业（平均）周转时间
· 操作系统提供的服务
· 操作系统的两种运行方式
· 操作系统的结构


### 贰  进程、线程与调度

#### 述：
#####
#####

###### 1. 进程 Process：

1. **进程的引入与概念**：
	1. *程序的执行顺序*：
		· 程序顺序执行的特点：
			· 程序执行的连续性
			· 程序环境的封闭性
			· 程序结果的可再现性
		· 优点：顺序程序的封闭性和可再现性为程序员调试程序带来了很大方便
		· 缺点：资源的独占性使得系统资源利用率非常低
	2. *程序的并发执行*：
		· 增强了计算机系统的处理能力，提高了资源利用率
		· 程序执行的间断性，并发执行的程序间产生了相互制约关系：执行—暂停—执行
		（因共享资源或协调完成同一任务引起：间接制约—共享资源；直接制约—协同完全任务）
		· 失去了程序的封闭性：资源共享
		· 程序结果的不可再现性
	3. *进程的基本概念*：
		· 进程的定义：
			· 进程是程序的一次执行
			· 进程是可以并发执行的计算
			· 进程是一个程序与其使用的数据在处理机上顺序执行时发生的活动
			· 进程是程序在一个数据集合上的运行过程，它是系统进行资源分配和调度的一个独立单位
			· 进程是可以和其他程序并发执行的程序关于某个数据集合的一次执行
		· 进程的特性：
			· <font color="#ffc000">动态性</font>：进程是程序的一次执行，具有生命期
			· <font color="#ffc000">独立性</font>：进程是系统进行资源分配和调度的一个独立单位
			· <font color="#ffc000">并发性</font>：进程可以并发执行
			· <font color="#ffc000">异步性</font>：进程间的相互制约，使进程执行具有间隙
			· <font color="#ffc000">结构性</font>：进程具有结构：1. 程序；2. 数据（地址空间、堆栈等）；3. <font color="#00ffb0">进程控制块</font>（PCB）
![|450](OS%20图/OS%20图1-37.png)
            （图三十七：系统中有多道程序对用户输入的数据进行计算并打印计算结果）
![|450](OS%20图/OS%20图1-38.png)
                （图三十八：两个并发执行的程序共同操作同一个 “count” 变量）
~~~
· 程序 A 和 B 执行时 count 的结果取决于语句执行顺序：
S1-S2-S3，count：N+1，N+1，0
S2-S3-S1，count：N，0，1
S2-S1-S3，count：N，N+1，0

· 程序与 CPU 执行的活动之间不再一一对应
	· 程序是完成某一特定功能的指令序列，是静态的
	· CPU 执行的活动是动态的
~~~

2. **进程的描述**：
	1. *进程控制块 PCB*：
		· 进程控制块是进程存在的<font color="#00ffb0">唯一标识</font>
		· 进程控制块包含进程的描述信息和管理控制信息
			· 进程标识符：内部 / 外部
			· 进程的状态（当前状态）
			· 进程调度信息：进程优先级、进程所在各种队列的指针
			· 进程的存储管理信息：
				· 进程要执行程序的内外存起始地址及采取的保护信息
			· 进程使用的资源信息：
				· 分配给进程的 I/O 设备
				· 正在执行的 I/O 请求信息
				· 当前进程正打开的文件
			· CPU 现场保护区：
				· 程序计数器
				· 工作寄存器
				· 程序状态字
				· 栈指针
			· 进程之间的家族关系：
				· 父子进程
				· 兄弟进程
		· Windows 的进程：
			· 执行体进程快 EPROCESS：表示进程的基本属性
			· 内核进程快 KPROCESS：
				· 进程控制块
				· 包含了内核调度线程的必要信息，例如基本优先级、默认时间片、进程状态、进程页目录表等
			· 进程环境块 PEB：
				· 位于进程地址空间（用户模式）
				· 包含了映像加载程序需要的信息、线程使用的堆信息等
![|450](OS%20图/OS%20图1-39.png)
                       （图三十九：Linux 中的进程控制块部分信息）
![|450](OS%20图/OS%20图1-40.png)
                      （图四十：Windows 中的进程控制块部分信息）
2. ······
	2. *进程的状态*：
		· 三种基本状态：
		1. <font color="#00ffb0">运行态</font>：正在计算单元（CPU core）上运行的进程所处状态（Instructions are beingexecuted）
		2. <font color="#00ffb0">就绪态</font>：已经获得了除 CPU core 之外的全部资源并等待系统分配 CPU core，一旦获得 CPU core 即可以变为运行态的进程状态
		3. <font color="#00ffb0">阻塞态 / 等候态</font>：一个进程因等待某事件发生而不能运行时所处状态，<font color="#ffc000">不能直接转换到运行态（需要先获得其他全部资源转换成就绪态）</font>
		· 创建态与终止态：
		4. <font color="#00ffb0">创建态</font>：进程被创建时的状态
		5. <font color="#00ffb0">终止态</font>：进程运行完成时的状态

| 进程状态      | 拥有资源情况                         |
| :-------- | :----------------------------- |
| 运行态       | CPU + 这一时刻所需要的其他全部资源           |
| 就绪态       | 这一时刻所需要的其他全部资源                 |
| 阻塞态 / 等候态 | 这一时刻所需要的部分资源（无法得到全部资源时会失去 CPU） |

![|450](OS%20图/OS%20图1-41.png)
                             （图四十一：进程状态的转换）
~~~
· 运行态 —> 就绪态
· 运行态 —> 等待态
· 就绪态 —> 运行态
· 等待 —> 就绪态
· 创建态 —> 就绪态：操作系统准备好再接纳一个进程时，把一个进程从创建态变为就绪态
· 运行态 —> 终止态：进程已结束，但尚未撤消，以便其它进程去收集该进程的有关信息
~~~
· 
	· Linux 进程生命期状态：
		· 可运行状态：进程正在或准备在 CPU 上运行的状态
		· 可中断的等待状态：进程睡眠等待系统资源可用或收到一个信号后，进程被唤醒
		· 不可中断的等待状态：进程睡眠等待一个不可被中断的事件发生（很少使用）
		· 暂停状态
		· 跟踪状态
		· 僵死状态：进程已终止，等待父进程处理
		· 死亡状态：系统删除该进程，进程退出状态
![|450](OS%20图/OS%20图1-42.png)
                           （图四十二：Linux 进程状态转换图）
	· Windows 线程的状态：
		· 就绪状态（ready）
		· 备用状态（standby）：
			· 已选好处理机，正等待描述表切换，以便进入运行状态
		· 运行状态（running）
		· 等待状态（waiting）
		· 传输状态（transition）
			· 核心栈被调到外存的就绪态
		· 终止状态（terminated）
		· 初始化状态（initialized）
![|450](OS%20图/OS%20图1-43.png)
                        （图四十三：Windows 进程状态转换图）
2. ······
	3. *进程上下文切换*：
		· <font color="#ffc000">进程的上下文（context）</font>包括进程运行时的寄存器状态，能够用于保存和恢复一个进程在处理器上运行的状态
		· 当操作系统需要切换当前执行进程时，使用<font color="#ffc000">上下文切换（context switch）</font>机制：
			· <font color="#ffc000">上下文保存至对应的 PCB 中</font>
			· 进程被调度时，从 PCB 中取出上下文并恢复
			· 上下文切换时进程通过中断或系统调用进入内核
		· 进程切换只发生在<font color="#ffc000">核心态</font>
![|200](OS%20图/OS%20图1-44.png)
                           （图四十四：进程上下文切换示意图）
	· Linux 进程切换：
		· 在发生进程切换之前，用户态进程使用的所有寄存器值都已被保存在进程的核心栈中
		· 之后大部分寄存器存放在 thread_struct 的 thread 字段（进程硬件上下文）里，一小部分仍在核心栈中
		· 进程切换步骤：
			· 切换页目录表以安装一个新的地址空间
			· 切换核心栈和硬件上下文，有 schedule() 函数完成进程切换
	· Windows 线程的上下文切换：
		· 上下文：CPU 的寄存器组、线程环境块、核心栈和用户栈

2. ······
	4. *进程地址空间布局*：
		· 进程具有独立的虚拟地址空间
			· 用户栈
			· 代码库
			· 用户堆
			· 数据与代码段
			· 内核部分：内核栈、内核代码与数据
![|150](OS%20图/OS%20图1-45.png)
                           （图四十五：进程独立的虚拟地址空间）
	· Linux 进程使用虚拟地址空间，由低地址到高地址分别为：
		· 只读段：包括代码段、rodata 段（C 常量字符串和 `#define` 定义的常量）
		· 数据段：保存全局变量、静态变量的空间
		· 堆：动态内存（ malloc/new 分配）
		· 文件映射区域：如动态库、共享内存等映射物理空间的内存，一般是 mmap 函数所分配的虚拟地址空间
		· 栈：用于维护函数调用的上下文空间，一般为 8M
		· 内核虚拟空间：用户代码不可见的内存区域，由内核管理（页表就存放在内核虚拟空间）
![|450](OS%20图/OS%20图1-46.png)
                        （图四十六：Linux 进程的虚拟地址空间）

2. ······
	5. *进程的组织*：
		· 线性表方式：将所有进程的 PCB 组成一个数组，系统通过数组下标访问每一个 PCB 
			· 优点：简单，节省存储空间
			· 缺点：系统开销大，查找一个指定的 PCB 较费时间
![](OS%20图/OS%20图1-47.png)
（图四十七：进程块的数组组织方式）
		· 链接方式：将处于同一状态的进程按照一定方式链接成一个队列
![|450](OS%20图/OS%20图1-48.png)
                        （图四十八：进程链接组织——进程队列）
![|450](OS%20图/OS%20图1-49.png)
                 （图四十九：进程链接组织——就绪队列和各种 I/O 设备队列）
	· Linux（传统）进程链表（list_head）：
		· 所有进程链表（tasks）：链表头是 0 号进程（idle 进程）
		· 可运行进程链表（run_list）：双向链表（140级）
		· 子进程链表（children）
		· 兄弟进程链表（sibling）
		· 等待进程链表：
			· 互斥等待临界资源的进程：一次唤醒一个
			· 非互斥等待的进程：唤醒所有进程
![|450](OS%20图/OS%20图1-50.png)
                              （图五十：Linux 进程队列）
	· 哈希链表：
		· 内核定义了 4 类哈希表
			· PIDTYPE_PID 链表：进程
			· PIDTYPE_TGID 链表：线程组
				· 同一线程组中的所有轻量级进程的 tgid 值相同
			· PIDTYPE_PGID 链表：进程组
			· PIDTYPE_SID 链表：会话
		· 哈希表地址存入 pid_hash 中
![|450](OS%20图/OS%20图1-51.png)
                        （图五十一：PIDTYPE_TGID 哈希链表）

3. **进程的控制**：
	1. *进程控制及原语*：
		· 进程控制：
			系统使用一些具有特定功能的程序段来创建、撤消进程以及完成进程各状态间转换等一系列有效管理；一般由操作系统内核完成
		· 原语（primitive）：
			某些程序段的执行过程不允许被中断，或者说其执行过程不可分割，这样的程序段叫***原语***
	2. *创建原语*：
		· 创建进程的时机：
			· 批处理系统中为每个作业创建一个进程（系统内核创建）
			· 分时系统中为每个用户创建一个进程（系统内核创建）
			· 提供服务：打印进程
			· 应用请求：已存在的进程创建子进程（应用程序创建）
		· 创建原语的功能：
			· 申请空白 PCB
			· 为新进程分配资源
			· 初始化进程控制块 PCB
			· 将新进程插入*就绪*队列
		· 创建进程时需注意的问题：
			· 资源共享：
				· 父子进程共享资源
				· 子进程共享部分父进程资源
				· 父子进程不共享资源
			· 数据：父进程传递给子进程初始数据
			· 地址空间：
				· 子进程复制父进程的地址空间
				· 子进程新创建自己的地址空间
			· 进程执行：
				· 父子进程并发执行
				· 父进程等待至子进程执行完毕
		· Linux 的进程创建—fork()：
			· fork() 系统调用创建子进程
			· 创建成功之后，子进程采用写时复制技术读共享父进程的全部地址空间，仅当父或子要写一个页时，才为其复制一个私有的页的副本
			· 父子进程是 2 个完全独立的进程，拥有不同的 pid 与虚拟地址空间，但内存、寄存器、程序计数器等状态都完全一致
		· Linux 的进程创建—clone() 与 vfork()：
			· 创建轻量级进程函数 clone()：实现对多线程应用程序的支持；共享进程在内核的很多数据结构，如页表、打开文件表等等
			· vfork()：阻塞父进程直到子进程退出或执行了一个新程序为止
```C
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
int main(int argc, char *argv[])
{
	pid_t pid;
	int x=100;
	/* fork another process */
	pid = fork();
	if (pid < 0)
	{ /* error occurred */
		fprintf(stderr, "Fork Failed");
	}
	else if(pid==0)
	{ /* child process */
		printf("Child process: x is: %d; \nThe value of x is: %d \n", pid, x);
	}
	else
	{ /* parent process */
		printf("Parent process: x is: %d; \nThe value of x is: %d \n", pid, x);
	}
}
```
![|200](OS%20图/OS%20图1-52.png)
                          （图五十二：父子进程之间的执行情况）
		· Windows 的进程创建—CreateProcess()：
			· 打开可执行文件 (.exe)，创建一个区域对象，建立可执行文件与虚拟内存之间的映射关系
			· 创建执行体进程对象 EPROCESS
			· 创建一个主线程
			· 通知 Win32 子系统，对新进程和线程进行一系列初始化
			· 完成地址空间的初始化，开始执行程序
· Win32 API 创建进程：
```C
#include <stdio.h>
#include <windows.h>
int main()
{
	STARTUPINFO si; //for new process
	PROCESS_INFORMATION pi;
	//allocate
	memoryZeroMemory(&si,sizeof(si));
	si.cb=sizeof(si);
	ZeroMemory(&pi,sizeof(pi));
	//create child processes
	if(!CreateProcess(NULL, //use command line
		"C:\\WINDOWS\\system32\\mspaint.exe",
		NULL, //don’t inherit process handle
		NULL, //don’t inherit thread handle
		FALSE, //disable handle inheritance
		0, //no creation flags
		NULL, //use parent’s environment block
		NULL, //use parent’s existing directory
		&si,
		&pi))
		{fprintf(stderr,"create failed."); return -1;}
	//parent will wait for the child to complete
	WaitForSingleObject(pi.hProcess,INFINITE);
	printf("Child Completed");
	//close handles
	CloseHandle(pi.hProcess);
	CloseHandle(pi.hThread);
}
```

3. ······
	3. *撤销原语*：
		· 撤销原语的时机：
			· 进程已完成任务，正常结束
			· 由于故障不能继续执行，异常结束：越界错误、保护错、非法指令、运行超时、算术运算错、I/O 故障
			· 外界干预：操作员或操作系统干预：死锁；父进程请求；父进程终止
		· 撤销原语的功能：
			· 根据被终止进程标识符查找被撤销进程 PCB 
			· 终止该进程，*重新调度*
			· 终止该进程的全部子进程
			· 回收资源释放 PCB
		· 撤销进程时需注意的问题：
			· 是否撤销该进程的子进程
		· Linux 中的进程撤销：
			· 进程终止：
				· exit() 系统调用只终止某一个线程
				· exit_group() 系统调用能终止整个线程组
			· 进程删除：
				· 父进程先结束的子进程会成为*孤儿进程*，系统会强迫所有的孤儿进程成为 init 进程的子进程
				· init 进程在用 wait() 类系统调用检查并终止子进程时，就会撤销所有僵死的子进程
		· Windows 中的撤销进程：
			· ExitProcess 和 TerminateProcess 终止进程和进程中的所有线程
				· 正常退出：ExitProcess
				· 异常退出：TerminateProcess，可以终止自己，也可以终止其他进程
	4. *阻塞原语*：
		· 阻塞进程的时机：
			· 处于运行状态的进程等待某一事件发生：
				· 等待 I/O 数据传输完成
				· 等待其他进程发送信息
		· 阻塞原语的功能：
			· 处于运行态的进程中断 CPU，将其运行现场保存在其 PCB 的 CPU 现场保护区
			· 将其状态置为阻塞态，并插入相应事件的等待队列
			· 转*进程调度*，选择一个就绪进程投入运行
		· 阻塞原语由进程自己执行
	5. *唤醒原语*：
		· 唤醒进程的时机：
			· 进程期待的事件到来时
		· 唤醒原语的功能：
			· 期待的事件是等待输入输出完成：
				· 输入 / 输出 完成后，由硬件提出中断请求，CPU 响应中断，暂停当前进程的执行，转去中断处理，检查有无等待该 输入/输出 完成的进程
				· 有则将该进程从等待队列抽出，并将其由阻塞态置为就绪态，插入就绪队列，结束中断处理
				· 返回被中断进程继续执行，或者转*进程调度*，选择一个就绪进程投入运行
			· 期待的事件是等待某进程发送消息：
				· 当信息发送给该等待进程时，由发送进程把该等待进程唤醒，并将其由阻塞态置为就绪态，插入就绪队列即可

###### 2. 线程 Thread 的引入与概念：

1. **线程的引入**：
	· 引入原因：
		· 在许多应用中同时发生着许多活动
		· 硬件技术的发展，使得计算机拥有了更多的 CPU 核，程序的可并行度提高
		· 创建进程的开销较大
		· 进程拥有独立的虚拟地址空间，在进程间进行数据共享和同步的开销较大
	· 解决方法：
		· 将拥有资源的基本单位与调度的基本单位分离
	· 线程引入的优点：
		· 响应时间：如果进程的一部分线程被阻塞，则允许其他线程继续执行，这对用户界面尤其重要
		· 资源共享：线程共享进程资源，比共享内存或消息传递更简单
		· 经济性：比创建进程更便宜，线程切换的开销比上下文切换更低
		· 可扩展性：可以利用多核架构的优势

2. **线程的概念**：
	· 进程内的一个执行单元
	· 进程内的一个可调度实体
	· 线程是程序（或进程）中相对独立的一个控制流序列
	· 线程是执行的上下文，其含义是执行的现场数据和其他调度所需的信息
	· 轻质进程（Light weight process）
		· 重质进程（Heavy weight process）：
			· 传统的进程是拥有一个线程的进程
	· 线程的特性：
		· 独立调度和分派的基本单位
		· 可并发（并行）执行
		· 动态性：
			· 线程的状态：就绪态，运行态，阻塞态/等待态
		· 结构性（*线程控制块，TCB*）：
			· 线程的标识
			· 线程状态
			· 程序计数器
			· 执行堆栈
			· 寄存器集
		· 所有线程具有相同的地址空间（进程地址空间），共享进程资源：
			· 地址空间
			· 代码段
			· 数据段
			· 其他 OS 资源
![|400](OS%20图/OS%20图1-53.png)
                          （图五十三：进程结构与线程结构对比）
![|400](OS%20图/OS%20图1-54.png)
                        （图五十四：单线程进程与多线程进程图示）
![|150](OS%20图/OS%20图1-55.png)
                         （图五十五：多线程进程的地址空间布局）
	· 线程的创建：
		· 创建进程时，系统同时为进程创建第一个线程，即“*初始化线程*”
		· 由初始化线程根据需要再去创建若干个线程	
	· 线程的终止：
		1. 线程完成工作后自愿退出
		2. 线程在运行中出现错误或由于某种原因而被其它线程强行终止
	· 对于 Linux：
		· Linux 创建内核线程的函数 `kernel_thread()`
		· 0 号进程就是一个内核线程，0 号进程是所有进程的祖先进程，又叫 idle 进程或叫做 swapper 进程；每个 CPU 都有一个 0 号进程
		· 1 号进程是由 0 号进程创建的内核线程 init，负责完成内核的初始化工作；在系统关闭之前，init 进程一直存在，它负责创建和监控在操作系统外层执行的所有用户态进程
		· 2 号进程是由 1 号进程 init 创建的内核线程，所有由内核创建和管理的进程都是由它 fork 出来的
![](OS%20图/OS%20图1-56.png)
                           （图五十六：简化后的 Linux 进程树）

3. **线程的实现**：
· 内核级线程：
	· 所有线程的创建、撤销、调度和管理都由 OS 依靠内核负责
	· 在内核空间为每一个内核支持线程设置了一个线程控制块，内核根据线程控制块感知线程的存在，并对其加以控制
	· 缺点：
		· 创建和管理的开销大
	· 优点：
		· 可调度一个进程中的多个线程同时在多个计算单元上并行运行，从而提高程序执行速度和效率
		· 当进程中的一个线程被阻塞时，进程中的其他线程仍可以被调度运行
		· 具有很小的数据结构和堆栈，线程切换较快，开销较小
	· 内核级线程的实现：
		· 创建进程时分配任务数据区空间
![|425](OS%20图/OS%20图1-57.png)
                            （图五十七：内核级线程的实现）

· 用户级线程：
	· 由用户应用程序建立的线程，并且由用户应用程序负责所有这些用户级线程调度执行和管理工作
	· 仅存在于用户空间，操作系统内核完全不知道这些线程的存在
	· 缺点：
		· 任一线程的阻塞将导致进程中所有其他线程被阻塞
		· 只能有一个线程在 CPU 上运行，不能利用多核的好处
	· 优点：
		· 用户应用程序中的线程切换的开销比内核线程切换的开销小
		· 线程库的线程调度算法与操作系统的调度算法无关
		· 用户级线程不要求内核支持，可适用于任何操作系统
	· 用户级线程的实现：
		· 运行时系统
![|425](OS%20图/OS%20图1-58.png)
                          （图五十八：用户级线程的实现）

4. **多线程模型**：
	1. 多对一（Many-to-One）：
		· 许多用户级线程映射到单个内核
		· 一个线程阻塞导致所有线程阻塞
		· 多个线程可能无法在多核系统中并行运行，因为一次只有一个线程在内核中
		· 目前很少有系统使用这种模型
		· 示例：Solaris GreenThreads；GNU PortableThreads
![](OS%20图/OS%20图1-59.png)
                           （图五十九：多对一的多线程模型）
4. ……
	2. 一对一（One-to-One）：
		· 每个用户级线程都映射到内核线程
		· 创建一个用户级线程就创建一个内核线程
		· 每个进程的并发性比多对一线程多，有时由于开销而受到限制
		· 示例：Windows；Linux
![](OS%20图/OS%20图1-60.png)
                            （图六十：一对一的多线程模型）
4. ……
	3. 多对多（Many-to-Many）：
		· 允许许多用户级线程映射许多内核线程
		· 允许操作系统创建足够数量的内核线程
		· Windows 使用 ThreadFiber 包
		· 其他的不太常见
![](OS%20图/OS%20图1-61.png)
                          （图六十一：多对多的多线程模型）
4. ……
	4. 两级模型（Two-level Model）：
		· 属于一种特殊的“多对多”，不同之处在于它允许将用户线程绑定到内核线程
![](OS%20图/OS%20图1-62.png)
                            （图六十二：两级多线程模型）
4. ……
	5. 内核控制线程（轻型进程 LWP）：
		· 用户级线程通过 LWP 与内核通信
![|500](OS%20图/OS%20图1-63.png)
                     （图六十三：用户级线程通过 LWP 与内核通信）

5. **线程库**：
· 线程库为程序员提供创建和管理线程的 API
· 实现方式：
	· 在用户空间提供没有内核支持的库
		· 所有代码和数据存在于用户空间
		· 用户空间的本地函数调用
	· 由操作系统直接支持的内核级的库
		· 所有代码和数据存在于内核空间
		· 对内核的系统调用
· 两种主要的线程库：
	· POSIX Pthread：可以提供用户级或内核级的线程库
	· Win32：适用于 Windows 系统的内核级线程库
· 利用线程库创建线程：
	· 示例：设计一个多线程程序，在独立的线程中完成非负数整数的加法功能

· 使用 Pthread API 的多线程 C 程序：
```C
#include <pthread.h>
#include <stdio.h>
int sum; //this data is shared by the thread(s)
void* runner(void *param); //the thread
int main(int argc, char* argv[]) {
	pthread_t tid;
	pthread_attr_t attr;
	if(argc!=2) {
		fprintf(stderr,"usage:a.out <integer value>\n");
		return -1;}
	if(atoi(argv[1]<0) {
		fprintf(stderr,"%d must be<=0\n",atoi(argv[1]));
		return -1; }
	//get the default attributes
	pthread_attr_init(&attr);
	//create the thread
	pthread_create(&tid,&attr,runner,argv[1]);
	//now wait for the thread to exit
	pthread_join(tid,NULL);
	printf("sum=%d\n",sum);}
	//the thread will begin control in this function
void* runner(void* param) {
	int i, upper=atoi(param);
	sum=0;
	for(i=1;i<=upper;i++) sum+=i;
	pthread_exit(0);}
```

· 使用 Win32 API 的多线程 C 程序：
```C
#include <windows.h>
#include <stdio.h>
DWORD sum; //this data is shared by the thread(s)
//the thread runs in this separate function
DWORD WINAPI Summation(LPVOID Param) {
	DWORD Upper=*(DWORD*)Param;
	for(DWORD i=0;i<=Upper;i++) sum+=i;
	return 0;}
int main(int argc, char* argv[]) {
	DWORD ThreadId;
	HANDLE ThreadHandle;
	int Param;
	if(argc!=2) {
		fprintf(stderr,"An integer param is required\n");
		return -1;}
	Param=atoi(argv[1]);
	if(Param<0) {
		fprintf(stderr,"An integer>=0 is required\n");
		return -1;}
	//create the thread
	ThreadHandle=CreateThread(
		NULL, //default security attributes
		0, //default stack size
		Summation, //thread function
		&Param, //parameter to thread function
		0, //default creation flags
		&ThreadId); //returns the thread identifier
	if(ThreadHandle!=NULL){
		//now wait for the thread to finish
		WaitForSingleObject(ThreadHandle,INFINITE);
		
		//close the thread handle
		CloseHandle(ThreadHandle);
		
		printf("sum=%d\n",sum);
	}
}
```

6. **线程实例**：
· *Windows 线程*：
	· Windows 应用程序以独立进程方式运行，每个进程可包括一个或多个线程
	· Windows 实现了一对一的映射，每个用户线程映射到相关的内核线程
	· Windows 也提供了对 fiber 库的支持，该库提供了多对多模型
	· 每个 Windows 线程包括：
		· 一个线程 ID，用于唯一标识线程
		· 一组寄存器集合，表示处理器状态
		· 一个用户栈和一个内核栈，分别供线程在用户模式和内核模式下运行
		· 一个私有存储区域，为各种运行时库和动态链接库使用
		· 后三者又合称为：线程上下文
	· Windows 线程的数据结构：
		· 内核空间：
			· ETHREAD：执行线程块
			· KTHREAD：内核线程块
		· 用户空间：
			· TEB：线程环境块
![|400](OS%20图/OS%20图1-64.png)
                        （图六十四：Windows 线程的数据结构）
· ETHREAD：包括线程进程的指针和线程开始控制的子程序的地址，以及相应的 KTHREAD
· KTHREAD：包括线程的调度和同步信息，以及内核栈（线程在内核模式下运行时使用）和 TEB
· TEB：包括线程相关信息、用户模式栈和用于线程特定数据的数组

· 线程对象的服务：
	· 创建线程 CreateThread
	· 线程退出 ExitThread
	· 终止某个线程 TerminateThread
	· 改变线程优先级 SetThreadPriority

· Linux 系统中不区分进程与线程，对程序内的控制流通常称为任务（task）：
	· Linux 的主进程数据结构中不包含进程的整个上下文，进程的文件系统上下文、文件描述表、信号处理表和虚拟内存上下文保存在独立的数据结构中
· Linux 中创建进程与线程：
	· fork() 系统调用提供复制进程的传统功能
	· clone() 系统调用提供创建线程的功能：
		· 通过传递一组标志，决定在父任务和子任务之间发生多少共享

| 标志            | 含义       |
| :------------ | :------- |
| CLONE_FS      | 共享文件系统信息 |
| CLONE_VM      | 共享内存空间   |
| CLONE_SIGHAND | 共享信号处理程序 |
| CLONE_FILES   | 共享打开文件集合 |

7. **进程与线程的比较**：
· *拥有资源*
	· 进程拥有独立的地址空间，若干代码段和数据段，若干打开文件、主存以及至少一个
	· 线程一个进程内的多线程共享该进程的所有资源，线程自己拥有很少资源
· *调度进程*
	· 调度需进行进程上下文切换，开销大
	· 同一进程内的线程切换，仅交换线程拥有的一小部分资源，效率高
	· 不同进程的线程切换将引起进程调度
· *并发性*
	· 引入线程后，系统并发执行程度更高；进程之间、进程内的多线程之间可以并发执行
· *安全性*
	· 同一进程的多个线程共享进程的所有资源，一个线程可以改变另一个线程的数据，而多进程实现则不会产生此问题

###### 3. 操作系统调度：

1. **基本概念**：
· *什么是调度？*
· Q1：程序员小明想在单核计算机上运行一个需要执行 30 分钟的机器学习程序，同时还想打开播放器收听音乐轮流执行？
· A1：轮流执行
· Q2：如果仅有 8 个处理器，如何运行 168 个任务？
	· 下一个要执行的任务是哪一个？
	· 执行该任务的 CPU 是哪一个？
	· 每个任务执行多长时间？

· 处理及调度级别：
	· 高级调度（作业调度）：
		· 选择哪个作业进入就绪队列
		· 调度不频繁
	· 低级调度（进程调度）：
		· 选择哪个进程可以占有 CPU
		· 调度频繁
	· 中级调度（交换调度）：
		· 进程换入换出
		· 提高内存利用率和系统吞吐量
![|350](OS%20图/OS%20图1-65.png)
                            （图六十五：作业状态及其转换）

· 调度方式：
	· 非剥夺方式
		· 实现简单，系统开销小，适合于批处理系统
	· 剥夺方式
		· 优先级/时间片，分时系统/实时系统
· 进程调度的功能：
	· 记录系统中各进程的执行状况
	· 选择进程真正占有 CPU
	· 进行进程上下文的切换
· 调度时机：
	· 现行进程完成执行或由于某种错误而中止运行
	· 正在执行的进程提出 I/O 请求，等待 I/O 完成
	· 分时系统中按照时间片轮转调度策略，分配给进程的时间片用完
	· 优先级调度策略中，进程有更高优先级进程变为就绪
	· 进程执行了某种操作原语，如阻塞原语或唤醒原语时，可能引起进程调度
· 处理机调度准则：
	· CPU 利用率*高*
	· 吞吐量*高*
	· 周转时间/平均周转时间*短*
	· 等待时间/平均等待时间*短*
	· 响应时间*短*
	· 批处理系统：*增加系统吞吐量和提高系统资源的利用率*
	· 分时系统：*保证每个分时用户的响应时间*

2. **单核调度**：
	1. <font color="#00ffb0">FCFS（先来先服务）调度算法</font>：
		· First Come First Serve
		· 采用非剥夺调度方式
		· 既可用于作业调度，也可用于进程调度
		· 示例：
![|300](OS%20图/OS%20图1-66.png)
                           （图六十六：FCFS 调度算法的示例）
· 注：当进程以角标区分时，即使所有进程是同时到达的，也认为有微小时间差，故调度默认优先顺序是按照角标从小到大的顺序
· 简单，但效率不高
· 有利于长作业（进程），不利于短作业（进程），容易被大作业（进程）垄断，使得平均等待时间很长

2. ……
	2. <font color="#00ffb0">SJF（短作业优先）调度算法</font>：
		· Short Job First
		· 考虑作业（进程）运行时间
		· 在长期调度中频繁使用
		· 既可采用非剥夺调度方式，也可采用剥夺调度方式（Shortest-Remaining-Time-First，SRTF）
		· 示例：
![|300](OS%20图/OS%20图1-67.png)
                            （图六十七：SJF 调度算法的示例）
· 优点：SJF 是一种最优算法，它可以获得最小平均等待时间，提高系统吞吐量
· 缺点：对长作业不利，容易产生“饥饿”现象；没有考虑作业的紧迫程度
· 困难：难以确定进程的执行时间

2. ……
	3. <font color="#00ffb0">高响应比优先调度算法</font>：
		· 优点：兼顾了运行时间短和等待时间长的作业（结合 FCFS 和 SJF 方法），优先运行短作业和等待时间足够长的长作业
		· 缺点：较复杂，系统开销大
$$响应比=\frac{作业等待时间+作业估计运行时间}{作业估计运行时间}=1+\frac{作业等等时间}{作业估计运行时间}$$
	· 响应比计算：
		· 若作业等待时间相同，则作业估计运行时间越短，响应比越高，因此有利于短作业
		· 若作业估计运行时间相同，则作业等待时间越长，响应比越高，此时算法即 FCFS
		· 对长作业来说，其响应比将随等待时间的增加而提高，当等待时间足够长时，响应比将足够高， 从而可以获得处理机，避免产生“饥饿”现象

---
2. ……
	4. <font color="#00ffb0">优先级调度算法</font>：
		· 为每个进程设定一个优先级
		· 既可采用非剥夺调度方式（批处理系统）
		· 也可采用剥夺调度方式（实时系统）
		· 优先级设定：
			· 进程类型：系统进程 / 用户进程
			· 进程对资源的需求：申请资源较多的进程，优先级较低
			· 用户要求
		· 优先级是用优先数表示的（不同操作系统对于“优先数越大优先级越高”还是相反是不同的）
		· 优先级类型：
			· 静态优先级：
				· 进程创建时确定，整个运行期间保持不变
				· 不能反映进程特点，调度性能差
				· 容易导致“饥饿”，即不能调度低优先级进程
			· 动态优先级：
				· 随着进程的推进或等待时间的增加而改变
		· 示例：
![|300](OS%20图/OS%20图1-68.png)
              （图六十八：优先级调度算法的示例（同时到达，优先数小优先级高））
![|300](OS%20图/OS%20图1-69.png)
          （图六十九：优先级调度算法的示例（不同时到达，可剥夺，优先数小优先级高））

2. ……
	5. <font color="#00ffb0">时间片轮转调度算法</font>：
		· 对于分时系统的
		· 采用剥夺调度方式（一定是可剥夺的）
		· 时间片的确定：
			· 既要保证系统各个用户进程及时地得到响应，又不要由于时间片太短而增加调度的开销，降低系统的效率
		· 注意：<font color="#ffc000">如果任务此次剩余时间小于时间片，则这个任务结束后可以立即开启下个任务的时间片，无需等待这个任务用完整个时间片</font>
		· 示例：
![|300](OS%20图/OS%20图1-70.png)
                          （图七十：时间片轮转调度算法的示例）
![|246](OS%20图/OS%20图1-71.png)
                   （图七十一：时间片轮转调度中周转时间随时间片大小变换）
· 分时系统实现时间片轮转调度需要使用的数据结构或程序：
	· 进程控制块
	· 时钟中断处理程序
	· 进程就绪队列

2. ……
	6. <font color="#00ffb0">多级队列调度算法</font>：
		· 将就绪队列分成多个独立队列
		· 根据进程的属性（内存大小、进程优先级、进程类型），一个进程被永久地分配到一个队列
		· 每个队列有自己的调度算法
		· 队列之间进行调度：固定优先级抢占调度
![|350](OS%20图/OS%20图1-72.png)
                          （图七十二：多级队列调度算法示意图）

2. ……
	7. <font color="#00ffb0">多级反馈队列调度算法</font>：
		· 设置多个就绪队列，并为其赋予不同的优先级和时间片，高优先级队列中进程的时间片较小
		· 新进程放入第一队列尾，按 FCFS 算法调度
		· 若该进程在指定时间片内未完成，调度程序将该进程转入第二队列尾，按 FCFS 算法调度，依次类推
		· 仅当第一队列空时，调度程序才调度第二队列中的进程运行，依次类推
		· 当处理机为某级队列服务时，有高优先级进程进入，则采用剥夺方式为高优先级进程服务
		· *调度时考虑的问题*：
			· 队列数目
			· 队列优先级
			· 每个队列采用的调度算法
			· 初始状态时，每个进程处于哪个队列
			· 进程是否在就绪队列之间进行迁移

- 关注图七十一：周转时间 $T_i$ 随时间片大小变换：

| 时间片大小 | $T_1$ | $T_2$ | $T_3$ | $T_4$ | 平均周转时间 $\overline{T}$ |
| :---- | :---- | :---- | :---- | :---- | --------------------- |
| $1$   | $15$  | $9$   | $3$   | $17$  | $11.0$                |
| $2$   | $14$  | $10$  | $5$   | $17$  | $11.5$                |
| $3$   | $13$  | $6$   | $7$   | $17$  | $10.75$               |
| $4$   | $14$  | $7$   | $8$   | $17$  | $11.5$                |
| $5$   | $15$  | $8$   | $9$   | $17$  | $12.25$               |
| $6$   | $6$   | $9$   | $10$  | $17$  | $10.5$                |
| $7$   | $6$   | $9$   | $10$  | $17$  | $10.5$                |
| $8$   | $6$   | $9$   | $10$  | $17$  | $10.5$                |
| $9$   | $6$   | $9$   | $10$  | $17$  | $10.5$                |
| $10$  | $6$   | $9$   | $10$  | $17$  | $10.5$                |

· 如果采用先来先服务的调度方式，则等同于时间片大小大于等于 $7$ 时，平均周转时间为 $10.5$
· 如果采用短作业优先的调度方式，则：

| 调度方式  | $T_1$ | $T_2$ | $T_3$ | $T_4$ | 平均周转时间 $\overline{T}$ |
| :---- | :---- | :---- | :---- | :---- | :-------------------- |
| 先来先服务 | $6$   | $9$   | $10$  | $17$  | $10.5$                |
| 短作业优先 | $10$  | $4$   | $1$   | $17$  | $8$                   |

· 短作业优先是能获得最优周转时间的调度
· 先来先服务的调度周转时间长短取决于服从短作业优先的程度
· 时间片的长度大于等于最长执行时间进程时，轮转调度等同先来先服务
· 时间片的长度过小时，即使不考虑进程切换，很多短小进程完成时间会很晚

3. **实时系统调度**：
	· 对于实时调度，调度程序必须支持抢占，基于优先级的调度，但只能保证软实时
	· 对于硬实时，还必须提供满足截止日期的能力
	· 进程具有新的特征：周期性进程需要 CPU 以固定的间隔进行处理时间 $t$，截止日期 $d$，周期 $p$：$0\leq t\leq d\leq p$
![](OS%20图/OS%20图1-73.png)
                         （图七十三：实时调度系统的执行）
3. ……
	1. 速率单调调度：
		· 优先级是基于周期任务周期的倒数来分配的，周期任务的周期为 $\frac{1}{p}$
![|350](OS%20图/OS%20图1-74.png)
                   （图七十四：示例——采用速率单调调度会错过最后期限）

3. ……
	2. EDF 调度算法（最早截止时间优先，Earliest Deadline First）：
		· 开始截止时间越早，优先级越高
![|450](OS%20图/OS%20图1-75.png)
                         （图七十五：EDF 调度算法的执行 Ⅰ）
![|450](OS%20图/OS%20图1-76.png)
                         （图七十六：EDF 调度算法的执行 Ⅱ）

3. ……
	3. LLF 调度算法（最小松弛度优先，Least Laxity First）：
		· 松弛度 = 结束时间 – 运行时间 – 当前时间
![|400](OS%20图/OS%20图1-77.png)
                           （图七十七：LLF 调度算法的执行）

4. **多核调度**：
	· 任务同时在多个 CPU 核心上并行执行
	· 调度器的考虑：
		· 当前应该调度哪个/哪些任务？
		· 每个调度的任务应该在哪个 CPU 核心上执行？
		· 每个调度的任务应该执行多长时间？
	· 负载分担：
		· 沿用单核调度思路，多核共享一个全局运行队列
		· 优点：设计实现简单；每个 CPU 核心分担系统负载，不会造成 CPU 的浪费
		· 缺点：共享全局队列的同步开销；任务在多个 CPU 核心之间切换开销
![|328](OS%20图/OS%20图1-78.png)
                        （图七十八：基于负载分担的多核调度示意图）
![|311](OS%20图/OS%20图1-79.png)
             （图七十九：基于负载分担的多核调度导致任务在 CPU 核心间频繁切换）
	· 协同调度：
		· 适用于关联任务或任务之间有依赖关系的场景 / 并行计算场景：
			· 将一个工作量较大的任务切分成多个子任务，每个子任务由不同 CPU 核心完成
			· 尽可能让一组任务并行执行，避免调度器同时调度有依赖关系的两组任务
		· 群组调度策略：
			· 将关联任务设置为一组，以组为单位调度任务在多个 CPU 核心上执行
			· 缺点：无关联任务之间的相互等待可能造成 CPU 资源的浪费
	· 两级调度：
		· 全局调度器：决定任务被哪个 CPU 核心执行
		· 本地调度器：任务一直被该核心调用，不会发生迁移
![|450](OS%20图/OS%20图1-80.png)
                             （图八十：群组调度示意图）
![|450](OS%20图/OS%20图1-81.png)
                            （图八十一：两级调度示意图）

###### · --- 本章要点 ---：
- 进程的概念与特点
- 进程控制块的作用及内容
- 进程的状态与状态转换
- 进程上下文切换
- 进程的内存空间布局
- 进程的组织
- 进程的控制
- 线程的概念与实现
- 多线程模型
- 先来先服务调度算法
- 短作业优先调度算法
- 高响应比优先调度算法
- 时间片轮转调度算法
- 优先级调度算法
- 多级反馈队列调度算法
- 实时系统调度算法
- 多核调度算法

