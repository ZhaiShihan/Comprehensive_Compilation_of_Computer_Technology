### 壹  进程通信与死锁

#### 述：
#####
#####

###### 1. 进程通信：

1. **并发进程的特点**：
· 资源共享引起的*互斥关系*：
	· 并发进程互斥使用共享资源：例如两个进程均要独占使用的打印机
	· 间接制约关系（通过资源制约）
	· 进程—资源—进程
· 协作完成同一个任务引起的*同步关系*：
	· 同步点：例如“生产者-消费者问题”
	· 直接制约关系
	· 进程—进程

2. **进程间通信**：
· 进程之间既相互依赖又相互制约，既相互合作又相互竞争
· 允许进程相互交换数据与信息
· 进程通信模式：
	1. 共享内存：
		· 建立起一块供协作进程共享的内存区域，进程通过向此共享区域读或写入数据交换信息
	2. 消息传递：
		· 通过在协作进程间交换消息实现通信
![|400](OS%20图/OS%20图2-1.png)
                              （图一：进程间两种通信模型）

###### 2. 进程同步：

1. **临界资源与临界区**：
![|368](OS%20图/OS%20图2-2.png)
                              （图二：临界资源与临界区）
· 临界资源（critical resource）：
	· 一次仅允许一个进程使用的资源
	· 打印机、共享变量、共用队列结构等都是临界资源
	· 可重入的程序代码、私用数据段等不是临界资源
· 临界区（critical section）：
	· 每个进程访问临界资源时必须互斥执行的*程序（代码）*
· 使用临界资源需要遵循的原则：
	· <font color="#00ffb0">互斥使用</font>：不能同时有两个进程在临界区内执行
	· <font color="#00ffb0">有空让进</font>：临界资源空闲时，应允许一个请求临界资源的进程进入临界区
	· <font color="#00ffb0">有限等待</font>：不能使进入临界区的进程无限期滴等待在临界区之外
	· <font color="#00ff7c">让权等待</font>：等待进入临界区的进程应释放处理机后阻塞等待（不是强制要求的）
![|450](OS%20图/OS%20图2-3.png)
                             （图三：进程 Pi 的通用结构）
![|450](OS%20图/OS%20图2-4.png)
                       （图四：进程 A 和进程 B 互斥使用一个临界区）

---
***互斥问题的解决***

2. **Peterson 算法**：
· 解决进程互斥进入临界区的软件方法
· 适用于两个进程交替执行临界区与剩余区
· $2$ 个进程共享 $2$ 个数据项：
`int turn`：表示哪个进程可以进入临界区
`boolean flag[2]`：表示哪个进程准备进入临界区
· 示例：
![|425](OS%20图/OS%20图2-5.png)
                    （图五：两个进程共享两个数据项的 Peterson 算法思路）
· 退出 `while` 循环的条件是，要么另一个进程 / 线程不使用临界区，要么此进程 / 线程不再拥有访问权限
· Peterson 算法一直在进行循环判断，故没有让权等待

· 局限性：Peterson 的解决方案不能保证在现代计算机体系结构上工作，主要原因是，为了提高系统性能，处理器和/或编译器可能会重新排序没有依赖关系的读写操作
· 现代编译器会对代码进行优化，比如：
```C
int flag=false, x=0;
P1
	while(!flag);
	print x;
P2
	x=100;
	flag=true;
```
· 期望输出是 100，但是由于 flag 和 x 没有直接制约关系，故现代编译器优化后的结果使得代码执行顺序错乱，输出的结果是 x=0
![](OS%20图/OS%20图2-6.png)
               （图六：重新排序没有依赖关系的读写操作对 Peterson 算法的影响）

3. **硬件同步**：
· 解决进程互斥进入临界区的硬件方法：
	1. 关中断：
		· 进程刚进入临界区后立即禁止所有中断
		· 进程要离开之前打开所有中断
		· 原理：CPU 只有在发生时钟中断或其他中断时才会进程切换
		· 实现：关中断（disable）—critical section—关中断（enable）
		· 优点：简单
		· 缺点：
			· 将禁止中断的权力交给用户进程是不明智的
			· 在多处理机系统中，禁止中断对执行本指令的 CPU 有效，其他 CPU 仍将继续运行，并可访问共享资源
	2. 内存屏障：
		· 解决 Peterson 算法乱序（reorder）问题
		· 一个计算机体系结构决定了它将向应用程序提供什么样的内存保证，这就是它的内存模型
			· 强指令：在一个处理器上的内存修改立即对所有其他处理器可见
			· 弱指令：在一个处理器上对内存的修改可能不会立即被其他处理器看到
		· 内存模型因处理器类型而异，因此内核开发人员不能对共享内存多处理器上内存修改的可见性做出任何假设
		· 为了解决这个问题，计算机体系结构提供了一些指令，可以强制将内存中的任何更改传播到所有其他处理器，从而确保在其他处理器上运行的线程可以看到内存修改
		· 这样的指令被称为内存屏障或内存栅栏
![|400](OS%20图/OS%20图2-7.png)
                  （图七：内存屏障的示例（此时 Thread1 输出的结果是 100））
	3. 硬件指令：
· `test_and_set()` 指令是原子（不会被打断）的：
![](OS%20图/OS%20图2-8.png)
                         （图八：test_and_set() 原子指令的定义）
![|425](OS%20图/OS%20图2-9.png)
                          （图九：test_and_set() 指令实现互斥）
~~~
图八解释：
· 如果标识为 false，则设置标识为 true，返回 false
· 判断出原来没上锁，将其上锁
· 如果标识为 true，直接返回 true
· 原本已经上锁

图九解释：
· 如果检测到 critical section 没上锁，则进入，并上锁
· 如果检测到 critical section 上锁，则 while 等待
· 当自己退出 critical section，则将锁解开（lock=false;）
~~~

· 与 `test_and_set()` 指令一样，`compare_and_swap()`（CAS）指令也是原子性的，用另一种机制实现交换两个单词的内容
![|450](OS%20图/OS%20图2-10.png)
                     （图十：compare_and_swap() 原子指令的定义）
![|450](OS%20图/OS%20图2-11.png)
                     （图十一：compare_and_swap() 指令实现互斥）
	4. 原子变量

4. **互斥锁**：
· 基于硬件的方法复杂且程序员无法访问
· 使用更高级别的软件工具——互斥锁
· 原理：
	· 为临界资源设置锁位变量 $w$
	· $w=0$，资源空闲可用
	· $w=1$，资源已被占用
	· 初始化及退出临界区时，将 $w$ 置为 $0$
	· 进入临界区时，将 $w$ 置为 $1$
	· 实现：多个进程利用互斥锁实现互斥
![|375](OS%20图/OS%20图2-12.png)
                         （图十二：多个进程利用互斥锁实现互斥）
· 自旋锁：
	· 利用 CAS 实现
	· 优点：没有上下文切换
	· 在现代多核计算系统上，自旋锁被广泛用于许多操作系统中
![](OS%20图/OS%20图2-13.png)
                                （图十三：自旋锁的实现）

---
***同步问题的解决***

5. **信号量**：
· 信号量：
	· semaphore
	· 进程同步工具
	· 1965 年由 Dijkstra（荷兰）提出
	· 物理意义：表示资源的实体
	· 结构：
```C
typedef struct
{
	int value;
	struct process *L;
} semaphere
```
`value` 表示该类资源的当前可用数量
`L` 表示等待使用该类资源的阻塞进程队列的队首指针
	· 操作：
		· 初始化：将 value 初始化为该类资源的可用数量
		· 原子操作 P：申请资源
		· 原子操作 V：释放资源
			· 信号量 value 为负数时，其绝对值表示在该信号量上等待的进程数目
![|350](OS%20图/OS%20图2-14.png)
                           （图十四：原子操作 P 和原子操作 V）

· 利用信号量实现 n 个进程间的互斥：
	· 互斥信号量 mutex，初值为 $1$
	· 第 $i$ 个进程的执行代码：
~~~
do
{
	P(mutex)
	<critical section>
	V(mutex)
	<reminder section>
}
~~~

· 利用信号量实现进程间的同步
	· *这是满足让权等待的*
	· 示例：利用信号量实现计算进程与打印进程之间的同步过程
	· 假定计算进程和打印进程共同使用一个单缓冲
	· 信号量：
		· 计算进程：信号量 empty，表示缓冲区是否为空，初值为 $1$
		· 打印进程：信号量 full，表示缓冲区中是否有可供打印的计算结果，初值为 $0$
![|400](OS%20图/OS%20图2-15.png)
                            （图十五：计算进程与打印进程）

· 信号量分类：
	· 公用信号量：互斥信号量，用于解决进程之间互斥进入临界区，如 mutex
	· 私用信号量：同步信号量，用于解决异步环境下进程之间的同步，如 empty、full

6. **经典进程同步问题**：
· <font color="#00ffb0">生产者-消费者问题</font>：
	· 是相互合作进程关系的一种抽象
	· 生产者：当进程释放一个资源时，可把它看成是该资源的生产者
	· 消费者：当进程申请使用一个资源时，可把它看成该资源的消费者
		· 计算进程：打印数据的生产者；空缓冲的消费者
		· 打印进程：打印数据的消费者；空缓冲的生产者
	· 问题描述：
		· 假定有一组生产者（$M$ 个）和一组消费者（$N$ 个）进程，通过一个有界环形缓冲区（$k$ 个缓冲块）发生联系；生产者将生产的产品放入缓冲区，消费者从缓冲区取用产品
		· 当缓冲区满时，生产者要等消费者取走产品后才能向缓冲区放下一个产品
		· 当缓冲区空时，消费者要等生产者放一个产品入缓冲区后才能从缓冲区取下一个产品
	· 信号量：
		· empty：表示空缓冲块的个数，初值为 $k$
		· full：由数据的缓冲块个数，初值为 $0$
		· mutex：互斥访问临界区的信号量，初值为 $1$
![|195](OS%20图/OS%20图2-16.png)
                               （图十六：缓冲区的读和写）
![|500](OS%20图/OS%20图2-17.png)
                         （图十七：生产者-消费者问题代码示例）
· 注：红框中的两个 P 操作不可以交换顺序；蓝框中的两个 V 操作交换顺序没有影响
· 对于生产者，先加锁（P(mutex)），若没有空位置，则消费者无法为其腾出新位置，固产生死锁僵持
· 如果 empty<=0，则在 P(empty) 位置阻塞

· <font color="#00ffb0">读者-写者问题</font>：
	· 有一个多进程共享的数据区（可以说一个文件或者主存的一块空间），有一些只读取这个数据区的进程（reader）和一些只往数据区中写数据的进程（writer）：
		· 任意多的读进程可以同时读数据区
		· 一次只有一个写进程可以写数据区
		· 若有写进程正在写，禁止任何进程读
	· 信号量：
		· 读写互斥信号量 $db$：实现读写互斥和写写互斥访问共享文件，初值为 $1$
		· 计数器变量 $rc$：记录同时读的读者数，初值为 $0$
		· 读计数互斥信号量 $mutex$：使读者互斥地访问共享变量 $rc$，初值为 $1$
![|500](OS%20图/OS%20图2-18.png)
                           （图十八：读者-写者进程代码示例）

· <font color="#ffc000">读者优先时</font>：
```C
int rc = 0, db = 1, mutex = 1;

/*读者进程*/
begin
    P(mutex)
    rc += 1
    if(rc==1) P(db)
    V(mutex)
    读数据操作
    P(mutex)
    rc -= 1
    if(re==0) V(db)
    V(mutex)
end

/*写者进程*/
begin
    P(db)
    写数据操作
    V(db)
end
```
· 当缓冲区有读进程，读进程优先会使得当下一次先后到来的是写和读进程，写进程阻塞，但读进程进入
· 长久以来，写任务会饥饿

· <font color="#ffc000">公平竞争时</font>（下一次先后到来的是写和读进程，此时不允许读进程比写优先进）：
```C
int rc = 0, db = 1, mutex = 1, Z = 1;

/*读者进程*/
begin
	P(Z)
    P(mutex)
    rc += 1
    if(rc==1) P(db)
    V(mutex)
    V(Z)
    读数据操作
    P(mutex)
    rc -= 1
    if(re==0) V(db)
    V(mutex)
end

/*写者进程*/
begin
	P(Z)
    P(db)
    写数据操作
    V(db)
    V(Z)
end
```
· 信号量 Z 的引入使得此后先来的进程有申请优先权：写申请资源后，读进程不可进入，直到缓冲区中读进程全部离开，写进程先进入

· <font color="#ffc000">写进程优先</font>：
```C
int rc = 0, db = 1, mutex = 1, x = 1, mutex2 = 1, wc = 0;

/*读者进程*/
Begin
	P(x)
    P(mutex)
    rc += 1
    if(rc==1) P(db)
    V(mutex)
    V(x)
    读数据操作
    P(mutex)
    rc -= 1
    if(re==0) V(db)
    V(mutex)
end

/*写者进程*/
begin
    P(mutex2)
    wc += 1
	if(wc==1) P(x)
    V(mutex2)
    P(db)
	写数据操作
    V(db)
    P(mutex2)
    wc -= 1
    if(wc==0) V(x)
    V(mutex2)
end
```
· 写进程在写时不准读进程申请
· 读进程在读时允许写进程申请但是不能写
· 设置一个互锁机制（db 与 x），写进程的存在锁读进程的申请，读进程的存在锁写进程的工作

· <font color="#00ffb0">哲学家问题</font>：
· 假设有 5 个哲学家，花费一生的时光思考和吃饭
· 在桌子上放着 5 把叉子
· 一个哲学家要分两次去取其左边和右边的叉子
· 若得到两把叉子，就开始吃饭；吃完放下两把叉子
算法：
```C
fork: ARRAY[0-4] OF semaphere;
mutex: semaphere;
fork[0]:=fork[1]:=fork[2]:=fork[3]:=fork[4]:=1;
mutex:=1;
parbegin
Pi: REPEAT               /*第 i 个哲学家的活动情况*/
	Think FOR while;     /*思考一会儿，想吃饭*/
	P(mutex);            /*申请拿叉子*/
	P(fork[i]);
	P(fork[(i+1) MOD 5]);
	V(mutex);            /*释放申请权*/
	Eat FOR WHILE;       /*吃饭*/
	V(fork[i]);
	V(fork[(i+1) MOD 5]);
UNTIL false
parend
```

7. **管程**：
· 引入管程的原因：
	· 各个进程自备 P(S) 和 V(S) 操作，加重了用户负担
	· 大量同步操作分散在各个进程中，系统管理复杂
	· 易产生死锁
· 提出：1974 年有 Hansen 和 Hoare 提出
· 管程的定义：
	· 一个管程调用了一个数据结构和能为并发进程所执行（在该数据结构上）的一组操作，这组操作能同步进程和改变管程中的数据
	· 管程是关于共享资源的数据结构及一组针对该资源的操作过程所构成的<font color="#ffc000">软件模块</font>
	· *一次只有一个进程能在管程内活动*，从而提供互斥机制，保证管程数据的一致性
· 管程的结构：
	· 管程名
	· 局部于管程的共享变量说明
	· 对该数据结构进行操作的一组过程
	· 对局部于过程的数据设置初始值的语句
![|450](OS%20图/OS%20图2-19.png)
                                （图十九：管程的实现）
· 管程的特点：
	· 局部于管程的数据结构只能被局部于管程的过程所访问，任何管程外部的过程都不能访问它
	· 局部于管程的过程只能服务管程内的数据结构
	· 管程每次只允许一个进程进入管程，从而实现管程的互斥
· 管程的同步机制：
	· `条件变量 c`：
	· `同步原语 wait(c)`：执行 wait(c) 的进程将自己阻塞在条件变量 c 的相应等待队列中；在阻塞前，*释放管程的互斥使用权*
	· `同步原语 signal(c)`：执行 signal(c) 的进程检查条件变量 c 的相应等待队列；如果队列为空，则执行此操作的进程继续；否则，唤醒 c 队列中的第一个等待者，让被唤醒者进入该管程
![|400](OS%20图/OS%20图2-20.png)
                        （图二十：利用管程实现临界资源的互斥使用）
![|400](OS%20图/OS%20图2-21.png)
                        （图二十一：利用管程解决生产者-消费者问题）

###### 3. 消息传递通信：
![|400](OS%20图/OS%20图2-22.png)
                           （图二十二：消息传递通信中的缓冲区）
· 消息队列通常放在进程控制块中
· 在消息缓冲通信机制中，使用的临界资源是*整个消息队列*
· PCB 的结构：
```C
· PCB 的结构：
struct PCB
{
	……
	mq;    //消息队列队首指针
	mutex;    //消息队列互斥信号量
	sm;    //消息队列同步信号量
	……
}
```

· 消息传递通信：
	· 消息结构
	· 消息缓冲
	· 直接 / 间接通信
	· 同步 / 异步通信
```C
struct message_buffer
{
	sender：消息发送者
	receiver：消息接收者
	size：消息长度
	text：消息正文
	next：指向下一消息缓冲区指针
}
```

· 直接通信：
	· 消息发送原语：
		· send（接收者，被发送信息始址，信息长度）
		· 主要工作：
			· 请求分配一个消息缓冲区
			· 将消息正文传送到该缓冲区中，并填入有关发送参数
			· 将该消息缓冲区挂到接收进程消息链上
	· 消息接收原语：
		· receive（发送者，信息始址，接收区始址，信息长度）
		· 主要工作：
			· 检查消息链上是否有消息
			· 有则将消息接收到接收区
			· 无在*阻塞*等待消息的到来
```C
send(receiver, a)
{
	getbuf(a.size, i);
	i.sender=a.sender;
	i.size=a.size;
	i.text=a.text;
	i.next=0;
	getid(PCBset, receiver, j);
	P(j.mutex);
	Insert(j.mq, i);
	V(j.mutex);
	V(j.sm);
}
```
```C
receive(b)
{
	j=getid;
	P(j.sm);
	P(j.mutex);
	Remove(j.mq, i);
	V(j.mutex);
	b.sender=i.sender;
	b.size=i.size;
	b.text=i.text;
}
```

· 间接通信（信箱/端口通信）：
	· 间接通信方式
	· 发送原语：`send(A, message)`
	· 接收原语：`receive(A, message)`
	· 信箱属性：
		· 共享
		· 专用

· 消息同步：
	· 发送进程与接收进程状态：
		· 阻塞
		· 非阻塞
	· 消息同步方式：
		· 非阻塞发送，非阻塞接收
		· *非阻塞发送，阻塞接收*
		· *阻塞发送，阻塞接收*
		· 阻塞发送，非阻塞接收（尚未见过）

###### 4. 客户-服务器系统通信：

1. **Socket 通信**：
![|600](OS%20图/OS%20图2-23.png)
                           （图二十三：Socket 通信的实现）

2. **RPC（远程过程调用）通信**：
![|500](OS%20图/OS%20图2-24.png)
                            （图二十四：RPC 通信的实现）
![|400](OS%20图/OS%20图2-25.png)
                               （图二十五：RPC 的步骤）
· *远程过程调用*：
· 主要问题：
	· 客户存根
	· 服务器存根
	· 客户-服务器绑定
	· 参数传递：
		· Call-by-value
		· Call-by-reference
		· Call-by-copy / restore
	· 参数表示：
		· use a standard representation

3. **管道（Pipe）**：
· 概念：
连接一个读进程和一个写进程，允许它们以生产者-消费者方式进行通信的一个文件（文件大小受限）
· 几个问题：
	· 类型：有名管道 / 无名管道
	· 通信方式：单向 / 双向（半双工 / 全双工）
	· 通信进程间是否存在父子关系
	· 是否可以在网络上使用管道

· 无名管道（普通管道）：
	· 创建：
		· 由进程创建的临时文件
		· 无法从创建它的进程外部访问
		· 父进程创建一个管道，并使用该管道与其创建的子进程进行通信
	· 通信：
		· 以标准生产者-消费者方式进行通信
		· 单向通信，互斥访问管道：
			· 生产者写入一端（管道写入端）
			· 消费者从另一端读取（管道读取端）

· 有名管道：
	· 创建：
		· 由系统创建的长期存在的文件
		· 所有进程可通过路径名访问该管道
		· 所有进程均可访问有名管道
	· 通信：双向通信：半双工

###### 5. 死锁：

1. **基本概念**：
· 死锁概念：
	· 多个进程在运行过程中因争夺资源而造成的一种僵局，当进程处于这种僵持状态时，若无外力作用，所有进程都将无法向前推进
· 产生死锁的原因：
	1. 竞争资源（资源数量不足）
		· 资源类型：
			· 可抢占资源：主存、CPU
			· 不可抢占资源：慢速设备、共享变量
	2. 进程推进顺序非法
		· 请求和释放资源的顺序不当
![|400](OS%20图/OS%20图2-26.png)
                    （图二十六：请求和释放资源的顺序不当导致的死锁风险）

· <font color="#00ffb0">死锁产生的必要条件</font>（下列四个条件必须同时具备）：
1) `互斥条件`：每个资源是不可共享的，它或者已经分配给一个进程，或者空闲
2) `不可剥夺条件`：进程所获得的资源在未使用完之前，不能被其他进程强行剥夺，只能由获得资源的进程自己释放
3) `保持和等待条件`：进程因请求资源而被阻塞等待时，对已经分配给它的资源保持不放
4) `循环等待条件`：存在进程循环链，链中有两（多）个进程在等待链中下一个成员保持的资源
![|425](OS%20图/OS%20图2-27.png)
                   （图二十七：I/O 设备共享时的死锁和进程之间通信时的死锁）

· <font color="#ffc000">资源分配图</font>：
	· 由节点 $V$ 和边 $E$ 构成
	· 节点 $V$ 分为两类：
		· 进程节点：$P=\{P_1,P_2,\ldots,P_n\}$，用圆圈表示，构成了系统中的进程集合
		· 资源节点：$R=\{R_1,R_2,\ldots,R_m\}$，用方块表示，表示系统中的各种资源
	· 边 $E$ 分为两类：
		· 请求边—有向边 $P_1\to R_j$
		· 分配边—有向边 $R_j\to P_i$
![|600](OS%20图/OS%20图2-28.png)
                          （图二十八：各种资源分配图的示例）
· 结论：
	· 资源分配图中无环路 $\Rightarrow$ 无死锁
	· 资源分配图中有环路 $\Rightarrow$ 
		· 每类资源只有一个实例则无死锁
		· 每类资源有多个实例时，可能死锁
· 解决死锁的方法：
	· 忽略死锁问题，假定系统永不死锁
	· 保证系统永远不进入死锁状态：死锁预防、死锁避免
	· 允许系统进入死锁状态，并可从死锁状态中恢复：死锁检测、死锁恢复
![|450](OS%20图/OS%20图2-29.png)
                           （图二十九：解决死锁的诸多方法）

2. **鸵鸟算法**：
· 假定死锁从不发生
· 原因：
	· 死锁在计算机中很少出现
	· 预防死锁的代价太高

3. **死锁预防**：
· <font color="#00ffb0">破坏死锁产生的必要条件</font>
· 破坏互斥条件：
	· 资源特性
	· 将独享设备改造为共享设备
· 破坏非剥夺条件：
	· 当一个已经占有了一些资源的进程提出新的资源申请而不能立即得到满足时，必须释放已经占有的全部资源，待以后需要时再重新申请
	· 缺点：
		· 保护进程放弃资源时的现场及之后的恢复现场，系统要付出很高的代价
		· 增加了进程周转时间
· 破坏保持和请求条件：
	· 进程在开始运行前必须获得所需的全部资源；若系统不能满足，则该进程等待
	· 优点：简单、易于实现、安全
	· 缺点：资源利用率低，饥饿问题
· 破坏循环等待条件：
	· 将系统全部资源按类进行全局编号排序，进程对资源的请求必须按照资源的递增或递减顺序序号申请
	· 缺点：找到能满足所有进程要求的资源编号，限制新类型设备的增加

4. **死锁避免**：
· 死锁预防：静态分配资源
· 死锁避免：
	· 动态分配资源
	· 允许进程动态地申请资源，一次申请一部分资源；系统在进行资源分配之前，先计算资源分配的安全性；若此次分配不会导致系统进入不安全状态，便将资源分配给进程；否则，进程等待
· 系统处于安全状态 => 无死锁
· 系统处于不安全状态 => 可能死锁
· 避免死锁 => 保证系统永不进入不安全状态
· 安全状态：系统能按照某种进程顺序（$P_1,P_2,\ldots,P_n$）来为每个进程 $P_i$ 分配其所需资源，直至满足每个进程对资源的最大需求，使每个进程都可以顺利地完成
· 安全序列：（$P_1,P_2,\ldots,P_n$）
· 不安全状态：不存在一个安全序列
![|500](OS%20图/OS%20图2-30.png)
                         （图三十：安全状态存在一种安全序列）
![|500](OS%20图/OS%20图2-31.png)
                        （图三十一：不安全状态不存在安全序列）
![|500](OS%20图/OS%20图2-32.png)
                            （图三十二：银行家算法的原理）

· <font color="#00ffb0">银行家算法</font>：
· 1965 年由 Dijkstra 提出
· 数据结构：
	· $n$ 表示进程数目，$m$ 表示资源类型
	· 可用资源向量 $Available$：含有 $m$ 个元素的数组，每个元素代表一类可利用的资源的数目，初始值为系统中所配置的该类资源的全部可用数目；如果 $Available[j]=k$，则表示系统中现有 $R_j$ 类资源 $k$ 个
	· 最大需求矩阵 $Max$：$n\times m$ 的矩阵，定义了系统中 $n$ 个进程中的每一个进程对 $m$ 类资源的最大需求；如果 $Max[i,j]=k$，则表示进程 $P_i$ 需要 $R_j$ 类资源的最大数目为 $k$
	· 分配矩阵 $Allocation$：$n\times m$ 的矩阵，定义了系统中每一类资源当前已分配给每一进程的资源数目；如果 $Allocation[i,j]=k$，则表示进程 $P_i$ 当前已分配到 $R_j$ 类资源的数目为 $k$
	· 需求矩阵 $Need$：$n\times m$ 的矩阵，表示每一个进程还需要的各类资源的数目；如果 $Need[i,j]=k$，则表示进程 $P_i$ 还需要 $R_j$ 类资源 $k$ 个，才能完成其任务
	· 各个矩阵之间的关系：$Need[i,j]=Max[i,j]-Allocation[i,j]$
· 算法：
	· 设 $Request_i$ 是进程 $P_i$ 的请求向量，如果 $Request_i[j]=k$，表示进程 $P_i$ 需要 $k$ 个 $R_j$ 类的资源
	1. 如果 $Request_i[j]\leq Need[i,j]$，转向第 2 步；否则出错
	2. 如果 $Request_i[j]\leq Available[j]$，转向第 3 步；否则表示尚无足够资源，$P_i$ 须等待
	3. 假定将资源分配给进程 $P_i$，修改下列数据结构：$$Available[j]=Available[j]-Request_i[j]$$$$Allocation[i,j]=Allocation[i,j]+Request_i[j]$$$$Need[i,j]=Need[i,j]-Request_i[j]$$
	4. 系统执行安全性算法，检查此次分配后，系统是否处于安全状态：
		· 安全：资源分配给进程 $P_i$
		· 不安全：$P_i$ 等待，本次试探分配取消，恢复原来的资源分配状态

· *安全性算法*：
	1. 设置工作向量 $Work$，表示系统可提供给进程继续运行所需要的各类资源数目，它含有 $m$ 个元素，初始值为 $Work=Available$
	2. 设置向量 $Finish$，表示系统是否有足够的资源分配给进程使之运行完成，它含有 $n$ 个元素，初始值为 $Finish[i]=false$
	3. 从进程集合中查找能满足下列条件的进程：$$Finish[i]=false$$$$Need[i,j]\leq Work[j]$$若存在该进程，则转 4，否则执行 5
	4. 进程 $P_i$ 获得资源后可顺利执行至完成，并释放分配给它的资源，即执行：$$Work[j]=Work[j]+Allocation[i,j]$$$$Finish[i]=true$$
	5. 若所有进程均满足 $Finish[i]==true$，则系统处于安全状态；否则为不安全状态

· 示例：假定有五个进程 $\{P_0,P_1,P_2.P_3,P_4\}$，$3$ 类资源 $\{A,B,C\}$，各类资源的数目分别为 $10,5,7$
![|400](OS%20图/OS%20图2-33.png)
                        （图三十三：初始时刻资源分配情况示例图）
![|400](OS%20图/OS%20图2-34.png)
                            （图三十四：对于安全序列的找寻）
![|400](OS%20图/OS%20图2-35.png)
                          （图三十五：如果此刻 $P_1$ 进程请求资源）
![|400](OS%20图/OS%20图2-36.png)
                           （图三十六：$P_1$ 请求下的安全序列）
![|400](OS%20图/OS%20图2-37.png)
                           （图三十七：再当 $P_0$ 和 $P_4$ 请求资源时）
![|400](OS%20图/OS%20图2-38.png)
                       （图三十八：$P_0$ 的请求是会导致不安全状态的）

· *死锁避免补充*：
· 系统中有 $n$ 个并发进程共享使用 $m$ 个同类资源时，若每个进程需要的最大资源数量为 $x$，则仅当 $m$、$n$ 和 $x$ 满足如下不等式时，才能保证系统处于安全状态：$$n\times(x-1)+1\leq m$$（假设是资源最不容易满足的情况，每个进程都需要 $x$ 个资源，而恰好这些进程各自先申请 $x-1$ 个资源；已申请资源共 $n\cdot(x-1)$ 个；只有 $m$ 比这种最坏情况下多一个，才能保证没有死锁出现）
若已知 $m$ 和 $n$，则 $x$ 为：$$x=\begin{cases}1,\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ m\leq n\\ 1+\frac{m-1}{n},\ \ \ \ m\textgreater n\end{cases}$$

5. **死锁检测**：
· 系统在进行资源分配之后，计算资源分配的安全性；若此次分配会导致系统死锁，则采取措施恢复；否则，继续
· 对系统中的资源进程分配图进行检测，若图中包含了一个或多个循环，则存在死锁，否则不存在死锁
· 检测时机：
	· 每次资源请求时检测：较早检测到、浪费大量 CPU 时间
	· 间隔一段时间检测
· 示例：
	· 进程 A 保持资源 R，请求资源 S
	· 进程 B 没有保持资源，正在请求资源 T
	· 进程 C 没有保持资源，正在请求资源 S
	· 进程 D 保持资源 U，正在请求资源 S 和 T
	· 进程 E 保持资源 T，请求资源 V
	· 进程 F 保持资源 W，请求资源 S
	· 进程 G 保持资源 V，请求资源 U
![|450](OS%20图/OS%20图2-39.png)
                        （图三十九：带有死锁的进程资源图示例）

· <font color="#00ffb0">检测算法</font>（每类资源一个单位数量）：
1) 以途中的每个节点 N 为起始节点，分别执行下列步骤：
2) 将 L 初始化为空，表示所有弧均未标记
3) 将当前节点加到 L 的末端，检查该节点在 L 中是否出现过；如果出现，这个图包含一个环路，算法终止；如果没有，则转 4
4) 检查该节点是否有未标记的引出弧；如果有，转 5；若没有，转 6
5) 任意选择一个未标记的引出弧对其进行标记，标记后将引出弧所到节点作为新的当前节点，转 3
6) 若所有从该节点引出的弧都已标记，则返回至前一节点；如果该节点是最初开始的节点，则该图没有包含环路，算法终止；若该节点不是初始节点，以该节点作为当前节点，转 4
· 示例：R 节点：
L=【】，L=【R】，L=【R,A】，L=【R,A,S】
· 示例：B 节点：
L=【】，L=【B】，L=【B,T】，L=【B,T,E】，L=【B,T,E,V】，L=【B,T,E,V,G】，L=【B,T,E,V,G,U】，L=【B,T,E,V,G,U,D】，L=【B,*T*,E,V,G,U,D,*T*】

· <font color="#00ffb0">检查算法</font>（每类资源有多个）：
· 简化资源分配图，检查每个连接进程和资源的箭头：
1) 如果一个资源只有射出箭头（无未满足的资源请求），则擦除所有与其相关的箭头
2) 如果某个进程只有指向它的箭头（所有资源请求均已满足），则擦除所有与其相关的箭头
3) 如果某个进程有射出的箭头，并且对于每个请求箭头都有一个可用的资源（无射出箭头），则擦除所有与其相关的箭头：
	1) 检测所有进程，如果至少有一个进程的箭头可以擦除，则返回重复上述处理过程，直到没有箭头剩余或没有进程的箭头可以擦除为止
	2) 当且仅当没有箭头剩余，系统处于非死锁状态
![|425](OS%20图/OS%20图2-40.png)
                   （图四十：每类资源有多个时也可以用资源分配图检测死锁）

6. **死锁恢复**：
· 通过剥夺资源使系统恢复：
	· 通过剥夺一些进程的资源使系统恢复：最小代价
	· 通过回滚一些进程恢复系统：将一个或多个死锁进程回滚
	· 饥饿问题
· 通过撤销进程使系统恢复：
	· 撤销死锁进程，断开环路
	· 撤销不在环路中的非死锁进程

###### · --- 本章要点 ---：
- 进程通信方式
- 临界资源与临界区
- 信号量的意义及 P/V 操作
- 经典同步问题
- 管程
- 死锁的概念及产生死锁的必要条件
- 死锁处理策略
- 系统安全状态
- 银行家算法

