##### 1. `bitXor` 函数

**函数要求：**

| 函数名  | `bitXor`                |
| :--- | :---------------------- |
| 参数   | int，int                 |
| 功能实现 | $x$^$y$                 |
| 要求   | 只使用 `~` 和 `\|` 运算符将结果返回 |

**实现分析：**

· 根据异或公式 `x^y = x&~y|~x&y`，函数利用德摩根定律将其转换为仅使用 `~` 和 `|` 运算符的形式
· `x^y = x&~y|~x&y = ~(~x&~y|x&y)`

**函数实现：**

```C
int bitXor(int x, int y)
{
	return ~(x&y) & ~(~x&~y);
}
```

##### 2. `getByte` 函数

**函数要求**：

| 函数名  | `getByte`                                 |
| :--- | :---------------------------------------- |
| 参数   | int，int                                   |
| 功能实现 | 从字 $x$ 中取出第 $n$ 个字节                       |
| 要求   | 只使用运算符：`!`，`~`，`&`，`^`，`\|`，`+`，`<<`，`>>` |

**实现分析：**

· 将 $n$ 左移三位计算出字节的位置，右移操作将目标字节移到最低位
· 再和 `0xFF` 进行与操作，只保留目标字节的值

**函数实现：**
```C
int getByte(int x, int n)
{
	return (x>>(n<<3)) & 0xFF;
}
```

##### 3. `logicalShift` 函数

**函数要求：**

| 函数名  | `logicalShift`                            |
| :--- | :---------------------------------------- |
| 参数   | int，int                                   |
| 功能实现 | 字 $x$ 逻辑右移 $n$ 位                          |
| 要求   | 只使用运算符：`!`，`~`，`&`，`^`，`\|`，`+`，`<<`，`>>` |

**实现分析：**

· 实现对字 $x$ 的逻辑右移 $n$ 位，先提取符号位生成掩码，确保在逻辑右移时高位填充为零
· 右移 $x$ 后与掩码进行位与运算，实现逻辑右移

**函数实现：**
```C
int logicalShift(int x, int n)
{
    int mask = (x & (0xFF<<31));
    int inverse = ~((mask>>n)<<1);
    return (x>>n) & inverse;
}
```

##### 4. `bitCount` 函数

**函数要求：**

| 函数名  | `bitCount`                                |
| :--- | :---------------------------------------- |
| 参数   | int                                       |
| 功能实现 | 计算 $x$ 中 $1$ 的个数                          |
| 要求   | 只使用运算符：`!`，`~`，`&`，`^`，`\|`，`+`，`<<`，`>>` |

**实现分析：**

· 构造掩码 `mask`
· 函数开始时 `s` 通过 `x & mask` 计算出每组中 $1$ 的个数
· 依次通过右移操作统计相邻比特的 $1$，逐步累加到 `s` 中
· 在这个过程中，`s` 逐渐累加每组中的 $1$
· `s = s + (s >> 16)` 将高 16 位的结果加到低 16 位，确保所有位置的 $1$ 都被统计
· 然后用 `mask = 0xF | (0xF << 8)` 创建新的掩码，以处理每个字节内的 $1$ 的个数
· `s = (s & mask) + ((s >> 4) & mask)` 将字节内的结果相加
· 最后输出 `return (s + (s >> 8)) & 0x3F` 确保最终结果在正确的范围内，返回字 $x$ 中 $1$ 的总个数

**函数实现：**
```C
int bitCount(int x)
{
    int m1 = 0x11 | (0x11<<8);
    int mask = m1 | (m1<<16);

    int s = x & mask;
    s += (x>>1) & mask;
    s += (x>>2) & mask;
    s += (x>>3) & mask;

    s = s + (s>>16);
    mask = 0xF | (0xF<<8);
    s = (s & mask) + ((s>>4) & mask);

    return (s + (s>>8)) & 0x3F;
}
```

##### 5. `conditional` 函数

**函数要求：**

| 函数名  | `bitCount`                                |
| :--- | :---------------------------------------- |
| 参数   | int，int，int                               |
| 功能实现 | 实现 C 语言中的 $x?y:z$                         |
| 要求   | 只使用运算符：`!`，`~`，`&`，`^`，`\|`，`+`，`<<`，`>>` |

**实现分析：**

· 先用 `!x` 判断 $x$ 是否为零，生成掩码 `mask`：如果 $x$ 为零，`mask` 为全 $1$，否则为全 $0$
· 再用位与运算符将 `y` 和 `z` 与掩码进行处理
· `y & ~mask` 仅保留 $x$ 非零时的 $y$ 值，而 `z & mask` 仅保留 $x$ 为零时的 $z$ 值
· 最终位或返回相应的值

**函数实现：**
```C
int conditional(int x, int y, int z)
{
    int mask = !x << 31 >> 31;
    return (y & ~mask) | (z & mask);
}
```

##### 6. `tmin` 函数

**函数要求：**

| 函数名  | `tmin`                                    |
| :--- | :---------------------------------------- |
| 参数   | void                                      |
| 功能实现 | 返回最小的补码 $1000\ldots[0]$                   |
| 要求   | 只使用运算符：`!`，`~`，`&`，`^`，`\|`，`+`，`<<`，`>>` |

**实现分析：**

· 将 `0x1` 左移 31 位，生成一个最高位为 1 的整数，表示最小的补码值（1 开头，后全为 0）

**函数实现：**
```C
int tmin(void)
{
	return 0x1<<31;
}
```

##### 7. `fitsBits` 函数

**函数要求：**

| 函数名  | `fitBits`                                 |
| :--- | :---------------------------------------- |
| 参数   | int，int                                   |
| 功能实现 | $x$ 的补码是否可以表示成 $n$ 位                      |
| 要求   | 只使用运算符：`!`，`~`，`&`，`^`，`\|`，`+`，`<<`，`>>` |

**实现分析：**

· 构造掩码 `mask`，涵盖所有 $n$ 位的可能值
· 将 $x$ 右移 $(n + ~0)$ 位，以检查其在 $n$ 位内的表现
· 再使用 `!x` 检查 $x$ 是否为零，确保其可以表示为 $n$ 位
· 使用 `!(x^mask)` 检查 $x$ 是否等于最大 $n$ 位值
· 最后两个条件通过逻辑或运算结合，返回是否可以用 $n$ 位表示（1 是 0 否）

**函数实现：**
```C
int fitsBits(int x, int n)
{
    int mask = 0xFF + (0xFF<<8);
    mask = mask + (mask<<16);
    x = x >> (n + ~0);
    return !x | !(x^mask);
}
```

##### 8. `dividePower2` 函数

**函数要求：**

| 函数名  | `fitBits`                                 |
| :--- | :---------------------------------------- |
| 参数   | int，int                                   |
| 功能实现 | 计算 $\frac{x}{2^n}$                        |
| 要求   | 只使用运算符：`!`，`~`，`&`，`^`，`\|`，`+`，`<<`，`>>` |

**实现分析：**

· 先判断 $x$ 是否为负，生成一个偏移量 `offset`，确保正确处理负数的情况
· 当 $x$ 为正时，偏移量为 $0$，反之则为 $1$
· 接着使用 `x + (1 << (n & (offset + ~0))) + ~0` 计算 $x$ 的值，并在此基础上加上相应的偏移，以实现向下取整
· 最后将结果右移 $n$ 位，实现除以 $2^n$

**函数实现：**
```C
int dividePower2(int x, int n)
{
    int offset = !(x & (1<<31));
    x = x + (1 << (n & (offset + ~0))) + ~0;
    return x >> n;
}
```

##### 9. `negate` 函数

**函数要求：**

| 函数名  | `negate`                                  |
| :--- | :---------------------------------------- |
| 参数   | int                                       |
| 功能实现 | 不用负号得到 $-x$                               |
| 要求   | 只使用运算符：`!`，`~`，`&`，`^`，`\|`，`+`，`<<`，`>>` |

**实现分析：**

· 利用位运算，函数首先对 $x$ 进行按位取反操作 `~x`，然后加 1
· 根据补码的定义，按位取反后再加 1 就可以得到 $x$ 的负值

**函数实现：**
```C
int negate(int x)
{
    return ~x + 1;
}
```

##### 10. `howManyBits` 函数

**函数要求：**

| 函数名  | `howManyBits`                             |
| :--- | :---------------------------------------- |
| 参数   | int                                       |
| 功能实现 | 计算表达 $x$ 所需的最少位数                          |
| 要求   | 只使用运算符：`!`，`~`，`&`，`^`，`\|`，`+`，`<<`，`>>` |

**实现分析：**

· 通过对 $x$ 进行位运算，首先创建一个全 $1$ 的掩码 `mask`
· 使用 `signn = x ^ (x << 1)` 检测 $x$ 的符号位，这样可以判断 $x$ 是否为负
· 使用逐步检测的方式来确定所需的位数：通过检查 `signn` 与掩码左移的结果，逐步判断高 16 位、8 位、4 位、2 位和1 位的情况，并相应地更新 `bits` 计数
· 每次通过位运算进行判断时，使用 `!!` 确保返回值为 $0$ 或 $1$，从而有效累加所需的位数
· 返回的 `bits + 1` 包含符号位的计算，确保输出的位数能够正确表达 $x$ 的值

**函数实现：**
```C
int howManyBits(int x)
{
    int mask = ~0;
    int signn = x^(x<<1);

    int bits = 0;

    bits += (!!(signn & (mask<<16)))<<4;
    bits += (!!(signn & (mask<<(bits + 8))))<<3;
    bits += (!!(signn & (mask<<(bits + 4))))<<2;
    bits += (!!(signn & (mask<<(bits + 2))))<<1;
    bits += !!(signn & (mask<<(bits + 1)));

    return bits + 1;
}
```

##### 11. `isLessOrEqual` 函数

**函数要求：**

| 函数名  | `isLessOrEqual`                           |
| :--- | :---------------------------------------- |
| 参数   | int，int                                   |
| 功能实现 | 判断是否满足 $x\leq y$                          |
| 要求   | 只使用运算符：`!`，`~`，`&`，`^`，`\|`，`+`，`<<`，`>>` |

**实现分析：**

· 首先计算差值 `diff = x + ~y + 1`，相当于 $x - y$
· 通过检查 `diff` 的符号位，使用 `mask = 0x1 << 31` 提取符号位，`p = !(diff & mask)` 用于判断差值的符号，表示 $x - y$ 是否非负
· 再提取 $x$ 和 $y$ 的符号位，`sign_x` 和 `sign_y` 判断它们是否为正
· 利用 $x$ 和 $y$ 的符号位差异，变量 `k` 进一步区分 $x$ 和 $y$ 的正负情况
· 根据符号的不同情况，分别计算 `sign_x` 和 `sign_y` 来判断 $x \leq y$ 的条件
· `(sign_x | sign_y)` 返回 $x \leq y$ 的结果

**函数实现：**
```C
int isLessOrEqual(int x, int y)
{
    int mask = 0x1<<31;
    int diff = x + ~y + 1;
    int p = !(diff & mask);
    int sign_x = !(x & mask);
    int sign_y = !(y & mask);

    int k = sign_x + 1 + ~sign_y;
    sign_x = (!k) & ((!diff) | (!p));
    sign_y = k &!!(k^0x1);

    return (sign_x | sign_y);
}
```

##### 12. `intLog2` 函数

**函数要求：**

| 函数名  | `intLog2`                                 |
| :--- | :---------------------------------------- |
| 参数   | int                                       |
| 功能实现 | 计算 $\lfloor log_2x\rfloor$                |
| 要求   | 只使用运算符：`!`，`~`，`&`，`^`，`\|`，`+`，`<<`，`>>` |

**实现分析：**

· 逐步检测 $x$ 中最高有效位的位置
· 将 $x$ 右移 16 位，通过 `b4 = !!(x >> 16)` 检查前 16 位是否存在有效位，如果有，则结果至少为 16
· 每次继续检查剩下的高位部分，分别对剩余的 8 位、4 位、2 位和 1 位进行检测，通过位运算判断是否有相应的有效位存在
· 每次检测时，将结果左移并累加，以逐步构造最终的对数值
· `result` 包含了 $x$ 的最高有效位的索引值，这个值就是 $\lfloor \log_2{x} \rfloor$

**函数实现：**
```C
int intLog2(int x)
{
	int result = 0;
    int b4 = !!(x >> 16);
    int b3 = 0;
    int b2 = 0;
    int b1 = 0;
    int b0 = 0;
    result = b4 << 4;
    b3 = !!(x >> (8 + result));
    result = result | (b3 << 3);
    b2 = !!(x >> (4 + result));
    result = result | (b2 << 2);
    b1 = !!(x >> (2 + result));
    result = result | (b1 << 1);
    b0 = !!(x >> (1 + result));
    result = result | b0;
    return result;
}
```

##### 13. `floatAbsVal` 函数

**函数要求：**

| 函数名  | `floatAbsVal`                                               |
| :--- | :---------------------------------------------------------- |
| 参数   | unsigned int                                                |
| 功能实现 | 计算 $uf$ 的绝对值的位级表示                                           |
| 要求   | 可以使用任何整数或无符号运算，包括逻辑运算符 `\|\|` 和 `&&`，以及控制流语句 `if` 和 `while` |

**实现分析：**

· 用 `uf & 0x7F800000` 提取浮点数的指数部分，检查是否为特殊值（如 NaN）
· 若指数部分为 255 且 `uf<<9` 表示数值非零（即 NaN），则直接返回原值 `uf`
（因为 NaN 的绝对值仍为 NaN）
· 否则通过 `uf & 0x7FFFFFFF` 清除符号位，返回非负数的浮点表示，实现绝对值的计算

**函数实现：**
```C
unsigned floatAbsVal(unsigned uf)
{
    unsigned abs = uf & 0x7F800000;
    if(abs>>23==255 && uf<<9) return uf;
    return uf & 0x7FFFFFFF;
}
```

##### 14. `floatScale1d2` 函数

**函数要求：**

| 函数名  | `floatScale1d2`                                             |
| :--- | :---------------------------------------------------------- |
| 参数   | unsigned int                                                |
| 功能实现 | 计算 $0.5\times uf$ 的位级表示                                     |
| 要求   | 可以使用任何整数或无符号运算，包括逻辑运算符 `\|\|` 和 `&&`，以及控制流语句 `if` 和 `while` |

**实现分析：**

· 提取符号位 `sign` 和指数部分 `exponent`，确定浮点数的基本信息：如果 $uf$ 为 NaN 或无穷大（即指数为 255），则直接返回原值，因为这些特殊值不受缩放影响
· 对于正常值，如果指数大于 1，则通过将指数减 1 来实现将数值缩小一倍
· 否则对于接近零的浮点数（指数为 1 或非规格化数），通过右移处理尾数位，同时保留符号位
· 为保证舍入正确性，若最低两位为 `0x3`，则进行加 2 的操作来实现舍入

**函数实现：**
```C
unsigned floatScale1d2(unsigned uf)
{
    int sign = uf & 0x80000000;
    int exponent = (uf>>23) & 0xFF;
    if((uf & 0x7FFFFFFF)>=0x7F800000) return uf;
    if(exponent>1)
    {
		uf = (uf & 0x807FFFFF) | ((exponent-1)<<23);
		return uf;
    }
    if((uf & 0x3)==0x3) uf += 0x2;
    return ((uf>>1) & 0xBFFFFFFF) | sign;
}
```

##### 15. `floatFloat2Int` 函数

**函数要求：**

| 函数名  | `floatFloat2Int`                                            |
| :--- | :---------------------------------------------------------- |
| 参数   | unsigned int                                                |
| 功能实现 | 计算 （int）$uf$ 的位级表示                                          |
| 要求   | 可以使用任何整数或无符号运算，包括逻辑运算符 `\|\|` 和 `&&`，以及控制流语句 `if` 和 `while` |

**实现分析：**

· 提取浮点数的指数部分 `exponent` 和尾数部分 `fraction` 来重构实际值
· 指数通过减去偏移量 127 来转换为整数形式
· 若指数小于 0，则表示浮点数小于 1，直接返回 0
· 若指数大于 31，表示溢出，返回 `0x80000000` 作为错误值
· 之后根据指数的大小，调整尾数的位数，以得到正确的整数值
· 最后检查符号位 `sign`，如果为负，则返回负数

**函数实现：**
```C
int floatFloat2Int(unsigned uf)
{
    int exponent = ((uf & 0x7f800000) >> 23) - 127;
    unsigned fraction = (uf & 0x007FFFFF) | 0x00800000;
    unsigned sign = uf >> 31;

    if(exponent < 0) return 0;
    if(exponent > 31) return 0x80000000u;
    if(exponent > 23) fraction << = (exponent - 23);
    else fraction >> = (23 - exponent);
    if(sign) return - fraction;
    else return fraction;
    return 0;
}
```

