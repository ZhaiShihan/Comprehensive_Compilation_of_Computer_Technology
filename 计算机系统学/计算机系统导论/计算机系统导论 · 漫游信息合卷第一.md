### 壹  计算机系统漫游

#### 述：
##### 我自乘龙欲天齐，天开风旋折白翼。
##### 百跌九阻魂不散，残傲凌霜振血羽。

###### · 五个重要事实：

· ***事实一***：
· <font color="#ffc000">int 不是整数，float 不是实数</font>（Ints are not Integers，Floats are not Reals）
· 示例 1：x 的平方总是大于 0 吗？对于 float 是成立的，对于 int 不总是成立的：
· 40000 * 40000 = 1600000000
· 50000 * 50000 溢出
· 示例 2：加法结合律总是成立吗？对于 unsigned int 和 int 是成立的，对于 float 不总成立：
· ( 1e20 + -1e20) + 3.14 = 3.14
· 1e20 + ( -1e20 + 3.14 ) 大数“吃”小数

· 计算机算术的特点：
	1. 不会产生随机值（数学性质）
	2. 不能假设所有“通常”数学性质成立
	3. 观察理解哪些抽象适用于哪些上下文

· ***事实二***：
· <font color="#ffc000">必须懂汇编语言</font>（You' re Got to Know Assembly）
· 理解汇编对机器级执行模式很关键：
	1. 出现错误时的程序行为（如高级语言模型的失灵）
	2. 调优程序性能（如理解编译器完成与未完成的优化工作，理解程序低效来源）
	3. 理解汇编对机器级执行模式来说是关键（如实现系统软件，创建与对抗恶意软件）

· ***事实三***：
· <font color="#ffc000">存储器很重要</font>（Memory Matters）
· 随机访问存储器是一种非物质抽象（Random Access Memory Is an Unphysical Abstraction）：
	1. 内存不是无限界的，它必须进行分配和管理，很多应用都受内存空间的限制
	2. 内存引用错误特别有害，在时间和空间上都是影响滞后的
	3. 存储器性能并不一致，高速缓冲和虚拟存储器可以显著影响程序性能，根据存储系统特点调整程序可以带来很大速度改进

· 示例：内存引用错误示例
```C++
typedef struct
{
	int a[2];
	double d;
} struct_t;

double fun(int i)
{
	volatile struct_t s;
	s.d=3.14;
	s.a[i]=1073741824; /* Possibly out of bounds */
	return s.d;
}
```
![|350](CSAPP%20图/CSAPP%20图1-1.png)
                           （图一：内存引用错误示例输出及原理）
· C 语言和 C++ 不提供任何内存保护
	1. 数组引用超界
	2. 不合法的指针值
	3. 分配和释放内存滥用
· 可能导致严重的错误
	· 是否错误有任何影响取决于系统和编译器
	· 在远处产生影响：破坏的对象逻辑上和访问的对象毫不相关，错误的效果第一次观察到可能距离产生的时间很长
	· 错误处理：采用 Java、Ruby、Python、ML 等语言编程，理解可能会发生什么相互影响，使用或开发工具来检测引用错误（例如Valgrind ）

· ***事实四***：
· <font color="#ffc000">性能不仅仅是渐进复杂度</font>（There is more to performance than asymptotic complexity）：
	· 常数因子也很重要
	· 精确的操作系统也难以预测性能：很容易发现 10 倍性能差异取决于如何编写代码，必须在多个级别进行优化：算法、数据表示、过程和循环
	· 必须理解系统才能优化性能：程序是如何编译和执行的，如何测量程序性能和识别瓶颈，如何改进性能同时不破坏代码的模块性和通用性

· 示例：内存系统性能示例
![|450](CSAPP%20图/CSAPP%20图1-2.png)
                      （图二：内存系统性能测试——二维数组遍历方式）
· 层次化存储器组织（Hierarchical memory organization）
· 性能依赖于访问模式（Performance depends on access patterns）包括如何设置步长遍历多维数组
![|350](CSAPP%20图/CSAPP%20图1-3.png)
                       （图三：二维数组遍历方式导致的性能差异解释图）

· ***事实五***：
· <font color="#ffc000">计算机不仅执行程序还做更多的事情</font>（Computers do more than execute programs）
· 计算机需要完成数据输入和输出，I/O 系统对程序的可靠性和性能至关重要
· 计算机通过网络进行彼此通信，很多系统级问题由于网络引起（如自治进程的并发操作，处理不可靠的传输介质，跨平台的兼容性，复杂的性能问题）

###### · 计算机系统漫游：

1. ***编译系统***：
· 跟踪 hello 程序的生命周期：
```C++
int main()
{
	print("hello, world\n");
	return 0;
}
```
· 信息就是比特位+上下文（Information Is Bits + Context）
![|500](CSAPP%20图/CSAPP%20图1-4.png)
                         （图四：hello.c 文件的 ASCll 文本表示）
· 信息由一串*比特位*表示，区分不同数据对象的是*上下文*

- 实用程序 Utilities：
	· 编程语言：ANSI C
	· 编译器：GNU-gcc——GNU Compiler Collection（GNU 编译器套件）
	· 工具：GNU tool chain 工具链

- 编译系统 Compilation System：
	· Linux> gcc -o hello hello.c
![|450](CSAPP%20图/CSAPP%20图1-5.png)
                             （图五：编译系统的运行过程）

- GNU 不是 Unix
	· 自由软件 Free software
	· Richard Stallman，1984
	· 完整的类 Unix 系统，有源代码
	· 一套环境：Unix 系统所有主要组件
	· 不包括内核

- C 编程语言：
	· C 语言创建于 1969-1973，由美国贝尔实验室
	· 美国国家标准学会（ANSI）于 1989 年正式批准了ANSI C 标准
	· 该标准定义了C language 以及一组库函数，称为 C 语言标准库
	· Kernighan and Ritchie 在他们的经典著作中描述了ANSI C
	· 用 R 的话来说，C 语言是：古怪的（quirky）、有缺陷的（flawed）、同时也是巨大的成功（and an enormous success）

	· C 语言与 Unix 操作系统关系密切：
		· C 语言从一开始就是作为 Unix 系统编程语言而开发出来的
		· 大部分 Unix 内核以及所有支持工具和库函数都是用 C 语言编写的
		· 随着 70 年代后期到 80 年代早期 Unix 在大学广泛流行，许多人开始接触 C 语言并喜欢上它
		· 由于 Unix 几乎全部是用 C 编写的，它可以很方便地移植到新的机器，这种特点为 C 和 Unix 赢得了更为广泛的支持

	· C 语言小而简单：
		· 设计是由一个人而非一个协会掌控的，因此是一个简洁，没有什么冗赘的设计
		· K&R 这本书用大量的例子和练习描述了完整的语言及标准库，全书不过 261 页
		· C 语言的简单性使它相对易于学习和移植到不同的计算机上

	· C 语言是为实践目的设计的：
		· C 语言是设计用来实现 Unix 操作系统的
		· 后来其他人发现能够用这门语言无障碍地编写他们想要的程序

	· C 语言是系统级编程的首选
	· 它也非常适用于应用级程序的编写

	· 然而它也并非适用于所有程序员和所有情况：
		· C 语言的指针是造成困惑和编程错误的一个常见原因
		· C 语言也缺乏有用抽象的显式支持，例如类和对象
		· 像 C++ 和 Java 这样针对应用级程序的新语言解决了这些问题

- C 语言标准化：
	· 原始贝尔实验室 C 语言版本，K&R 著作的第 1 版 
	· 1989 年发布 ANSI C 标准，美国国家标准学会，修改了函数声明的方式，K&R 著作的第 2 版，ISO C90（The International Standards Organization 国际标准化组织）
	· ISO C99 引入了一些新的数据类型，对使用不符合英语语言字符的文本串提供了支持
	· Gcc 支持

2. ***计算机系统***：
- 第一台通用目的计算机：
	· ENIAC：
		· 电子数字积分计算机 Electronic Numerical Integrator And Computer
		· 1946 年宾夕法尼亚大学出品 Delivered by UPenn. on Feb. 14, 1946
		· John Mauchly，John Eckert

- 计算机硬件—冯 · 诺伊曼（Von Neumann）体系结构：
![|425](CSAPP%20图/CSAPP%20图1-6.png)
                        （图六：冯 · 诺伊曼计算机硬件体系结构）
· DEVAC：电子离散变量自主计算机

· 处理器读并解释存储在内存中的指令

- 系统的硬件组成（Hardware organization of system）：
![|450](CSAPP%20图/CSAPP%20图1-7.png)
                      （图七：处理器读并解释存储在内存中的指令）
![|425](CSAPP%20图/CSAPP%20图1-8.png)
                          （图八：运行 hello 程序的输入两阶段）
![|425](CSAPP%20图/CSAPP%20图1-9.png)
            （图九：将可执行文件从磁盘加载到主存中，因为磁盘中文件以块的形式组织）
![|425](CSAPP%20图/CSAPP%20图1-10.png)
                        （图十：将输出字符串从内存写入显示器）

- 高速缓存（Caches）至关重要：
	· 处理器和内存速度鸿沟持续增大
	· 更小和快速的存储设备称为 cache 存储器（简称 chche）
	· 用称为静态随机访问存储器硬件技术实现（SRAM）
![|425](CSAPP%20图/CSAPP%20图1-11.png)
                            （图十一：存储设备的层次结构）
· **口诀**：
<font color="#00ffb0">零阶最高寄存器，高速缓存分三级。</font>
<font color="#00ffb0">主存二级为本地，远程结末逐层取。</font>

3. ***操作系统***：
- 操作系统的发展史：
	· 1960’s
		· IBM OS/360，Honeywell Multics
	· Fernado Jose Corbató
		· IEEE Computer Pioneer Award，1982
		· ACM Turing Award，1990
	· Unix
		· Bell Lab，DEC PDP-7，1969
		· Ken Thompson，Dennis Ritchie，Doug Mcllroy，Joe Ossana
		· 1970 Brian Kernighan dubbed the system “Unix”
		· Rewritten in C in 1973，announced in 1974
		· BSD（UC，Berkeley），System V（Bell lab）
		· Solaris (Sun Microsystem)
	· Posix standard
	· Ken Thompson，Dennis Ritchie
		· ACM Turing Award，1983
	· Linux
		· 1991，Linus Torvalds
		· Unix-like operating systems
		· 386 (486) AT，bash (1.08)，gcc (1.40)
		· Posix complaint version of Unix operating system
		· Available on a wide array of computers
		· From handheld devices to mainframe computers
		· wristwatch

- 操作系统管理硬件：
![|425](CSAPP%20图/CSAPP%20图1-12.png)
                            （图十二：操作系统管理硬件）
· **硬件口诀**：
 <font color="#00ffb0">I O 主存 C P U，文件虚拟进程兜。</font>

· 将操作系统看作应用程序和硬件之间插入的一个软件层
	· 两个基本目的：
		1. 保护硬件防止被失控的应用误用
		2. 给应用提供简单统一的机制操作复杂和差异巨大的低层硬件设备
	· 基本抽象：进程、虚存和文件
		1. 文件是 I/O 设备的抽象
		2. 虚拟存储器是主存和磁盘 I/O 设备的抽象
		3. 进程是处理器、主存和 I/O 设备的抽象

· 进程的上下文切换：
	· <font color="#ffc000">进程是操作系统对运行程序的抽象</font>
![|550](CSAPP%20图/CSAPP%20图1-13.png)
                           （图十三：进程的上下文切换示例）

- 虚拟存储器（Virtual Memory）：
	· 每个进程有同样一致的内存视图，称为进程的虚地址空间
![|450](CSAPP%20图/CSAPP%20图1-14.png)
                            （图十四：进程的虚拟地址空间）

- 系统之间使用网络通信：
	· 网络也是一种 I/O 设备，计算机之间使用网络进行连接
![|500](CSAPP%20图/CSAPP%20图1-15.png)
                             （图十五：系统之间网络通信）
	· 计算机系统支持云计算（Cloud Computing）

4. ***计算机系统几大重要主题***：
- Amdahl 定律：
	- 对系统的某个部分加速时，其对系统整体性能的影响取决于该部分的重要性和加速程度
$$S=\frac{1}{(1-\alpha)+\frac{\alpha}{k}}$$
	· 该部分时间占比为 $\alpha$
	· 该部分性能改进提高 $k$ 倍
	· 必须提升在总体系统中占比非常大的部分的速度
$$S_{\infty}=\frac{1}{(1-\alpha)}$$

- 并发和并行：
	· 并发指同时具有多个活动的系统这个通用概念
	· 并行指用并发使系统运行更快
	· 并行可以在计算机系统的多个抽象层次上运用
	· 三个层次，在系统层次结构中从最高到最低级

	· 线程级并发：
		· 在进程抽象基础上，多个程序同时执行，导致并发
		· 使用线程可以在单一进程中有多个控制流
		· 从单处理器系统到多处理器系统，最近多核和超线程
		· 超线程称为同时多线程，是一项允许单一 CPU 执行多个控制流的技术
		· 要求程序必须以多线程方式编写

	· 指令级并行：
		· 现代处理器可以一次执行多条指令，称为指令级并行
		· 流水线的使用，接近一个时钟周期一条指令的执行速率
		· 比一个周期一条指令更快的执行速率，称为超标量处理器

	· 单指令流多数据流（SIMD）并行 ：
		· 单条指令引起并行执行多个操作
		· 某些编译器尝试自动从 C 程序抽取 SIMD 并行性
		· 自己使用编译器支持的特殊向量数据类型编写程序

- 计算机系统的抽象：
	· 计算机系统中抽象的重要性：抽象的使用是计算机科学中最为重要的概念之一

	· 计算机系统中使用的几个抽象：
		· **指令集体系结构提供实际处理器硬件的抽象**
		· 操作系统提供三个抽象：
			· **文件作为 I/O 设备抽象**
			· **虚存作为程序内存的抽象**
			· **进程作为运行程序的抽象**
		· 新抽象：
			· **虚拟机提供整个计算机的抽象**，包括 OS、处理器和程序

5. ***响应时间和吞吐量***：
· 响应时间 Response time：做一项任务所需时间
· 吞吐量 Throughput：每单位时间完成的总工作量

· 定义**性能**为：$\frac{1}{执行时间}$

· 相对性能：程序在 X 运行时间和在 Y 运行时间之比为 $n$，则相对性能：$Y/X=n$

· 测量执行时间：
	· 经历时间 Elapsed time：
		· 即总响应时间，包括所有方面：处理、I/O、操作系统开销、空闲时间
		· 决定了系统性能
	· CPU 时间 CPU time：
		· 对于指定的作业花费在处理上的时间：减掉 I/O 时间，其他作业共享时间
		· 由用户 CPU 时间和系统 CPU 时间构成
		· 不同程序受 CPU 和系统性能的影响不同

- CPU 时钟周期：
	· 数字硬件的操作受固定时钟速率控制
![|500](CSAPP%20图/CSAPP%20图1-16.png)
                            （图十六：CPU 时钟周期示例）
	· 时钟周期：一次时钟循环持续时间
	· 时钟频率（速率）：每秒钟的周期数

· CPU 时间：$$CPU\ 时间=CPU\ 时钟周期数\times 时钟周期时间=\frac{CPU\ 时钟周期数}{时钟速率}$$
· 改进性能手段：减少时钟周期数量，增加时钟速率，硬件设计师必须经常在时钟速率和周期数间进行折中

· CPI（Instruction Count and CPI，每条指令的时钟周期数）：
$$时钟周期数=指令数\times每条指令的时钟周期数\ (即\ CPI)$$$$CPU\ 时间=指令数\times CPI\times时钟周期时间=\frac{指令数\times CPI}{时钟速率}$$
· 程序的指令数由程序、ISA（Instruction Set Architecture，指令集架构）和编译器决定
· 平均 CPI 由 CPU 硬件决定，如果不同指令有不同的 CPI，则平均 CPI 受指令混合程度影响 

· 如果不同类型指令需要不同的时钟周期数：$$时钟周期=\Sigma_{i=1}^n(CPI_i\times指令数_i)$$
· 加权平均 CPI 为：$$CPI=\frac{时钟周期}{指令数总数}=\Sigma_{i=1}^n(CPI_i\times\frac{指令数_i}{指令数总数})$$
其中：$\frac{指令数_i}{指令数总数}$ 称为“相对比率（relative frequency）”
![|450](CSAPP%20图/CSAPP%20图1-17.png)
                            （图十七：平均 CPI 计算示例）

- 性能小结：

A. CPU 时间：
$$CPU\ Time=\frac{Instructions}{Program}\times\frac{Clock\ cycles}{Instruction}\times\frac{Seconds}{Clock\ cycles}$$
$$CPU\ 时间=每个程序指令数\times每条指令的时钟周期数\times每个时钟周期的时间$$

B. 性能取决于：
	· 算法：影响 IC（指令数），可能影响 CPI
	· 编程语言：影响 IC、CPI
	· 编译器：影响 IC、CPI
	· 指令集体系结构：影响 IC、CPI 和时钟周期 $T_c$

- MIPS（Millions of Instructions Per Second，每秒钟执行百万条指令）：
$$MIPS=\frac{Instruction\ count}{Execution\ time\times10^6}=\frac{Instruction\ count}{\frac{Instruction\ count\times CPI}{Clock\ rate}\times10^6}=\frac{Clock\ rate}{CPI\times10^6}$$
· 注：此处并未考量：不同计算机之间的 ISA 不同，不同指令之间的复杂度不同

· 在特定的 CPU 上在不同程序之间 CPI 是变化的


### 贰  信息的表示与处理

#### 述：
#####
#####

###### · 比特、字节和整数（Bits, Bytes, and Integers）：

1. ***用比特表示信息（Representing information as bits）***：
- 十进制表示：
	· 基数为 10
	· 已经使用了超过 1000 年
	· 起源于印度 Developed in India
	· 12 世纪被阿拉伯数学家改进
	· 13 世纪被带到西方：意大利数学家斐波那契

- 一切均是比特位：
	· 每个比特是 0 或 1
	· 以各种方式编码/解释比特位集合：
		· 计算机确定要做什么（指令）
		· 以及表示和操作数值、集合、字符串等
	· 比特易于用稳态元件存储
	· 在有噪声和不精确的电缆中可靠传输
![|550](CSAPP%20图/CSAPP%20图1-18.png)
                          （图十八：用电信号的形式表示比特）

- 二进制计数：
	· 基数为 $2$ 的数制表示：$0$，$1$，$10$，$11$，$100$，$101$，……
	· 十进制整数表示为二进制整数：$15213_{10}=11101101101101_2$
	· 十进制小数表示为二进制小数：$1.20_{10}=1.0011001100110011[0011]\ldots_{2}$
	· 十进制科学计数法表示为二进制科学计数法：$1.5213\times10^4=1.1101101101101_2\times2^{13}$

	· 二进制数的性质：$1+1+2+4+8+\cdots+2^{w-1}=2^w$，即：$1+\Sigma_{i=0}^{w-1}\ 2^i=2^w$
	（当 $w=0$ 时，$1=2^0$ ）

- 多个位组成组：
	· 孤立地看，单个位不是很有用
	· 在英语中，它的字母表中有 26（或 52）个字符，它们单独使用也没有用
	· 然而，它的词汇表中有很多单词
	· 同样，我们可以使用多个位（而不是单个位）来表示任何有限集的元素

	· 为此，我们首先把多个比特组合在一起
	· 然后应用某种解释给不同的可能位模式
	· 给每个模式一个意义
	· 1956 年 7 月维纳博士提出：8 位数据块组织成一个字节（$1\ byte=8\ bits$）
	（IBM 草稿计算机早期设计阶段）

	· 由于一个字节包含 8 个比特位，故一个字节表示的十进制数取值范围是 $0_{10}$ 到 $2^8-1=255_{10}$
	· 二进制取值范围：$00000000_2$ 到 $11111111_2$
	· 十六进制取值范围：$00_{16}$ 到 $FF_{16}$

- 十六进制与二进制：
	· 十六进制在 C 语言中前导为“`0x`”
	· 十六进制和二进制的转化：四位一划分，一位分四位

· 组合字节以创建标量数据类型：

| C Data Type | Typical 32-bit | Typical 64-bit |
| :---------- | :------------- | :------------- |
| char        | 1              | 1              |
| short       | 2              | 2              |
| int         | 4              | 4              |
| long        | 4              | 8              |
| float       | 4              | 4              |
| double      | 8              | 8              |
| pointer     | 4              | 8              |
| unsigned    | 4              | 4              |
|             | "ILP32"        | "LP64"         |

2. ***比特级操作（Bit-level manipulations）***：
- 布尔代数（Boolean Algebra）：
	· 19 世纪由布尔开发
	· 逻辑的代数表示：逻辑值真和假编码为 1 和 0
![|500](CSAPP%20图/CSAPP%20图1-19.png)
                           （图十九：布尔代数基本运算规则）
· 布尔代数的应用：
	· 由香农应用到数字系统中，信息论的奠基人
	· 1937 年 MIT 硕士论文，对继电器开关网络进行推理（开关闭合编码为 1，开关打开为 0）
![|450](CSAPP%20图/CSAPP%20图1-20.png)
                        （图二十：继电器开关网络中的布尔代数）
· 一般布尔代数：
	· 对比特位向量进行运算，将运算运用到每个比特位
	· 布尔代数的所有性质都可运用
![](CSAPP%20图/CSAPP%20图1-21.png)
（图二十一：对比特位向量进行运算示例）

- 三基色模型（RGB Color Model）：
![|350](CSAPP%20图/CSAPP%20图1-22.png)
                               （图二十二：三基色的混一）
![|350](CSAPP%20图/CSAPP%20图1-23.png)
                          （图二十三：三基色模型中的布尔代数）

- C 语言中的比特级运算：
	· C 中可用运算 Operations &, |, ~, ^
	· 可以运用到任何整数类数据类型，参数视为比特位向量，运用到每个比特位

· 异或的整数“交换”作用：
![|400](CSAPP%20图/CSAPP%20图1-24.png)
                            （图二十四：异或的整数交换作用）
· <font color="#ffc000">代码</font>：
```C++
void inplace_swap(int *x, int *y)
{
	*x=*x^*y; /*#1*/
	*y=*x^*y; /*#2*/
	*x=*x^*y; /*#3*/
}

void reserve_array(int a[], int cnt)
{
	int first, last;
	for(first=0, last=cnt-1; first<last; first++, last--)
	{
		inplace_swap(&a[first], &a[last]);
	}
}
```

- 掩码操作：
	· 位模式 bit pattern
		· `0xFF`
		· 最低 8 个有效位为 1
		· 指明一个字的最低字节
	· 掩码操作 Mask Operation
		· X = `0x89ABCDEF`
		· X & `0xFF` = `0xEF`
	· 写 C 表达式使其对任何字长 w 大于等于 8 的数都能适用：
		· x = `0x87654321`，with w = 32
		· 取 x 的最低有效字节，其它位都设为 0（如 `0x00000021`）：x & `0xFF`
		· x 的最低有效字节不变，所有其它位变反（取补）：x ^ ~`0xFF`
		· x 的最低有效字节设置为全 1，所有其它字节保持不变：x | `0xFF`
	· 位设置和位清除：
		· 设置结果 z 为 x 并进行修改
		· z = bis (int x, int m)（位设置 bit set）= `x|m`
			· 在 m 为 1 的每个位置上，将结果 z 的对应位设置为 1
		· z = bic (int x, int m)（位清除 bit clear）= `x&~m`
			· 在 m 为 1 的每个位置上，将结果 z 的对应位设置为 0
		· DEC 公司的 VAX 机
		· 使用位设置和位清除来实现目标：
			1. Or (int x, int y)：`bis (x, y)`
			2. Xor (int x, int y)：`bis ( bic(x, y), bic(y, x) )`

- C 语言中的逻辑运算：
	· 视 0 为假
	· 任何非零视为真（0 的取反默认为 1）
	· 总是返回 0 或 1
	· 提前终止：
~~~
!0x41 -> 0x00
!0x00 -> 0x01
!!0x41 -> 0x01

0x69 && 0x55 -> 0x01
0x69 || 0x55 -> 0x01
p && *p 可用于避免访问空指针的判定，若有空则可以实现提前终止
~~~

- 逻辑运算的快捷方式：
	· a && 5/a，如果 a 为 0，不会计算 5/a，避免了被 0 除
	· p && * p 不会导致间接引用空指针
	· 仅使用位级和逻辑操作：
		1. 实现 x == y 的判断（相等返回 1，否则返回 0）：`!(x^y)`

- 移位运算：
	· 左移：`x<<y`，位向量 x 左移 y 位，丢弃左边多余比特，右边填 0
	· 右移：`x>>y`，位向量 x 右移 y 位，丢弃右边多余比特，左边分两种情况：
		1. 如果是逻辑移位，则左边补 0
		2. 如果是算术移位，则左边复制最高有效位
	· 未定义行为：位移量小于 0 或大于等于字长
![|182](CSAPP%20图/CSAPP%20图1-25.png)
                            （图二十五：算术移位和逻辑移位）
	· C 语言中的移位操作：
		· 会发生什么情况？
			1. `int lval = 0xFEDCBA98 << 32`
			2. `int aval = 0xFEDCBA98 >> 36`
			3. `unsigned uval = 0xFEDCBA98 >> 40`
		· 可能的情况：
			1. `lval = 0xFECDBA98`（移动位数是 y 取余字长 w，得 0）
			2. `aval = 0xFFEDCBA9`（移动位数是 y 取余字长 w，得 4）
			3. `uval = 0x00FEDCBA`（移动位数是 y 取余字长 w，得 8）
		· 要小心 `1<<2 + 3<<4` 的情况：
			· 实际上是 `1<<(2+3)<<4`，得到的是 512，而不是 52
		· <font color="#ffc000">C 语言中 int 的右移默认算术右移（前补高位），unsigned 默认逻辑右移（前补零）</font>

- 位计数 bitCount：
	· 返回字中 1 的个数
	· 例如：`bitCount(5) = 2`，`bitCount(7) = 3`
	· 只允许使用位运算实现
	· 限制：最多可以使用 40 个运算符
```C++
int bitCount(int x)
{
	int m1 = 0x11|(0x11<<8);    // 0001 0001 0001 0001
	int mask = m1|(m1<<16);    // 0001 0001 0001 0001 0001 0001 0001 0001
	int s = x & mask;    //取每一个“小段”的最右一位：000x
	s += x>>1 & mask;    //再取每一个“小段”的第二位：00x0
	s += x>>2 & mask;    //再取每一个“小段”的第三位：0x00
	s += x>>3 & mask;    //再取每一个“小段”的第四位：x000
	//此时得到的 s 分成 8 个小段，每一个小段的值是 x 的这一小段中 1 的个数，如：0x32341002
	//之后的操作是进行加和：3+2+3+4+1+0+0+2

	s = s + (s>>16);    // 0x32341002 + 0x00003234 = 0x[][][][]4236
	mask = 0xF|(0xF<<8);    // 0000 1111 0000 1111
	s = (s&mask) + ((s>>4)&mask);
	// s & mask = 0x4236 & 0x0F0F = 0x0206
	// (s>>4) & mask = 0x[]423 & 0x0F0F = 0x0403
	// s = 0x0206 + 0x0403 = 0x0609
	return (s+(s>>8))&0x3F;
	// s + (s>>8) = 0x0609 + 0x[][]06 = 0x[][]0F
	// 0x[][]0F & 0x003F = 0x[][]00001111 & 0x{00000000}00111111 = 0x0F
	// 故数出的个数是 15（3+2+3+4+1+0+0+2=15）
}
```

3. ***整数（Integers）***：

- 编码整数（Encoding Integers）：
	· 无符号数 Unsigned：$B2U(X)=\Sigma_{i=0}^{w-1}\ x_i\cdot 2^i$
	· 无符号数补码：$2^w-\Sigma_{x=0}^{w-1}x_i\cdot2^i$
	· 有符号数补码 Two's Complement：$B2T(X)=-x_{w-1}\cdot 2^{w-1}+\Sigma_{i=0}^{w-2}\ x_i\cdot 2^i$
	· <font color="#ff337d">口诀</font>：<font color="#00ffb0">高负低正按权展</font>
	· 举例：short int x = 15213，short int y = -15213
	· C 语言并不强制使用二进制补码，然而大部分机器一般会用二进制补码进行运算
	· C 语言中 short 为 2 字节长

| 进制  | 十进制 Decimal | 十六进制 Hex | 二进制 Binary         |
| :-- | :---------- | :------- | :----------------- |
| x   | 15213       | 3B  6D   | 00111011  01101101 |
| y   | -15213      | C4  93   | 11000100  10010011 |
	· 补码中的符号位：对于补码最高有效位是符号位，0 表示非负，1 表示负数

| ------ | ------ | -16 | 8   | 4   | 2   | 1   | 求和               |
| :----- | :----- | :-- | :-- | :-- | :-- | :-- | :--------------- |
| 10     | =      | 0   | 1   | 0   | 1   | 0   | 8 + 2 = 10       |
| -10    | =      | 1   | 0   | 1   | 1   | 0   | -16 + 4 + 2= -10 |
![|350](CSAPP%20图/CSAPP%20图1-26.png)
                           （图二十六：±15213 的补码编码方式）
 · 二进制到无符号数：$$B2U(X)=\Sigma_{i=0}^{w-1}\ x_i\cdot 2^i$$
 · 补码二进制到有符号数：$$B2T(X)=-x_{w-1}\cdot 2^{w-1}+\Sigma_{i=0}^{w-2}\ x_i\cdot 2^i$$
 · *对于符号数，非负数的补码即原码无变化，负数的补码为原码取反加一*：
	 · -5 的原码：0101，取反：1010，加一：1011，故 -5 的补码为 1011
	 · -12345 -> 0011 0000 0011 1001 -> 1100 1111 1100 0110 -> 1100 1111 1100 0111

· 例：求 -62 的补码：
	· 如果 6 号位是符号位，则：-64+2=-62 —— 1000010
	· 如果 7 号位是符号位，则：-128+64+2=-62 —— 11000010
	· 如果 8 号位是符号位，则：-256+128+64+2=-62 —— 111000010
	· 如果 11 号位是符号位，由此可以直接得出，在 8 号位基础上前面补三个 1 即可：111111000010

· 数值范围：
	1. 无符号数：最小为 $0$，即 000…0；最大为 $2^w-1$，即 111…1
	2. 有符号数补码值：最小为 $-2^{w-1}$，即 100…0；最大为 $2^{w-1}-1$，即 011…1
	· 注：$-1$ 在二进制补码中表示为 111…1
![|450](CSAPP%20图/CSAPP%20图1-27.png)
                      （图二十七：16 位长不同类型整数编码的数值范围）
![|450](CSAPP%20图/CSAPP%20图1-28.png)
                    （图二十八：几种整数在不同字长补码编码下的取值范围）

· 观察易发现：
1. $|T_{Min}|=T_{Max}+1$，这是一个非对称范围
2. $U_{Max}=2*T_{Max}+1$
3. abs（$T_{Min}$）的结果就是 $T_{Max}+1$

· 在 C 语言编程中，引用头文件：`#include <limits.h>` 可以声明常量：
	· `ULONG_MAX`，`LONG_MAX`，`LONG_MIN`
	· 具体取值随平台而定

![|175](CSAPP%20图/CSAPP%20图1-29.png)
                          （图二十九：无符号数和有符号数的数值）
1. 等同性：非负值同样的编码
2. 唯一性：每个比特模式表示唯一的整数值，每个可表示的整数有唯一的比特位编码
3. 能够逆映射：
	1. $U2B(X)=B2U^{-1}(X)$，无符号整数比特模式
	2. $T2B(X)=B2T^{-1}(X)$，补码整数比特模式

· 其他有符号数表示：
	· 反码：与补码相同，除了最高位权值位 $-(2^{w-1}-1)$ 而不是 $-2^{w-1}$：
$$B2O_w(X)=-x_{w-1}(2^{w-1}-1)+\Sigma_{i=0}^{w-2}\ x_i\cdot2^i$$
	+0 = 00000000，-0 = 11111111（过去有使用反码的机器，现在都用补码）
	· 原码：最高有效位是符号位，决定剩余位是负权还是正权
$$B2S_w(X)=(-1)^{x_{w-1}}\cdot(\Sigma_{i=0}^{w-2}x_i2^i)$$
	+0 = 00000000，-0 = 10000000（在浮点表述中还在使用）

- 类型转换：
	· 无符号数和补码之间进行映射，保持位表示并重新解释
![|425](CSAPP%20图/CSAPP%20图1-30.png)
                         （图三十：补码看成无符号数的变换公式）
![|350](CSAPP%20图/CSAPP%20图1-31.png)
                        （图三十一：有符号数和无符号数之间的映射）
![|450](CSAPP%20图/CSAPP%20图1-32.png)
                        （图三十二：补码转换为无符号数的可视化）

· C 语言中整数数据类型有无符号型 unsigned，有符号型 int
· Java 没有无符号数据类型（使用字节代替字符）
![|450](CSAPP%20图/CSAPP%20图1-33.png)
                    （图三十三：C 语言整数数据类型典型取值范围 - 32 位）
![|450](CSAPP%20图/CSAPP%20图1-34.png)
                    （图三十四：C 语言整数数据类型典型取值范围 - 64 位）
![|450](CSAPP%20图/CSAPP%20图1-35.png)
                      （图三十五：C 语言整数数据类型确保取值范围）

· C 语言有 / 无符号数强制类型转换：
	· C 语言允许一种类型的变量解释为另一种数据类型
		· 类型转换（隐式）
		· 强制类型转换（显示）

· C 语言中的有符号数和无符号数：
	· 常量：默认为有符号整数，有 U 做后缀表示无符号数：`0U`，`4294967259U`
	· 强制类型转换 casting：显示强制类型转换有 / 无符号数等同于 U2T/T2U
	（隐式强制类型转换通过赋值和过程调用也会发生）
~~~
测试：
short int x = 12345;
unsigned short int ux = (unsigned short) x;
short int y = -12345;
unsigned short int uy = (unsigned short) y;

· 结果值 Resulting Value
· 位表示没有变化 No change in bit representation
· 非负数值没有变化 Nonnegative values unchanged：
· ux = 12345
· 负值变成大的正值 Negative values change into (large) positivevalues：
· uy = 53191
~~~

· *强制类型转换的注意点*：
· 表达式求值：如果单一表达式中混合了无符号数和有符号数，有符号值隐含强制转换成无符号数，包括比较运算
![|450](CSAPP%20图/CSAPP%20图1-36.png)
            （图三十六：表达式中混合了有符号数和无符号数时，有符号数转成无符号数）

· 小结：有 / 无符号数强制转换的基本规则
	a. 比特位模式保持不变，但是需要重新解释
	b. 可能有不期望的效果：加或减 $2^w$
	c. *表达式包含有符号和无符号整数时，有符号数强制类型转换为无符号数*

- 整数的扩展和截断：
	· 由短到长的转换：
		· short int x = 12345;
		· int ix = (int) x;
		· short int y = -12345;
		· int iy = (int) y;
		· 有时需要到扩展数据长度
		· 无符号类型之间强制类型转换正常
		· 有符号类型之间强制类型转换需要技巧

	· 符号扩展：
		· 给定 w 位的带符号整数 x
		· 目标是转换成数值相同的 w+k 位整数
		· 规则：（MSB - 最高有效位）把符号位复制 k 位
![|425](CSAPP%20图/CSAPP%20图1-37.png)
                             （图三十七：符号扩展的规则）
![|425](CSAPP%20图/CSAPP%20图1-38.png)
                            （图三十八：符号位扩展的原理）
· 从小整数数据类型转换到大整数数据类型，C 语言自动执行扩展：
![|425](CSAPP%20图/CSAPP%20图1-39.png)
                          （图三十九：更大型符号位扩展举例）
~~~
从短到长的扩展：
short int sx = 12345;    // 0x0309
int x = (int) sx;    // 0x00000309
short int sy =-12345;    // 0xcfc7
int y = (int) sy;    // 0xffffcfc7
usigned ux = sy;    // 0xffffcfc7
~~~
~~~
int fun1(unsigned word) {return (int) ((word << 24) >> 24);}
int fun2(unsigned word) {return ((int) word << 24) >> 24;}

    w         fun1(w)    fun2(w)
0x00000076   00000076   00000076
0x87654321   00000021   00000021
0x000000C9   000000C9   FFFFFFC9
0xEDCBA987   00000087   FFFFFF87
· 描述每个函数执行时字中的有用计算
~~~

· 从长到短的转换——截断：
	· 给定 k+w 位有符号或无符号整数 X
	· 目标：转换成 w 位整数 X’，对于“足够小的” X 具有同样的值
	· 规则：丢弃头 k 位
![|425](CSAPP%20图/CSAPP%20图1-40.png)
                                （图四十：截断的规则）
![|450](CSAPP%20图/CSAPP%20图1-41.png)
                             （图四十一：截断的简单示例）
![|425](CSAPP%20图/CSAPP%20图1-42.png)
                        （图四十二：有符号数和无符号数的截断）

· 小结：扩展和截断的基本规则：
~~~
扩展（例如 short 扩展成 int）：
· 无符号数：添加零 Unsigned: zeros added
· 有符号数：符号位扩展 Signed: sign extension
· 都还会产生期望的结果 Both yield expected result

截断（例如无符号int截断成无符号short）：
· 无 / 有符号数：比特位截断 Unsigned / signed: bits are truncated
· 结果重新解释 Result reinterpreted
· 无符号数：模取余运算 Unsigned: mod operation
· 有符号数：类似模取余 Signed: similar to mod
· 对于小的数值还会产生期望的行为 For small numbers yieldsexpectedbehavior
~~~

- 加、补码非、乘和移位：
	· 无符号数加法：
![|450](CSAPP%20图/CSAPP%20图1-43.png)
                           （图四十三：无符号数加法的规则）
![|425](CSAPP%20图/CSAPP%20图1-44.png)
            （图四十四：数学上的整数加法（上）和无符号数的加法（下）的可视化表示）

· 对于无符号数而言，其在数学上性质体现为：数模加法形成阿贝尔群：
1. 封闭的加法 Closed：$0\leq UAdd_w(u,v)\leq2^w-1$
2. 交换性 Commutative：$UAdd_w(u,v)=UAdd_w(v,u)$
3. 结合性 Associative：$UAdd_w(t,UAdd_w(u,v))=UAdd_w(UAdd_w(t,u),v)$
4. 0 是加性恒等（单位元）：$UAdd_w(u,0)=u$
5. 每个元素都有加法逆元（inverse）：$UAdd_w(u,2^w-u)=0$

	· 补码加法：
![|450](CSAPP%20图/CSAPP%20图1-45.png)
                            （图四十五：补码加法的规则）
![|450](CSAPP%20图/CSAPP%20图1-46.png)
                            （图四十六：有符号数加法的溢出）
![|450](CSAPP%20图/CSAPP%20图1-47.png)
                             （图四十七：可视化补码加法）
![|450](CSAPP%20图/CSAPP%20图1-48.png)
                            （图四十八：有符号数加法特征）
 · TAdd 数学上的性质：
	 1. 与无符号数的 UAdd 是同构群：
$$TAdd_w(u,v)=U2T\ (\ UAdd_w\ (\ T2U(\ u,\ T2U(v)\ )))$$
因为都有同样的比特位模式
	2. TAdd 下补码形成一个群：封闭性、交换性、结合性、$0$ 具有加性恒等性（单位元）
每个元素都有加法逆元：
$$TComp_w(u)=\begin{cases}-u,\ \ \ \ \ \ \ \ \ \ u\neq TMin_w\\ TMin_w,\ \ \ u=TMin_w\end{cases}$$

· <font color="#00ffb0">乘法</font>：
· 目标：计算 w 位的数 x 和 y 的乘积
· 精确的结果比 w 位大得多：
	· 无符号数：到 $2w$ 位，$0\leq x*y\leq(2^w-1)^2=2^{2w}-2^{w+1}+1$
	· 补码最小（负数）：到 $2w-1$ 位，$x*y\geq(-2^{w-1})*(2^{w-1}-1)=-2^{2w-2}+2^{w-1}$
	· 补码最大（正数）：到 $2w$ 位，但仅限于 $(TMin_w)^2$，$x*y\leq(-2^{w-1})^2\leq2^{2w-2}$
· 所有，为了保证精确的结果，<font color="#ffc000">需要在计算每个乘积时不断扩大乘积结果表示的字长</font>，也可以借助任意精度算术软件包完成
![|450](CSAPP%20图/CSAPP%20图1-49.png)
                        （图四十九：C 语言中的无符号数乘法规则）
![|450](CSAPP%20图/CSAPP%20图1-50.png)
                        （图五十：C 语言中的有符号数乘法规则）

· <font color="#ffc000">二进制补码乘法的运算步骤</font>：
· 两个补码相乘，单独考虑符号位（负负得正），只用绝对值运算
· 例如 -5×4，只用 5 和 4 的无符号数进行运算（四比特位约束），列竖式做乘法
· 得到的结果**先截断**，比如 5×4=20，截断后的四位是 0100，即 4
· 对于截断后的结果进行处理，如果应该有负号，则**再转负数**：1100，即 -4
· 核心：<font color="#00b0f0">先截断，有负号再转负数</font>

· <font color="#00ffb0">用移位实现 2 的整数次幂乘法</font>：
![|450](CSAPP%20图/CSAPP%20图1-51.png)
                      （图五十一：用移位实现 2 的整数次幂乘法规则）
· 大多数机器移位和加法比乘法更快，编译器自动生成这种代码（一定要信任编译器！）
· 示例：
$$u<<3==u*8$$$$(u<<5)-(u<<3)==u*24$$

· <font color="#00ffb0">用移位实现 2 的整数次幂除法</font>：
![|450](CSAPP%20图/CSAPP%20图1-52.png)
                    （图五十二：用移位实现无符号数 2 的整数次幂除法）
![|450](CSAPP%20图/CSAPP%20图1-53.png)
                    （图五十三：用移位实现有符号数 2 的整数次幂除法）
![|400](CSAPP%20图/CSAPP%20图1-54.png)
                           （图五十四：修正 2 的整数次幂除法）

· 编译生成的乘法代码：
![|450](CSAPP%20图/CSAPP%20图1-55.png)
                           （图五十五：编译生成的乘法代码）
· 当乘以常量时，C 语言编译器自动生成移位 / 加法代码

· 编译生成的除法代码：
![|450](CSAPP%20图/CSAPP%20图1-56.png)
                        （图五十六：编译生成的无符号数除法代码）
	· 对于无符号数使用逻辑移位
	· 对于 Java 用户，逻辑移位记为 `>>>`
![|450](CSAPP%20图/CSAPP%20图1-57.png)
                        （图五十七：编译生成的有符号数除法代码）
	· 对于 int 使用算术移位
	· 对于 Java 用户，算术移位记为 `>>`

· <font color="#00ffb0">补码非：求补和递增</font>
![|450](CSAPP%20图/CSAPP%20图1-58.png)
                            （图五十八：补码非运算规则）
![|450](CSAPP%20图/CSAPP%20图1-59.png)
                           （图五十九：补码非求相反数示例）

- 小结：
	- 算术运算：基本规则：
		- 加法：
			- 无 / 有符号数：正常加法然后截断，比特位级运算是相同的
			- 无符号数：加法再取模数运算，数学上加法+可能减去模
			- 有符号数：修正的模加法（结果在正确的范围），数学上加法+可能加或减模
		- 乘法：
			- 无 / 有符号数：正常的乘法然后截断，比特位级运算是相同的
			- 无符号数：乘法取模
			- 有符号数：修正的乘法取模（结果在正确范围）
		- 无符号数、补码都是同构环：同构 = 强制类型转换
		- 左移：
			- 无 / 有符号数：乘以 2 的整数次幂
			- 总是逻辑移位
		- 右移：
			- 无符号数：逻辑移位，除以 2 的整数次幂（除法+向 0 舍入）
			- 有符号数：算术移位：
				- 正数：除以 $2^k$（除法+向 0 舍入）
				- 负数：除以 $2^k$（除法+远离 0 舍入），使用偏置修正
	- 无符号数运算的性质：
		- 用加法的无符号数乘法形成交换环：
			- 加法是具有交换性的群组
			- 封闭的乘法 $0\leq UMult_w(u,v)\leq2^w-1$
			- 乘法具有交换性 $UMult_w(u,v)=UMult_w(v,u)$
			- 乘法具有结合性 $UMult_w(t,UMult_w(u,v))=UMult_w(UMult_w(t,u),v)$
			- 1 是乘性恒等的（单位元）$UMult_w(u,1)=u$
			- 乘法对加法具有分配性 $UMult_w(t, UAdd_w(u , v)) = UAdd_w(UMult_w(t, u ), UMult_w(t, v))$
	- 补码运算的属性：
		- 同构的代数：
			- 无符号数乘法和加法，截断到 $w$ 位
			- 补码乘法和加法，截断到 $w$ 位
		- 都形成闭环
			- 同构于整数模 $2^w$ 的闭环
		- 数学整数运算比较：
			- 都是闭环
			- 整数遵循按序属性：$u\textgreater0=>u+v\textgreater v,\ \ \ u\textgreater0,v\textgreater0=>u\cdot v\textgreater0$
			- 补码运算不遵循的属性：$TMax+1==TMin,\ \ \ 15213*30426=-10030$
	- 为什么使用无符号数？
		- 在没有理解含义的情况下*不要使用*
			- 容易犯错误，可能非常微妙
		- 当执行模运算时*使用无符号数*
			- 多精度运算
		- 当使用比特位表示集合时*使用无符号数*
			- 逻辑右移，无需符号扩展
		- 在系统编程时*使用无符号数*
			- 位掩码、设备命令……
	- 用无符号数倒计时：
![|450](CSAPP%20图/CSAPP%20图1-60.png)
                             （图六十：用无符号数倒计时）
· **口诀**：
<font color="#00ffb0">加法补码直累计，乘二除二左右移</font>
<font color="#00ffb0">负数除法进上位，取反补非再加一</font>

4. ***内存中的表示、指针和字符串***：
- 面向字节的内存组织：
	· 程序按照地址引用数据，概念上，将其想象成一个非常大的字节数组
		· 事实上，并非如此，但是可以这样看待
	· 地址就像是数组的索引 ，而且指针变量存储地址
	· 注意：系统给每个进程提供私有地址空间：
		· 进程看成执行中的程序
		· 因此，程序可以任意处理自己的数据，但是不能处理其他程序数据

- 机器字：
	· 任何特定的计算机都有“字长”：
		· 整数值数据的标称大小，以及地址
		· 直到最近，大多数机器使用 32 位（4 字节）作为字长，地址局限到 4GB
		· 机器字长增长为 64 位，潜在地，可以有 18EB 地址空间，即 $18.4\times10^{18}$
		· 机器还支持多种数据格式：字长的部分或倍数（总是字节的整数倍）

- 面向“字”的内存组织：
![|450](CSAPP%20图/CSAPP%20图1-61.png)
                           （图六十一：面向“字”的内存组织）

- 数据表示的示例：

| C Data Type | Typical 32-bit | Typical 64-bit | x86-64 |
| :---------- | :------------- | :------------- | :----- |
| char        | 1              | 1              | 1      |
| short       | 2              | 2              | 2      |
| int         | 4              | 4              | 4      |
| long        | 4              | 8              | 8      |
| float       | 4              | 4              | 4      |
| double      | 8              | 8              | 8      |
| long double | ---            | ---            | 10/16  |
| pointer     | 4              | 8              | 8      |

- 字节顺序：
	· 字中的多个字节在内存里如何排序？
	· 约定：
		· 大端法：
			· 最低有效字节有最高的地址
			· Sun
			· PPC Mac
			· Internet
		· 小端法：
			· 最低有效字节有最低地址
			· x86
			· ARM processors running Android
			· iOS
![|400](CSAPP%20图/CSAPP%20图1-62.png)
                              （图六十二：字节顺序示例）

- 整数表示：
![|400](CSAPP%20图/CSAPP%20图1-63.png)
                             （图六十三：内存中整数的表示）
![|400](CSAPP%20图/CSAPP%20图1-64.png)
                             （图六十四：检查数据的表示）

· `show_bytes` 执行示例：
```C
int a = 15213;
printf("int a = 15213;\n");
show_bytes((pointer) &a, sizeof(int));
```
~~~
运行结果（Linux x86-64）：
int a = 15213;
0x7fffb7f71dbc 6d
0x7fffb7f71dbd 3b
0x7fffb7f71dbe 00
0x7fffb7f71dbf 00
~~~

- 指针表示：
![|400](CSAPP%20图/CSAPP%20图1-65.png)
                            （图六十五：内存中指针的表示）

- 字符串表示：
![|400](CSAPP%20图/CSAPP%20图1-66.png)
                            （图六十六：内存中字符串的表示）
![|400](CSAPP%20图/CSAPP%20图1-67.png)
                            （图六十七：阅读逆序字节列表）
![|400](CSAPP%20图/CSAPP%20图1-68.png)
                              （图六十八：C 语言整数难题）
~~~
图六十八详解（以四位为例：T：-8~7；U：0~15）：
1. x < 0：如果 x=-8，即 1000，则移位后得 0
2. 无符号数大于等于零永远正确
3. x & 7 == 7：说明 x 的后三位是 1，当左移 30 位后，首位（符号位）是 1，故为负数
4. ux > -1：当有无符号数一起比较时，int 要转成 unsigned，-1 要映射为 UMax
5. x > y：-7 > -8，-7 的相反数是 7，-8 补码非转相反数还是 -8
6. x * x >= 0：2×4=8，但是 8 的二进制表示是 1000，按照补码翻译要变成 -8
7. 7+7=14 -> 正溢，得 -2
8. x>=0：由于 0<=x<=7，补码非取相反数都是可以正常实现的，故 -x<=0 成立
9. x<=0：取 x=-8，则补码非取相反数还是 -8
10. (x|-x)>>31==-1：当且仅当 (x|-x) 的首位是 1，正负符号异或一定是 1，但 x 可以取 0
11. 根据除法定义，对于 unsigned 而言，ux >> 3 == ux / 8 没有问题
12. 当 x<0 时，x/8 应当表示为：((x-1)>>3)+1，向零取整
13. 6 & 5 != 0 成立，但是 2 & 1 != 0 不成立
~~~

###### · 浮点数（Floating Point）：

1. ***二进制小数（Fractional binary numbers）***：
- 二进制小数的表示方式：
	· “小数点”右边的位代表 2 的整数次幂分之一 
	· $\Sigma_{k=-j}^i\ b_k\times2^k$ 代表有理数
~~~
示例：
23/4 => 101.11(2)
23/8 => 10.111(2)
23/16 => 1.0111(2)
~~~
· 观察：
	· 通过右移来除以 2（无符号数）
	· 通过左移乘以 2
	· 数字形式 0.111111…（2）是刚好低于 1.0 的数
	· 即 $\frac{1}{2}+\frac{1}{4}+\frac{1}{8}+\cdots=1.0$
	· 使用记法为：$1.0-\epsilon$

· 二进制小数的限制：
· 限制 1：仅可以精确地表示 $x/2^k$ 形式的数，其它有理数有重复的比特位（即“循环节”）表示
~~~
示例：
1/3 => 0.0101010101[01]…(2)
1/5 => 0.001100110011[0011]…(2)
1/10 => 0.0001100110011[0011]…(2)
~~~
· 限制 2：定点数，在 w 比特位中仅有一个二进制小数点设置，有限的数值范围

2. ***IEEE 浮点数标准：定义（IEEE floating point standard: Definition）***：
· IEEE 754 标准（IEEE Standard 754）：
	· 1985 年制定作为浮点运算的统一标准（在此之前，有很多异质的格式）
	· 得到所有主流 CPU 的支持
	· 由 Kahan 为 Intel 处理器设计（获得 1989 年图灵奖）
· 由数值问题所驱动：
	· 非常好的标准用于舍入、上溢和下溢
	· 在硬件上很难快速运算：数值分析师在定义标准时比硬件设计师更占主导地位

- 浮点表示：
	· 浮点数形式（Numerical Form）：$(-1)^s\ M\ 2^E$：
		· 符号位 s 确定数值是负还是正
		· 尾数 M 是范围在 $[1.0,2.0)$ 之间的普通小数
		· 阶码 E 是给浮点数指定 2 的 E 次幂权重
	· 编码（Encoding）：
		· 最高位是符号位 s
		· exp 字段编码 E（但不等于 E）
		· frac 字段编码 M（但不等于 M）
~~~
示例：
15213_(10) = (-1)^0 × 1.1101101101101_(2) × 2^13
~~~

- 精度选项（Precision options）：
	- 单精度浮点数
	- 双精度浮点数
	- 扩展精度（仅 Intel）
![|450](CSAPP%20图/CSAPP%20图1-69.png)
                        （图六十九：单、双进度浮点数及扩展精度）

- “规格化”值（“Normalized” Values）：
· 当阶码非全零和全一时，阶码编码为一个有偏置值的有符号数：$E=Exp-Bias$
	· Exp：exp 字段的无符号值
	· 偏置 $Bias=2^{k-1}-1$，其中 $k$ 是阶码位的位数
		· 单精度：Exp：1…254，E：-126…127
		· 双精度：Exp：1…2046，E：-1022…1023
· 尾数编码为带隐含的一个前导 1：M = 1.xxxxxx（2）
	· frac 字段的比特位：
	· 当 frac 全零时值最小：frac=000…0（M=1.0）
	· 当 frac 全一时值最大：frac=111…1（M=2.0-$\epsilon$）
· <font color="#ff337d">口诀</font>：<font color="#00ffb0">指数加补码最大值得阶数</font>
![|450](CSAPP%20图/CSAPP%20图1-70.png)
                            （图七十：“规格化”编码示例）

- 非规格化值（Denormalized Values）：
· 条件：exp 全为 0：exp = 000…0
· 阶码值：$E=1-Bias$（除非 $E=0-Bias$）
· 尾数编码为隐含的一个前导零：M = 0.xxxxxx（2）
	· 情况 cases：
	· exp = 000…0，frac = 000…0，代表 0 值，注意区别值：+0 和 -0
	· exp = 000…0，frac ≠ 000…0，最接近 0.0 的数值，平均分布的 Equispaced
· <font color="#ff337d">口诀</font>：<font color="#00ffb0">指数加补码最大值得 1</font>

- 特殊值（Special Values）：
· 条件 exp 为全一：exp = 111…1
· 情况：
	· exp = 111…1，frac = 000…0
	· 代表值无穷大
	· 溢出运算
	· 正负均如此
	· 例：1.0/0.0 = -1.0/-0.0 = +∞，1.0/-0.0 = -∞
· 情况：
	· exp = 111…1，frac ≠ 000…0
	· 不是一个数（Not-a-Number：NaN）
	· 代表无法确定数值的情况
	· 例：sqrt ( -1 )，∞ - ∞，∞ × 0
![|450](CSAPP%20图/CSAPP%20图1-71.png)
                           （图七十一：浮点编码的可视化）
![|500](CSAPP%20图/CSAPP%20图1-72.png)
                        （图七十二：C 语言中的浮点数示例一）
![|500](CSAPP%20图/CSAPP%20图1-73.png)
                        （图七十三：C 语言中的浮点数示例二）

· “看阶码”总结：
	· 阶码看作无符号数，按权展开如果是在 1 到 254 间，那么这是一个规格化值，此时阶码减去 127 为实际指数，尾数部分默认有一个前导 1
	· 如果阶码是 0（全零），那么这是一个非规格化值，尾数部分默认有一个前导 0，实际指数默认为 -126，如果尾数部分是 0（全零），那么这就是 0；如果尾数部分不是 0（全零），那么这是一个接近 0 的数
	· 如果阶码是 255（全一），那么这是一个特殊值，如果此时尾数部分是 0（全零），那么这就是无穷；如果尾数不是 0（全零），那么这就是 NaN

· **口诀**：
· <font color="#00ffb0">你真爱误事</font>（1 至 254 ），<font color="#00ffb0">别忘签到噫</font>（别忘前导 1 ）
· <font color="#00ffb0">您莫再呜呜</font>（0 和 255 ），<font color="#00ffb0">设个签到铃</font>（设个前导 0）
· <font color="#00ffb0">街上全是人</font>（阶上全是 1 ），<font color="#00ffb0">无穷数不来</font>（∞ 和 NaN ）
· <font color="#00ffb0">街上没有人</font>（阶上没有 1 ），<font color="#00ffb0">几乎等于零</font>（近 0 与 0 ）

3. ***浮点数示例和属性（Example and properties）***：
- 微小的浮点数示例：
![|300](CSAPP%20图/CSAPP%20图1-74.png)
                            （图七十四：微小的浮点数示例）
· 8 位浮点表示：
	· 符号位是在最高有效位
	· 随后四位是阶码，偏置为 7
	· 最后的三位是尾数
· 与 IEEE 格式同样的通用格式：
	· 规格化、非规格化
	· 0、NaN 和无穷大的表示
![|450](CSAPP%20图/CSAPP%20图1-75.png)
                            （图七十五：正数的动态范围）
· 值的分布：
	· 6 位类 IEEE 格式
	· 3 位阶码：e = 3
	· 2 位尾数：f = 2
	· 偏置量为 3
![](CSAPP%20图/CSAPP%20图1-76.png)
（图七十六：非规格化、规格化数的分布）
![|450](CSAPP%20图/CSAPP%20图1-77.png)
                           （图七十七：一些“有趣”的数值性质）

- IEEE 编码的特殊属性：
	- 浮点数的零和整数的零相同：所有比特位为 0
- 几乎可以使用无符号整数比较：
	- 必须首先比较符号位
	- 必须考虑 -0 = 0
	- “不是一个数” NaN 的问题
		- 比其他任何值都大
	- 否则都没有问题
		- 非规格化和规格化
		- 规格化和无穷大

4. ***舍入、加法和乘法***：
- 舍入（Rounding）：
	· 舍入模式：
![|450](CSAPP%20图/CSAPP%20图1-78.png)
                        （图七十八：用美元来举例说明舍入模式）
· 近处观察向偶数舍入：
	· 默认的舍入模式：
		· 没有深入汇编级很难理解任何其它类型的舍入
		· 所有其它的舍入都有统计偏差：一组正数的和将始终高估或低估
	· 适用于其它小数位/比特位位置：
		· 当正好位于两个可能值中间时，舍入以便最低位是偶数
		· 例如舍入到最近的百分位：
~~~
舍入到最近的百分位示例：
7.8949999   7.89  (低于中间值 Less than half way)
7.8950001   7.90  (高于中间值 Greater than half way)
7.8950000   7.90  (中间值-向上舍入 Half way—round up)
7.8850000   7.88  (中间值-向下舍入 Half way—round down)
~~~
· <font color="#ff337d">口诀</font>：<font color="#00ffb0">奇进偶不进</font>

· 舍入二进制数：
	· 二进制小数当最低位是 0 时为偶数，当舍入位置右边 = 100…（2）时为“中间值”
	· 例如舍入到最接近 1/4（小数点右边 2 位）：
~~~
舍入到最近 1/4 示例：
Value        Binary       Rounded      Action      Rounded Value
2+3/32    10.00011_(2)     10.002   (<1/2—down向下)       2
2+3/16    10.00110_(2)     10.012   (>1/2—up向上)        2+1/4
2+7/8     10.11100_(2)     11.002   ( 1/2—up向上)         3
2+5/8     10.10100_(2)     10.102   ( 1/2—down向下)      2+1/2
~~~
![|450](CSAPP%20图/CSAPP%20图1-79.png)
                 （图七十九：浮点数的监督位、舍入位和固着位及向上舍入条件）
· 正浮点数舍入规则总结：
	1. 舍入位是 0，则一律舍去
	2. 舍入位是 1：
		1. 如果固着位存在 1，则直接进位
		2. 如果固着位没有 1：
			1. 如果监督位是 0，则舍去
			2. 如果监督位是 1，则进位
· **口诀**：<font color="#00ffb0">四舍五入，过五进位，整五奇进偶不进</font>

· 浮点运算的基本思想：
$$x+_fy=Round(x+y)$$$$x\times_fy=Round(x\times y)$$
基本思想：首先计算精确的结果，使它适合需要的精度（如果阶码太大可能会溢出，可能需要舍入才能适合尾数位数）

- 浮点加法：
$$(-1)^{s_1}\ M_1\ 2^{E_1}\ +\ (-1)^{s_2}\ M_2\ 2^{E_2}$$
假设 $E_1\textgreater E_2$
小数点对齐
· 精确的结果（Exact Result）：$(-1)^s\ M\ 2^E$：
	· 符号位 $s$，尾数 $M$：有符号数对齐并相加的结果
	· 阶码 $E$ 是 $E_1$
![|500](CSAPP%20图/CSAPP%20图1-80.png)
                            （图八十：浮点加法的精确结果）
· 修正 Fixing：
	· 如果 M 大于等于 2，M 右移，E 加一
	· 如果 M 小于 1，M 左移 k 位，E 减 k 
	· 如果 E 超过范围则溢出
	· 舍入 M 到适合 frac 的精度

· 浮点加法 Floating Point Addition：
$$1.010*2^2+1.110*2^3=(0.1010+1.1100)*2^3$$$$=10.0110*2^3=1.00110*2^4=1.010*2^4$$

-  浮点加法的数学性质：
	- 相比于其它阿贝尔群：
		- 加法封闭
		- 可交换
		- 不可结合（溢出和舍入不精确）
		- $0$ 是加性恒等元（单位元）
		- 几乎对每个元素都有加法逆元（除了无穷大和 NaNs）
	- 单调性 $a\geq b=>a+c\geq b+c$：
		- 几乎满足（除了无穷大和 NaNs）

- 浮点乘法：
$$(-1)^{s_1}\ M_1\ 2^{E_1}\ \times\ (-1)^{s_2}\ M_2\ 2^{E_2}$$
· 精确的结果：$(-1)^s\ M\ 2^E$
	· 符号位 $s$：异或：$s_1$^$s_2$
	· 尾数 $M$：相乘：$M_1\times M_2$
	· 阶码 $E$：相加：$E_1+E_2$
· 修正：
	· 如果 M 大于等于 2，M 右移，阶码 E 加一
	· 如果 E 超过范围，溢出
	· 舍入 M 到适合 frac 的精度
· 实现：
	· 最繁琐的工作是尾数相乘
	· 四位尾数：
$$1.010*2^2\times1.110*2^3=10.0011*2^5=1.00011*2^6=1.001*2^6$$


- 浮点乘法的数学性质：
	- 相比于交换环：
		- 乘法封闭
		- 乘法可交换
		- 乘法不具有结合性（可能溢出，舍入不精确）
		- $1$ 是乘法恒等元（单位元）
		- 乘法对加法不可分配（可能溢出，舍入不精确）
	- 单调性 $a\geq b\ and\ c\geq0=>a*c\geq b*c$：
		- 几乎满足单调性（除了无穷大和 NaNs）

5. ***C 语言中的浮点数（Floating point in C）***：
- C 语言中的浮点数：
	· C 语言确保两个级别的浮点数：
		· float，single precision，单精度
		· double，double precision，双精度
	· 转换/强制转换：
		· double / float —> int：
			· 截断尾数部分
			· 就像向零舍入
			· 当超过范围或 NaN 时没有定义：一般设置为 $T_{Min}$
		· int —> double：
			· 精确转换，只要 int 字长小于等于 53 位
		· int —> float：
			· 将按照舍入模式进行舍入

- 创建浮点数：
	· 步骤 Steps：
		· 用前导 1 规格化尾数
		· 舍入以适合尾数位
		· 后规格化以处理舍入的影响
	· 案例研究 Case Stydy：
		· 转换 8 位无符号数成微小浮点数格式
~~~
转换 8 位无符号数成微小浮点数格式示例数值：
128   10000000
13    00001101
17    00010001
19    00010011
138   10001010
63    00111111
~~~

· 规格化 Normalize：
	· 设置小数点以便数值格式为 1
	· 调整所有位得到前导 1：随着尾数左移，阶码 -1；尾数右移，阶码 +1
~~~
示例：
Value     Binary     Fraction     Exponent
128      10000000    1.0000000       7
13       00001101    1.1010000       3
17       00010001    1.0001000       4
19       00010011    1.0011000       4
138      10001010    1.0001010       7
63       00111111    1.1111100       5
~~~

· 后规格化 Postnormalize：
	· 问题：舍入可能导致溢出，通过右移一次进行处理同时阶码加一
~~~
Value      Rounded      Exp      Adjusted      Result
128        1.000         7                      128
13         1.101         3                       13
17         1.000         4                       16
19         1.010         4                       20
138        1.001         7                      134
63        10.000         5        1.000/6        64
~~~

· C 语言的浮点数难题：
![|450](CSAPP%20图/CSAPP%20图1-81.png)
                          （图八十一：C 语言的浮点数难题）
~~~
图八十一详解：
1. x 最大可以是 32 位 int，但是 float 的尾数最多能盛放 23 位
2. double 的尾数可以盛放 52 位
3. float 转 double 无损，double 再正常转回
4. double 转 float 有损，无法正常转回
5. s 从 0 变 1（或从 1 变 0），再变回
6. int 和 float 同时运算，统一扩展成浮点数，则 2/3=0，2/3.0=0.6666……
7. 乘二只移动阶码，符号位 s 不变
8. 正常数学性质（本质原因：符号位与数值位分开，无交互和溢出）
9. 正常数学性质（同上理由）
10. 不可认为是 d-d+f，浮点数加法没有结合律，常见异常：“大数吃小数”
~~~

5. ***小结与延申***：
- IEEE 浮点数有明确的数学性质
- 表示浮点数的形式为 $M\times 2^E$
- 运算和实现是相互独立的
- 与实数运算并不相同：
	- 违背结合律与分配律
	- 对编译器和严谨数值应用程序员是一个挑战

- 关于浮点数的灾难性影响
	- 浮点运算的不精确性
	- 1991 年 2 月 25 日，在第一次海湾战争期间，位于沙特阿拉伯 Dharan 的美国爱国者导弹连未能拦截来袭的伊拉克飞毛腿导弹，飞毛腿袭击了美国陆军营房并杀死了 28 名士兵
	- 爱国者系统包含一个内部时钟，以计数器的形式实现，每 0.1 秒递增一次；为了确定以秒为单位的时间，程序会将此计数器的值乘以 24 比特位的小数，该小数是 1/10 的二进制近似值
	- 程序采用 0.1 的近似值，其值为 x=0.00011001100110011001100
	- 0.1 - x = 0.00000000000000000000*000【1100】【1100】*…（2）
	- 0.1 - x = $2^{-20}\times 0.1$ = $9.54\times10^{-8}$
	- 开始 100 小时后，有 0.343 秒的差异
	- 飞毛腿以 2000 米/秒左右的速度行驶，686 米差距
	- 软件升级未完成，有时使用准确的定时，有时读取不准确的定时
	- 1996 年 6 月 4 日，阿丽亚娜 Ariane 5 号火箭的处女航行
	- 发射后仅 37 秒，火箭就偏离了飞行路径，解体并爆炸
	- 在将 64 位浮点数转换为 16 位有符号整数的过程中发生了溢出
	- 溢出的值测量了火箭的水平速度
	- 在 Ariane 4 中，水平速度永远不会溢出 16 位数字
	- Ariane 5 只是以 5 倍的速度重用相同的软件

