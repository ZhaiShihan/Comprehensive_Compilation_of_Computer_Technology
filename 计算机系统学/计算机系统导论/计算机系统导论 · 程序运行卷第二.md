### 壹  程序的机器级表示 · 基础控制合纪一

#### 述：
#####
#####

###### · 程序的机器级表示 Ⅰ：基础：

1. ***Intel 处理器和体系结构历史***：
	· Intel x86 处理器：
		· 主导了笔记本、台式机、服务器的市场
		· 不断进化的设计：
			· 从 1978 年引入的 8086 开始，实现了后向兼容
			· 随着时间的推移增加更多的功能
		· 复杂指令集计算机 CISC
			· 很多不同指令有不同的格式，但 Linux 程序仅使用其中小的子集
			· 很难匹敌精简指令集计算机 RISC 的性能
			· 但是，Intel 已经这么做了：速度方面提升很快，但是很少用于低功耗环境
	· Intel x86 的演进——里程碑：
![|450](CSAPP%20图/CSAPP%20图2-1.png)
                               （图一：Intel x86 的发展概述）
· 2015 年最先进的处理器：
![|450](CSAPP%20图/CSAPP%20图2-2.png)
                  （图二：2015 年 Core i7 Broadwell 2015 第五代处理器架构）
· 2018 年最先进的处理器：
![|450](CSAPP%20图/CSAPP%20图2-3.png)
                        （图三：2018 年 Coffee Lake 处理器架构）

· x86 克隆：AMD（Advanced Micro Devices）
	· 历史：紧跟 Intel，稍微慢一点，便宜很多
	· 后来：
		· 从 DEC 公司和其它走下坡路公司招募了顶级电路设计师
		· 构建了皓龙：奔腾 4 的强力竞争者
		· 开发了 x86-64，扩展为 64 位体系结构
	· 最近几年：
		· Intel 齐心协力
			· 1995-2011：全球领先的半导体“晶圆厂”
			· 2018：第二大厂（第一是三星 Samsung） 
			· 2019：重新夺回第一
		· AMD 落后：从 GlobalFoundaries 分拆出来
		· 2019-2020：领先，将台积电作为部分晶圆厂
		· 2022：英特尔重新领先

· Intel 的 64 位处理器历史：
	· 2001 年 Intel 尝试从 IA32 向 IA64 的激进迁移
		· 完全不同的体系结构（安腾）
		· 仅仅作为遗留执行 IA32 代码
		· 性能令人失望
	· 2003 年 AMD 采用革命性解决方案步伐
		· x86-64（现在称为 AMD64）
	· Intel 感到必须要聚焦到 IA64
		· 很难承认犯错或 AMD 更佳
	· 2004 年 Intel 宣布 EM64T 扩展到 IA32
		· 扩展 64 位内存技术
		· 几乎和 x86-64 相同
	· 除了低端都支持 x86-64
		· 但很多代码仍然运行在 32 位模式

2. ***汇编语言基础：寄存器、操作数和传送类指令***：
![|400](CSAPP%20图/CSAPP%20图2-4.png)
                            （图四：对于一个程序的抽象级别）
· 定义：
	· 体系结构（又称 ISA：指令集体系结构）：要进行处理器设计，需要理解或者写汇编 / 机器代码
	· 微体系结构：体系结构的实现
	· 代码形式：
		· 机器代码：处理器执行的字节级程序
		· 汇编代码：机器代码的文本表示
	· 示例 ISA：
		· ARM：用于几乎所有移动电话
		· RISC V：新的开源 ISA

· 汇编 / 机器代码视图：
![|425](CSAPP%20图/CSAPP%20图2-5.png)
                            （图五：汇编 / 机器代码视图）
	· 程序员可见的状态：
		· PC 程序计数器：
			· 下条指令地址
			· 称为 RIP（x86-64）
		· 寄存器堆：程序频繁使用的数据
		· 条件码：存储有关最近的算术和逻辑运算的状态信息，用于条件分支
		· 内存：
			· 字节可寻址的数组
			· 代码和用户数据
			· 支持过程的栈

· 汇编语言的数据类型：
	· 1，2，4 或 8 字节“整数”数据：数据值；地址（无类型指针）
	· 4，8 或 10 字节的浮点数据
	· （SIMD 向量数据类型 8、16、32 或 64 字节）
	· 代码：字节序列编码一序列指令
	· 没有聚合类型例如数组或结构：仅在内存中分配连续的字节
![|350](CSAPP%20图/CSAPP%20图2-6.png)
                           （图六：64 位寄存器实现 64 位加法）
· x86-64 整数寄存器：
![|350](CSAPP%20图/CSAPP%20图2-7.png)
                             （图七：x86-64 整数寄存器）
	 · 可以引用低 4 字节（也可以引用低 1 或 2 字节） 
	 · 不是内存（或 cache）的一部分

· “历史”上的 IA32 寄存器：
![|450](CSAPP%20图/CSAPP%20图2-8.png)
                           （图八：“历史”上的 IA32 寄存器）

· 汇编语言：操作
	· 在内存和寄存器之间传送数据
		· 从内存装载数据到寄存器
		· 存储寄存器数据到内存
	· 对寄存器或内存数据执行算术运算
	· 传递控制
		· 无条件跳转到 / 从过程
		· 条件分支
		· 间接分支
![|450](CSAPP%20图/CSAPP%20图2-9.png)
                               （图九：传输数据的原理）
![|400](CSAPP%20图/CSAPP%20图2-10.png)
                            （图十：movq 指令操作数组合）

· 简单内存寻址方式：
	· 正常：Normal，（R），$Mem[Reg[R]]$
		· 寄存器 $R$ 指定内存地址
		· C 语言中的指针间接引用
		· `movq (%rcx),%rax`
	· 变址：Displacement，D（R），$Mem[Reg[R]+D]$
		· 寄存器 $R$ 指定内存区域的起始地址
		· 常量变址值 $D$ 指定偏移
		· `movq 8(%rbp),%rdx`
![|450](CSAPP%20图/CSAPP%20图2-11.png)
                            （图十一：简单寻址方式示例）
![](CSAPP%20图/CSAPP%20图2-12.png)
（图十二：swap() 函数的工作原理）

· 复杂内存寻址方式：
	· 最通用形式：$D(Rb,Ri,S)$，$Mem[Reg[Rb]+S*Reg[Ri]+ D]$
		· $D$: 常量“变址” 1，2 或 4 字节
		· $Rb$：基指针：16 个整数寄存器中任意一个
		· $Ri$：索引寄存器：任意，除了 `%rsp`
		· $S$：比例因子：1，2，4 或 8（为何这几个数）
	· 特殊情况：
		· $(Rb,Ri)$，$Mem[Reg[Rb]+Reg[Ri]]$
		· $D(Rb,Ri)$，$Mem[Reg[Rb]+Reg[Ri]+D]$
		· $(Rb,Ri,S)$，$Mem[Reg[Rb]+S*Reg[Ri]$
![|450](CSAPP%20图/CSAPP%20图2-13.png)
                               （图十三：地址计算示例）
![|450](CSAPP%20图/CSAPP%20图2-14.png)
                            （图十四：简单的数据传送指令）
· 仅更新指定寄存器字节：除了 `movl` 指令，它将寄存器的高四个字节更新为 0

· 数据传输示例：
~~~
· 数据传输示例：
· movl $0x4050, %eax immediate register, 4 bytes
· movw %bp, %sp register register, 2 bytes
· movb (%rdi, %rcx), %al memory register, 1 byte
· movb $-17, (%rsp) immediate memory, 1 byte
· movq %rax, -12(%rbp) register memory, 8 byte
~~~

· 零扩展—数据传输指令：
![|450](CSAPP%20图/CSAPP%20图2-15.png)
                           （图十五：零扩展—数据传输指令）
![|450](CSAPP%20图/CSAPP%20图2-16.png)
                         （图十六：符号扩展—数据传输指令）
~~~
示例：
long exchange(long *xp, long y)
{
	long x = *xp ;
	*xp = y ;
	return x ;
}
xp in %rdi, y in %rsi
1. exchange:
2. movq (%rdi), %rax   Get x at xp. Set as return value
3. movq %rsi, (%rdi)   Store y at xp
4. ret return
~~~

· 汇编语言的数组：
```Assembly
long a[16];
void f(void){
	long i ;
	for(i=0; i<16; i++) a[i]=i;}
movq %rdx, a(,%rdx,8)

i: %rdx
```

· 数据传送示例：
~~~
初始值 Initial value %dl=8d     %rax=0000000098765432
1 movb %dl, %al     %rax=000000009876548d
2 movsbl %dl, %eax     %rax=00000000ffffff8d
3 movzbq %dl, %rax     %rax=0000000000008d
~~~

3. ***算术和逻辑运算***：
![|425](CSAPP%20图/CSAPP%20图2-17.png)
                                （图十七：地址计算指令）
![|450](CSAPP%20图/CSAPP%20图2-18.png)
                            （图十八：双操作数指令示例）
· 注：有/无符号整数之间没有区别
![|400](CSAPP%20图/CSAPP%20图2-19.png)
                            （图十九：单操作数指令示例）
![|650](CSAPP%20图/CSAPP%20图2-20.png)
                          （图二十：理解算术表达式示例）

· *算术和逻辑运算*：
![|500](CSAPP%20图/CSAPP%20图2-21.png)
                        （图二十一：一些算术和逻辑运算指令）
![|450](CSAPP%20图/CSAPP%20图2-22.png)
                              （图二十二：“lea” 指令示例）
![|500](CSAPP%20图/CSAPP%20图2-23.png)
                              （图二十三：特殊的算术运算）

· 示例：
~~~
Initially dest in %rdi, x in %rsi, y in %rdx (*dest= x*y)
1 movq %rsi, %rax
2 mulq %rdx
3 movq %rax, (%rdi)
4 movq %rdx, 8(%rdi)

Initially x in %rdi, y in %rsi, qp in %rdx, rp in %rcx
(*qp = x / y, *rp = x % y)
1 movq %rdx, %r8
2 movq %rdi, %rax2 cqto
3 idivq %rsi
4 movq %rax, (%r8)
5 movq %rdx, (%rcx)
~~~

4. ***C 语言、汇编和机器代码***：
![|425](CSAPP%20图/CSAPP%20图2-24.png)
                          （图二十四：转换 C 源程序为目标代码）
![|425](CSAPP%20图/CSAPP%20图2-25.png)
                             （图二十五：编译成汇编程序）
![|600](CSAPP%20图/CSAPP%20图2-26.png)
                         （图二十六：汇编程序“真正的样子”）
![|475](CSAPP%20图/CSAPP%20图2-27.png)
                        （图二十七：目标代码，汇编器与链接器）
![|450](CSAPP%20图/CSAPP%20图2-28.png)
                               （图二十八：机器指令示例）

· **反汇编（Disassembled）**：
![|450](CSAPP%20图/CSAPP%20图2-29.png)
                             （图二十九：反汇编目标代码）
![|450](CSAPP%20图/CSAPP%20图2-30.png)
                             （图三十：替代的反汇编工具）
· 反汇编能做什么？
![|500](CSAPP%20图/CSAPP%20图2-31.png)
                     （图三十一：微软最终用户许可协议禁止逆向工程）
· 任何内容都可以解释为可执行代码
· 反汇编器检查字节并重新构造汇编语言源程序

5. ***程序的机器级表示 Ⅰ：小结***：
- Intel 处理器和体系结构历史：
	- 不断进化的设计导致很多怪异的老古董
- C 语言、汇编和机器代码：
	- 可见状态的新形式：程序计数器、寄存器等
	- 编译器将状态、表达式和过程翻译成低级指令序列
- 汇编语言基础：寄存器、操作数和传送类指令：
	- x86-64 传送类指令覆盖广泛的数据传送形式
- 运算（Arithmetic）：
	- C 语言编译器找出不同指令组合来进行计算

###### · 程序的机器级表示 Ⅱ：控制：

· 回忆：内存操作数和 LEA
![|450](CSAPP%20图/CSAPP%20图2-32.png)
                            （图三十二：内存操作数和 LEA）
· 为什么使用 LEA？
	· CPU 设计师倾向使用：计算一个对象的指针
		· 数组元素（或许）
		· 例如：传递一个数组元素给另一个函数

| 汇编 Assembly               | 等价 C 语言 C equivalent |
| :------------------------ | :------------------- |
| `lea (%rbx,%rdi,8), %rax` | `rax = &rbx[rdi]`    |
· 编译器设计人员喜欢用它实现普通计算
	· 可以在一条指令中做复杂的计算
	· x86 仅有的几个三操作数指令之一
	· 并不影响条件码（后面再讨论）

| 汇编 Assembly               | 等价 C 语言 C equivalent |
| :------------------------ | :------------------- |
| `lea (%rbx,%rbx,2), %rax` | `rax = rbx * 3`      |

· 旁注：指令后缀
	· 多数 x86 指令写或不写后缀都可以，没有区别：
		· `imul %rcx, %rax`
		· `imulq %rcx, %rax`
	· 后缀指明操作的大小：
		· b=byte，w=short，l=int，q=long
		· 如果出现，必须和寄存器名字相匹配
	· 编译器产生的汇编输出（gcc –S）通常有后缀
	· 反汇编转储通常省略后缀
	· Intel 手册总是省略后缀

· 控制流 control flow：
![|550](CSAPP%20图/CSAPP%20图2-33.png)
                             （图三十三：汇编语言的控制流）

1. ***控制：条件码***：
· 处理器状态（x86-64，部分）：
![|450](CSAPP%20图/CSAPP%20图2-34.png)
                    （图三十四：处理器状态反映关于当前执行程序的信息）
![|450](CSAPP%20图/CSAPP%20图2-35.png)
                          （图三十五：设置条件码的关键内容）

· **条件码（隐式设置）**：
· 单个比特位寄存器：
	· `CF` 进位标志（对无符号数）
	· `SF` 符号表示（对有符号数）
	· `ZF` 零标志
	· `OF` 溢出标志（对有符号数）
· 由算术运算隐式设置（看成副作用）：
	· 举例：`addq Src, Dest t = a+b`
	· `CF set`：如果从最高有效位进位（无符号溢出）
	· `ZF set`：如果结果为零
	· `SF set`：如果结果小于零（有符号数）
	· `OF set`：如果补码（有符号数）溢出：
		· `(a>0 && b>0 && t<0) || (a<0 && b<0 && t>=0)`
·  leaq 指令不设置条件码
![|550](CSAPP%20图/CSAPP%20图2-36.png)
                           （图三十六：四种条件吗的设置条件）

· **条件码（显式设置：比较指令）**：
· 由比较指令显式设置：
	· `cmpq Src2, Src1`
	· `cmpq b,a` 类似计算 $a-b$，只是不设置目的操作数
	· `CF set`：如果从最高有效位进位（用于无符号数比较）
	· `ZF set`：如果相等（if a == b）
	· `SF set`：如果小于（有符号数）
	· `OF set`：如果补码（有符号数）溢出：
		· `(a>0 && b<0 && (a-b)<0) || (a<0 && b>0 && (a-b)>0)`

· **条件码（显式设置：测试指令）**：
· 由测试指令显式设置
	· `testq Src2, Src1`：
		· `testq b,a` 类似计算与操作，但是不设置目的操作数
	· 根据与运算的值设置条件码
	· 对于用一个操作数作为掩码很有用
	· `ZF set` 当与结果为 $0$ 时
	· `SF set` 当与结果小于 $0$ 时
	· 非常常用：`testq %rax,%rax`

· **读取条件码**：
· SetX 指令：
	· 根据条件码组合设置目的操作数低字节成 $0$ 或 $1$
	· 不会改变剩余的 $7$ 个字节

| SetX    | 条件 Condition     | 描述 Description |
| :------ | :--------------- | :------------- |
| `sete`  | `ZF`             | 等于 / 零         |
| `setne` | `~ZF`            | 不等 / 不为零       |
| `sets`  | `SF`             | 负数             |
| `setns` | `~SF`            | 非负             |
| `setg`  | `~(SF^OF)&~ZF`   | 大于（有符号数）       |
| `setge` | `~(SF^OF)`       | 大于或等于（有符号数）    |
| `setl`  | `(SF^OF)`        | 小于（有符号数）       |
| `setle` | `(SF^OF)`\| `ZF` | 小于或等于（有符号数）    |
| `seta`  | `~CF&~ZF`        | 高于（无符号数）       |
| `setb`  | `CF`\| `ZF`      | 低于（无符号数）       |
![|400](CSAPP%20图/CSAPP%20图2-37.png)
                       （图三十七：有符号数小于（setl）的使用情况）

· x86-64 整数寄存器：
![|425](CSAPP%20图/CSAPP%20图2-38.png)
                    （图三十八：x86-64 整数寄存器——可以引用低字节）

· **读取条件码**：
· SetX 指令：根据条件码的组合设置单个字节
· 可寻址的字节寄存器之一：不会修改剩余的字节；典型地使用movzbl（0 扩展字节到双字）来完成工作
	· 32 位指令也设置高 32 位为 0
![|550](CSAPP%20图/CSAPP%20图2-39.png)
                        （图三十九：可寻址的字节寄存器之一）
· 显示读取条件码：
![|450](CSAPP%20图/CSAPP%20图2-40.png)
                        （图四十：当心怪异 movzbl（和其他））

2. ***条件分支***：
· **跳转指令 Jumping**：
· 根据条件码跳转到代码的不同部分

| jX    | 条件 Condition      | 描述 Desctiption |
| :---- | :---------------- | :------------- |
| `jmp` | `1`               | 无条件            |
| `je`  | `ZF`              | 相等 / 零         |
| `jne` | `~ZF`             | 不等 / 非零        |
| `js`  | `SF`              | 负数             |
| `jns` | `~SF`             | 非负数            |
| `jg`  | `~(SF^OF)&~ZF`    | 大于（有符号数）       |
| `jge` | `~(SF^OF)`        | 大于或等于（有符号数）    |
| `jl`  | `(SF^OF)`         | 小于（有符号数）       |
| `jle` | `(SF^OF)` \| `ZF` | 小于或等于（有符号数）    |
| `ja`  | `~CF&~ZF`         | 高于 above（有符号数） |
| `jb`  | `CF`              | 低于 below（有符号数） |

![|450](CSAPP%20图/CSAPP%20图2-41.png)
                        （图四十一：条件分支示例（旧版风格））

· *用 goto 代码表达*：
· C 语言允许使用 goto 语句
· 跳转到标号指示的位置
```C
long absdiff(long x, long y)
{
	long result;
	if(x>y) result=x-y;
	else result=y-x;
	return result;
}
```
```C
long absdiff_j(long x, long y)
{
	long result;
	int ntest=(x<=y);
	if(ntest) goto Else;
	result=x-y;
	goto Done;
	Else: result=y-x;
	Done: return result;
}
```

· *通用条件表达式翻译（使用分支）*：
	· C 语言代码：
```C
val = Test ? Then_Expr : Else_Expr;
```
```C
val = x>y ? x-y : y-x;
```
· 将上述代码转成 goto 版本：
```C
ntest = !Test;
if(ntest) goto Else;
val = Then_Expr;
Else: val = Else_Expr;
Done: /*代码*/ return val;
```
· 为 then 和 else 表达式分别创建代码区
· 执行适当的一个代码区

· *使用条件传送指令*：
· 条件传送指令：
	· 指令支持：`if(Test) Dest <- Src`
	· 在 1995 年之后的 x86 处理器得到支持
	· GCC 尝试使用这些指令：但是，仅仅当知道这样是在安全的情况下才行
	· 为何？——指令流通过流水线时分支是非常容易引起混乱的；条件传送不需要控制转移
· C 代码：
```C
val = Test ? Then_Expr : Else_Expr;
```
· goto 版本：
```C
result = Then_Expr;
eval = Else_Expr;
nt = !Test;
if(nt) result = eval;
return result;
```

· <font color="#ffc000">条件传送指令</font>：只有条件成立时，才进行传送；否则，无操作

| 指令       | 条件                | 描述            |
| :------- | :---------------- | :------------ |
| `cmove`  | `ZE`              | 相等 / 零        |
| `cmovne` | `~ZE`             | 不相等 / 非零      |
| `cmovs`  | `SF`              | 负数            |
| `cmovns` | `~SF`             | 非负数           |
| `cmovg`  | `~(SF^OF)&~ZF`    | 大于（有符号 >）     |
| `cmovge` | `~(SF^OF)`        | 大于或等于（有符号 >=） |
| `cmovl`  | `SF^OF`           | 小于（有符号 <）     |
| `cmovle` | `(SF^OF)` \| `ZF` | 小于或等于（有符号 <=） |
| `cmova`  | `~CF&~ZF`         | 高于（无符号 >）     |
| `cmovae` | `~CF`             | 高于或等于（无符号 >=） |
| `cmovb`  | `CF`              | 低于            |
| `cmovbe` | `CF` \| `ZF`      | 低于或等于（无符号 <=） |
![|450](CSAPP%20图/CSAPP%20图2-42.png)
                              （图四十二：条件传送示例）
![|450](CSAPP%20图/CSAPP%20图2-43.png)
                          （图四十三：对于条件传送糟糕的情况）
![|450](CSAPP%20图/CSAPP%20图2-44.png)
                         （图四十四：条件分支部分的示例总结）

3. ***循环***：
· **do-while 循环示例**：
· C 代码：
```C
long pcount_do(unsigned long x)
{
	long result=0;
	do {
		result += x&0x1;
		x>>=1;
	} while(x);
	return result;
}
```
· goto 版本：
```C
long pcount_goto(unsigned long x)
{
	long result=0;
	loop: result += x&0x1;
	x>>=1;
	if(x) goto loop;
	return result;
}
```
· 计算参数 x 中 $1$ 的个数
· 使用条件分支要么继续循环要么退出循环
· x86 作为 CISC 有 popcount 指令

· *通用 do-while 翻译*：
· C 代码：
```C
do
	/*Body*/
	while(Test);
```
· goto 版本：
```C
loop:
	/*Body*/
	if(Test) goto loop;
```
· 循环体：
```C
{
	Statement_1;
	Statement_2;
	……
	Statement_n;
}
```
![|450](CSAPP%20图/CSAPP%20图2-45.png)
                            （图四十五：do-while 循环翻译）
![|400](CSAPP%20图/CSAPP%20图2-46.png)
                         （图四十六：通用“while”循环翻译方法 Ⅰ）
· C 代码：
```C
long pcount_while(unsigned long x)
{
	long result=0;
	while(x)
	{
		result += x&0x1;
		x>>=1;
	}
	return result;
}
```
· 跳转到中间版本：Jump to middle Version
```C
long pcount_goto_jtm(unsigned long x)
{
	long result=0;
	goto test;
	loop: result += x&0x1;
	x>>=1;
	test: if(x) goto loop;
	return result;
}
```
· 相较于该函数的 do-while 版本，初始跳转到从测试开始循环
![|400](CSAPP%20图/CSAPP%20图2-47.png)
                         （图四十七：通用“while”循环翻译方法 Ⅱ）
· C 代码：
```C
long pcount_while(unsigned long x)
{
	long result=0;
	while(x)
	{
		result += x&0x1;
		x>>=1;
	}
	return result;
}
```
· do-while 版本：
```C
long Version pcount_goto_dw(unsigned long x)
{
	long result=0;
	if(!x) goto done;
	loop: result += x&0x1;
	x>>=1;
	if(x) goto loop;
	done: return result;
}
```
· 初始条件检测在循环入口
· 相较于该函数的 do-while 版本：删除跳转到中间这个过程

· *For 循环形式*：
· 通用格式：
```C
for(Init; Test; Update)
	Body
```
```C
#define WSIZE 8*sizeof(int)
long pcount_for(unsigned long x)
{
	size_t i;
	long result=0;
	for(i=0; i<WSIZE; i++) 
	{
		unsigned bit = (x>>i)&0x1;
		result += bit;
	}
	return result;
}
```
![|250](CSAPP%20图/CSAPP%20图2-48.png)
                            （图四十八：“for”循环格式的详解）
· for 循环版本：
```C
for(Init; Test; Update)
	Body
```
· while 循环版本：
```C
Init:
	while(Test)
	{
		Body
		Update;
	}
```
![|400](CSAPP%20图/CSAPP%20图2-49.png)
                        （图四十九：“for”循环到“while”循环的转换）
![|400](CSAPP%20图/CSAPP%20图2-50.png)
                       （图五十：“for”循环到“do-while”循环的转换）

4. ***Switch（开关）语句***：
· **Switch 语句示例**：
```C
long switch_eg(long x, long y, long z)
{
	long w=1;
	switch(x)
	{
		case 1:
			w=y*z;
			break;
		case 2:
			w=y/z;
			/* Fall Through */
		case 3:
			w+=z;
			break;
		case 5:
		case 6:
			w-=z;
			break;
		default:
			w=2;
	}
	return w;
}
```
· 多个情况标签：上述代码中的 case 5 和 case 6
· 落入其他情况（无 break 语句）：上述代码中的 case 2
· 缺失的情况：上述代码中缺失了 case 4
![|450](CSAPP%20图/CSAPP%20图2-51.png)
                              （图五十一：跳转表结构）
![|450](CSAPP%20图/CSAPP%20图2-52.png)
                              （图五十二：开关语句示例 Ⅰ）
![|450](CSAPP%20图/CSAPP%20图2-53.png)
                            （图五十三：开关语句示例 Ⅱ）
![|450](CSAPP%20图/CSAPP%20图2-55.png)
                          （图五十四：汇编程序组织方式解释）
![|700](CSAPP%20图/CSAPP%20图2-54.png)
                     （图五十五：开关语句对应跳转表上的实现方式）
![|450](CSAPP%20图/CSAPP%20图2-56.png)
                        （图五十六：“switch”开关语句示例总结）

5. ***程序的机器级表示 Ⅱ：小结***：
- C 语言控制：
	- if - then - else
	- do - while
	- while，for
	- switch
- 汇编器控制：
	- 条件跳转
	- 条件传送
	- 间接跳转（通过跳转表）
	- 编译器生成代码序列实现更复杂的控制
- 标准技术：
	- 循环转换成 do-while 或跳转到中间的形式
	- 大型 switch 语句使用跳转表
	- 稀疏 switch 语句可能使用决策树
- 本次议题：
	- 控制：条件码
	- 条件分支和条件传送
	- 循环
	- Switch 语句
- 下次议题：
	- 栈 Stack
	- 调用 Call / 返回 Return
	- 过程调用准则 Procedure call discipline
![|500](CSAPP%20图/CSAPP%20图2-57.png)
                            （图五十七：找到二进制跳转表）


### 贰  程序的机器级表示 · 过程数据合纪二

#### 述：
#####
#####

###### · 程序的机器级表示 Ⅲ：过程：
· 目标：
	· push / pop 和 call / ret 指令对的基本功能
	· 能够识别栈的不同组件（返回地址、参数、保存的寄存器、局部变量）
	· 解释被调用者和调用者保存寄存器的不同
	· 解释栈如何允许函数被递归调用 / 重入
· 过程中的机制：
	· 传递控制：
		· 进入过程代码的开始
		· 回到返回点
	· 传递数据：
		· 过程参数
		· 返回值
	· 内存管理：
		· 在过程执行期间分配内存
		· 返回时释放内存
	· 所有机制由机器指令实现
	· x86-64 的过程实现仅使用这些需要的机制
· 机器指令实现该机制，但是具体选择由设计师确定；这些选择构成了应用程序二进制接口（ABI）

1. ***栈结构***：
· x86 的栈：用栈准则管理的一段内存区：
	· 内存看成字节数组
	· 不同区域有不同用途
	· 类似 ABI，策略决策事情
![|450](../../Pasted%20image%2020241025152111.png)
                      （图五十八：x86-64 用栈准则管理的一段内存区）
