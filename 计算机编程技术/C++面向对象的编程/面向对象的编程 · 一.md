### 壹  语言的编译

#### 述：
##### 曾以翻丘为路终，推门海映繁星明。
##### 兴起迈步从头越，金銮九霄大道通。

###### · 编译器与解释器：
· 高级编程语言分为编译型语言、解释型语言；又可以分为静态语言与动态语言
· 静态语言：在编译时变量的数据类型即确定，多数静态类型语言要求在使用变量之前必须声明数据类型，例如 C++、C#、Java、Delphi 等；大多数静态语言又属于编译型语言
· 动态语言：在运行时确定变量的数据类型，变量使用之前不需要类型声明，通常变量的类型是被赋值的那个值的类型，例如 PHP、ASP、Ruby、Python、Perl、ABAP、SQL、JavaScript、Unix Shell 等；几乎所有的动态语言又属于解释型语言
· **编译器**：把源代码整个编译成目标代码，执行时不需要在编译器，直接在支持目标代码的平台上运行，在不同的平台上仍然需要重新编译连接成可执行文件，这样执行效率比解释执行快很多
· 编译器的编译过程：源代码（Source Code）—> 预处理器（Proprecessor）—> 目标代码（Object Code）—> 链接器（Linker）—> 可执行程序（Executables）
· **解释器**：直接执行用编程语言编写的指令的程序，容易让用户实现代码的跨平台，比如 Java、PHP 等，同一套代码可以在几乎所有的操作系统上执行，而无需根据操作系统做修改
· 传统的 BASIC 编译器一次翻译和执行一行，然后把翻译过的行“忘掉”，这使它执行缓慢

###### · 单独编译的工具：
· 在构建大型项目时，单独编译尤为重要，在 C++ 中，可以用小的、可管理的、独立测试的块来创建程序
· 函数是一段代码，可以放在单个文件中，允许单独编译，可以接受参数和返回值，一个文件可以包含多个函数
· **头文件**：头文件是包含库的外部声明的文件，当使用库中的函数和变量时，应该引用头文件
<font color="#ffc000">例</font>：# include < iostream. h >
<font color="#ffc000">例</font>：# include < iostream >
    using namespace std;
<font color="#ffc000">例</font>：# include "self - defined. h"

###### · 第一个 C++ 程序：

· <font color="#ffc000">程序 1 - 1 </font>：Hello, World!
```C++
#include<iostream>
using namespace std;

int main()
{
	cout<<"Hello, World!"<<endl;
	//相当于：printf("Hello, World!\n");
	int x=10, y=20;
	cout<<"x="<<x<<endl<<"y="<<y<<endl;
	//相当于：printf("x=%d\ny=%d\n",x,y);
	cout<<hex<<"x="<<x<<endl<<"y="<<y<<endl;
	//从“hex”之后，所有的数值都将转成十六进制
	return 0;
}
```

· <font color="#ffc000">程序 1 - 2</font> ：程序的输入
```C++
#include<iostream>
using namespace std;

int main()
{
	int x;
	double y;
	char z;
	cin>>x;    //相当于：scanf("%d",x);
	if(!cin) return 0;    //如果输入的 x 不符合数据类型要求（例如输入“a”），则程序直接终止
	cin>>x>>y>>z;    //相当于：scanf("%d%f%c",&x,&y,&z);
	return 0;
}
```

###### · string 字符串：
· 标准 C++ string 类用来处理字符数组的所有底层操作（隐藏）
· 必须引用 C++ 头文件：# include < string >，字符串类位于命名空间 std 中，因此必须使用 using 指令

·<font color="#ffc000"> 程序 1 - 3</font> ：字符串 string
```C++
#include<iostream>
#include<string>
using namespace std;

int main()
{
	string s1;
	string s2="World";    //初始化
	s1="Hello, ";    //赋值操作
	cout<<s1+s2+"!"<<endl;    //输出结果：Hello, World!
	s1+=s2+"!";    //直接“加”后缀
	cout<<s1<<endl;    //输出结果：Hello, World!
	return 0;
}
```

###### · 读写文件：
· 引用头文件：# include < fstream >，打开文件并进行读写操作
· 要打开文件进行读取，需要创建一个 ifstream 对象，其操作类似于 cin
· 要打开文件进行写入，需要创建一个 ofstream 对象，其操作类似于 cout
· 函数 getline() 支持将文件中的一行读入字符串对象
· 函数 getline() 第一个参数是正在读取的 ifstream 对象，第二个参数是字符串对象

· <font color="#ffc000">程序 1 - 4</font> ：读取文件，逐行输出
```C++
#include<string>
#include<iostream>
#include<fstream>
using namespace std;

int main()
{
	ifstream in("Study.txt");    //打开文件“Study.txt”进行读取
	string line;
	if(in)    //如果文件可以打开
	{
		while(getline(in,line))    //找到一行
			cout<<line<<endl;    //输出这一行
	}
	else cout<<"Error in Opening"<<endl;    //否则返回“打开错误”
	in.close();    //关闭文件后才可以访问其他文件
	return 0;
}
```

· <font color="#ffc000">程序 1 - 5</font> ：文件复制
```C++
#include<iostream>
#include<string>
#include<fstream>
using namespace std;

bool CopyFile(char* from, char* to)
{
	ifstream fin(from);
	ofstream fout(to);
	string line;

	if(fin)
	{
		while(getline(fin, line))
		{
			fout<<line<<endl;
		}
		fin.close();
		fout.close();
		return true;
	}
	return false;
}

int main(int argc, char *argv[])
{
	if(CopyFile(argv[1], argv[2])) cout<<"OK"<<endl;
	else cout<<"ERROR"<<endl;
	return 0;
}
```

###### · vector 向量容器：
· 将文件中的行读入字符串，在此期间并不知道需要多少字符串，只有把文件全部读完才知
· 容器可以解决上面这个问题，vector 是最基本的标准容器
· vector 类是一个模板，可以有效地应用于不同类型

· <font color="#ffc000">程序 1 - 6</font> ：将整个文件导入一个字符串容器中：
```C++
#include<string>
#include<iostream>
#include<fstream>
#include<vector>
using namespace std;

int main()
{
	vector <string> v;
	ifstream in("file1.cpp");
	string line;
	while(getline(in, line)) v.push_back(line);    //逐条存入
	for(int i=0; i<v.size(); i++) cout<<i<<":"<<v[i]<<endl;    //添加行号输出
	return 0;
}
```

· <font color="#ffc000">程序 1 - 7</font> ：用 vector 存储数字
```C++
#include<iostream>
#include<vector>
using namespace std;

int main()
{
	vector <int> v;
	for(int i=0; i<10; i++) v.push_back[i];    //存入 0，1，2，3，4，5，6，7，8，9
	for(int i=0; i<v.size(); i++) v[i]=v[i]*10; //转换为 0，10，20，30，40，50，60，70，80，90
	for(int i=0; i<v.size(); i++) cout<<v[i]<<',';    //逐个输出
	cout<<endl;
	return 0;
}
```

###### · 有关于流 stream：

· *流名称约定*：

| 类型        | 输入            | 输出            | 头文件           |
| --------- | ------------- | ------------- | ------------- |
| 泛用        | istream       | ostream       | < iostream >  |
| 文件        | ifstream      | ofstream      | < fstream >   |
| C 字符串（经典） | istrstream    | ostrstream    | < strstream > |
| C 字符串     | istringstream | ostringstream | < sstream >   |

· *预定义流*：

| 流对象  | 功能            |
| ---- | ------------- |
| cin  | 标准输入          |
| cout | 标准输出          |
| cerr | 未缓冲的错误（调试）输出  |
| clog | 缓冲的信息（日志文本）输出 |

· *流操作符*：

| 流操作符                | 功能                | 类型  |
| ------------------- | ----------------- | --- |
| dex，hex，oct         | 设置数制（二进制、十六进制、八进） | I，O |
| endl                | 插入换行符并刷新          | I，O |
| flush               | 刷新输出流缓冲区          | I，O |
| setw(int)           | 设置字段宽度            | I，O |
| setfill(ch)         | 用字符 ch 占未满字段空位    | I，O |
| setbase(int)        | 设置数制的基数           | I，O |
| ws                  | 跳过空格              | I，O |
| setprecision(int)   | 设置浮点精度            | I，O |
| setiosflags(long)   | 设置输出流的格式化标志       | I，O |
| resetiosflags(long) | 关闭设置输出流的格式化标志     | I，O |

· *流标志控制格式*：

| 标识                               | 作用                             | 标识              | 作用                       |
| -------------------------------- | ------------------------------ | --------------- | ------------------------ |
| ios :: skipws                    | 输入流跳过空白字符                      | std :: noskipws | 解除跳过默认字符行为，cin 中正常接收空白字符 |
| ios :: left，ios :: right         | 输出的左对齐和右对齐                     |                 |                          |
| ios :: internal                  | 输出设置内部对齐                       |                 |                          |
| ios :: dec，ios :: oct，ios :: hex | 设置输出的数制                        |                 |                          |
| ios :: showbase                  | 输出时显示数字基数（数制的标志，如八进制基数前缀 “0” ） |                 |                          |
| ios :: showpoint                 | 全局显示小数点                        |                 |                          |
| ios :: uppercase                 | 将十六进制输出的字母全部转化为大写              |                 |                          |
| ios :: showpos                   | 输出的整数前面全部加一个“+”                |                 |                          |
| ios :: scientifis                | 将输出的浮点数转化为科学计数法                | ios :: fixed    | 以固定的精度输出浮点数              |
| ios :: unitbuf                   | 每次输出操作都会立即刷新缓冲区                |                 |                          |


### 贰  C++ 中的 C

#### 述：
##### 笔舞龙蛇一气完，重章复沓韵回环。
##### 莫道异判分歧道，条条路尽终值返。

###### · 函数创建与程序执行流程：
· <font color="#ffc000">程序 1 - 8</font> ：封装斐波那契数列递归函数
```C++
#include<iostream>
using namespace std;

int Fibonacci(int k)
{
	if(k==1) return 1;
	else if(k==2) return 1;
	else return Fibonacci(k-1)+Fibonacci(k-2);
}

int main()
{
	int k;
	cin>>k;
	cout<<Fibonacci(k)<<cout;
}
```

· <font color="#ffc000">程序 1 - 9</font> ：if-else 语句和 while 语句对数组中元素取余 3
```C++
#include<iostream>
using namespace std;

int main()
{
	int arr[8]={0,1,2,3,4,5,6,7};
	int i=0;
	whlie(i<8)
	{
		if(arr[i]%3==0) cout<<0<<endl;
		else if(arr[i]%3==1) cout<<1<<endl;
		else cout<<2<<endl;
		i++;
	}
}
```

· <font color="#ffc000">程序 1 - 10</font> ：用 do-while、break 和 continue 语句确定数组中 0 的位置
```C++
#include<iostream>
using namespace std;

int main()
{
	int arr[8]={1,1,1,1,0,1,1,1};
	int i=0;
	do
	{
		if(arr[i]==1) continue;
		else break;
	} whlie(i<8)
	cout<<i<<endl;
	return 0;
}
```

· <font color="#ffc000">程序 1 - 11</font> ：用 switch-case 语句判定这是 2024 年的第几天
```C++
#include<iostream>
using namespace std;

int main()
{
	int month, day;
	cin>>month>>day;
	int sum;    //总天数
	int limit;    //每个月最大的天数
	switch(month)
	{
		case 1: sum=day, limit=31; break;
		case 2: sum=day+31, limit=29; break;
		case 3: sum=day+60, limit=31; break;
		case 4: sum=day+91, limit=30; break;
		case 5: sum=day+121, limit=31; break;
		case 6: sum=day+152, limit=30, break;
		case 7: sum=day+182, limit=31; break
		case 8: sum=day+213, limit=31; break;
		case 9: sum=day+244, limit=30; break;
		case 10: sum=day+274, limit=31; break;
		case 11: sum=day+305, limit=30; break;
		case 12: sum=day+335, limit=31; break;
		default: cout<<"Error"<<endl; return 0;
	}
	if(day>limit||day<1)
	{
		cout<<"Error"<<endl;
		return 0;
	}
	cout<<"This is the "<<sum;
	switch(sum%20)
	{
		case 1: cout<<"st"; break;
		case 2: cout<<"nd"; break;
		case 3: cout<<"rd"; break;
		default: cout<<"th"; break;
	}
	cout<<" day."<<endl;
	return 0;
}
```

· <font color="#ffc000">程序 1 - 12</font> ：用 goto 语句确定数组中 0 的位置
```C++
#include<iostream>
using namespace std;

int main()
{
	int arr[8]={1,1,1,1,0,1,1,1};
	int i=0;
	mark:;    // goto 的目标地点
	if(arr[i]!=0)
	{
		i++;
		if(i<8) goto mark;
	}
	cout<<i<<endl;
	return 0;
}
```

· <font color="#ffc000">程序 1 - 13</font> ：用 for 语句确定数组中 0 的位置
```C++
#include<iostream>
using namespace std;

int main()
{
	int arr[8]={1,1,1,1,0,1,1,1};
	for(int i=0; i<8; i++)
	{
		if(arr[i]==0)
		{
			cout<<i<<endl;
			return 0;
		}
	}
	return 0;
}
```

· 对于 for 语句，第 11 版 C++ 特加语法：for ( data_type var : collection_to_loop ) { /* Code * / }

· <font color="#ffc000">程序 1 - 14</font> ：循环输出数组内容
```C++
#include<iostream>
using namespace std;

int main()
{
	int arr[]={10,23,45,12,56};
	for(int a:arr) cout<<a<<endl;    //用变量 a 去循环遍历数组 arr
	return 0;
}
```

· <font color="#ffc000">程序 1 - 15</font> ：将向量 vector 容器中每一个数字以 3 倍大小遍历输出
```C++
#include<iostream>
using namespace std;

int main()
{
	vector <int> v;
	int a;
	for(int i=0; i<5; i++)
	{
		cin>>a;
		v.push_back(a);
	}
	for(int x:v) cout<<3*x<<endl;
	return 0;
}
```

###### · 操作符：

1. 常见单目运算符（一元运算符）：

| 符号  | 功能      | 符号  | 功能        | 符号        | 功能      |
| --- | ------- | --- | --------- | --------- | ------- |
| ++  | 自加      | -   | 负数        | new       | 动态分配新内存 |
| --  | 自减      | *   | 指针的定义、解引用 | delete    | 释放内存    |
| ( ) | 强制优先执行等 | &   | 取地址、创建引用  | new[ ]    | 动态分配数组  |
| [ ] | 下标访问    | !   | 逻辑非（逻辑取反） | delete[ ] | 释放数组空间  |
| +   | 正数      | ~   | 按位取反      |           |         |
|     |         |     |           |           |         |

2. 常见双目运算符（二元运算符）：

| 符号  | 功能   | 符号  | 功能      | 符号   | 功能     | 符号  | 功能        |
| --- | ---- | --- | ------- | ---- | ------ | --- | --------- |
| +   | 加    | *=  | 乘后赋值    | \|=  | 按位或后赋值 | &&  | 与         |
| -   | 减    | /=  | 除以后赋值   | ==   | 比较相等性  | <<  | 二进制位左移    |
| *   | 乘    | %=  | 取余后赋值   | !=   | 不等于    | >>  | 二进制位右移    |
| /   | 除以   | &   | 按位与     | >    | 大于     | >>= | 二进制位右移后赋值 |
| %   | 取余   | \|  | 按位或     | <    | 小于     | <<= | 二进制位左移后赋值 |
| =   | 等于   | ^   | 按位异或    | >=   | 大于等于   | ->  | 访问类或结构体对象 |
| +=  | 加后赋值 | ^=  | 按位异或后赋值 | <=   | 小于等于   | ->* | 访问类成员指针   |
| -=  | 减后赋值 | &=  | 按位与后赋值  | \|\| | 或      |     |           |

3. 其他常见运算符：

| 符号     | 功能          | 符号  | 功能      |
| ------ | ----------- | --- | ------- |
| .      | （结构体或类）成员选择 | .*  | 访问成员指针  |
| ::     | 作用域解析       | ? : | 三元条件表达式 |
| sizeof | 获取占用的字节数    |     |         |

###### · 数据类型：

1. 内置类型：
	1. Boolean（bool）布尔型：true or false
	2. Character（char）字符型：signed / unsigned
	3. Integer（int）整型：short / long / signed / unsigned
	4. Floating-point 浮点型：float / double / long double
	5. Void（void）空：函数无返回值

2. 指针：
· 程序中的每一个元素都占用内存且有其地址
· C++ 有一种特殊类型的变量来表示地址，这种变量称之为“指针”

· <font color="#ffc000">程序 1 - 16</font> ：指针输出测试
```C++
#include<iostream>
using namespace std;

int main()
{
	int* p;    //定义一个整型指针，以用来指向整型变量的地址
	int a=1;    //定义整型数据 a=1
	p=&a;    // p 指向存放 a 的地址
	cout<<p<<endl<<*p<<endl;    //输出地址 p 及地址 p 中的内容（此处 “*” 的作用为解引用）
	int b=2;
	p=&b;    //此时 p 将指向存放 b 的地址
	cout<<p<<endl<<*p<<endl;    //输出地址 p 和 b 的值（应为 2 ）
	return 0;
}
```

###### · 参数传递：
· 参数传递有三种实现方式：按值传递、地址（指针）调用、引用传参

· <font color="#ffc000">程序 1 - 17</font> ：函数按值传递参数
```C++
#include<iostream>
using namespace std;

void f(int a)
{
	cout<<"a="<<a<<endl;    //输出 a=47
	a=5;
	cout<<"a="<<a<<endl;    //输出 a=5
}

int main()
{
	int x=47;
	cout<<"x="<<x<<endl;    //输出 x=47
	f(x);
	cout<<"x="<<x<<endl;    //输出 x=47
	return 0;
}
```
· 可以发现，按值传参的函数调用结束后，传入的值并没有得到修改

· <font color="#ffc000">程序 1 - 18</font> ：函数地址（指针）调用传参
```C++
#include <iostream>
using namespace std;

void f(int* p)    //传入地址
{
	cout<<"p="<<p<<endl;    //输出传入的 x 地址
	cout<<"*p="<<*p<<endl;    //输出 *p=47
	*p=5;    //地址所对应的内容值改为 5
	cout<<"p="<<p<<endl;    //输出地址不变
}

int main()
{
	int x=47;
	cout<<"x="<<x<<endl;    //输出 x=47
	cout<<"&x="<<&x<<endl;    //输出 x 的地址，一个例子：0x73ff0c
	f(&x);    //将 x 的地址传入
	cout<<"x="<<x<<endl;    //输出 x=5
	return 0;
}
```
· 可以看到，对于调用地址（指针）的函数，传入地址存放的内容会在函数调用中被修改

· **引用传参**：
· 引用传递是将地址传递给函数的另一种方式
· 引用传递允许函数修改外部对象，就像传递指针一样
· 从语法上讲，调用接受引用的函数比调用接受指针的函数更简洁
· 引用除非作为函数的形参，否则必须初始化：
```C++
· 引用如果不是作为函数的形参，必须初始化：
int a=3;
int &m=a;    //正确
int &m;    //错误
int &m=5;    //错误
```
· “int &m=a;” 这一语句可以理解为“<font color="#00b0f0">给 a 找了一个替身 m </font>”，a 和 m 来自同一个地址，<font color="#00f0f0">当 a 变动时，m 随之修改；同样，当 m 变动时，a 随之修改；</font>m 与 a 就如同同一个事物的两个名字，这也就是为什么必须进行“int &m=a;” 这样的初始化

· <font color="#ffc000">程序 1 - 19</font> ：普通赋值、引用赋值和指针赋值的区别测试
```C++
#include<iostream>
using namespace std;

int main()
{
	int m=3;
	int &k=m;    //引用赋值，“给 m 找了一个替身 k”，m 与 k 在同一地址下
	int n=m;    //直接赋值，n 与 m 只是同值，但不互相约束，不存在同一地址下
	int *p=&m;   //整型指针指向 m 的地址，p 存储在另一个地址下，其值为 m 的地址，仅 *p 修改时影响 m
	m=m+5;    //修改 m 的值以进行测试
	cout<<m<<endl<<k<<endl<<n<<endl<<p<<endl<<*p<<endl;
	//输出的 5 行内容：
	//8
	//8
	//3
	//【m 的存储地址】（一个示例：0x73ff00）
	//8
	return 0;
}
```

· <font color="#ffc000">程序 1 - 20</font> ：按值传参和引用传参的比较
```C++
#include<iostream>
using namespace std;

void f(int a)
{
	cout<<"In f, a="<<a<<endl;
	a=5;
	cout<<"In f, a turns to "<<a<<endl;
}

void g(int& a)
{
	cout<<"In g, a="<<a<<endl;
	a=6;
	cout<<"In g, a turns to "<<a<<endl;
}

int main()
{
	int a=4;
	cout<<"a="<<a<<endl;
	f(a);
	cout<<"a="<<a<<endl;
	g(a);
	cout<<"a="<<a<<endl;
	//输出 7 行内容：
	//a=4
	//In f, a=4
	//In f, a turns to 5
	//a=4
	//In g, a=4
	//In g, a turns to 6
	//a=6
	return 0;
}
```

· <font color="#ffc000">程序 1 - 21</font> ：地址调用和引用传参的比较
```C++
#include<iostream>
using namespace std;

void f(int *a)
{
	cout<<"In f, a="<<a<<endl;
	a=5;
	cout<<"In f, a turns to "<<a<<endl;
}

void g(int& a)
{
	cout<<"In g, a="<<a<<endl;
	a=6;
	cout<<"In g, a turns to "<<a<<endl;
}

int main()
{
	int a=4;
	cout<<"a="<<a<<endl;
	f(&a);
	cout<<"a="<<a<<endl;
	g(a);
	cout<<"a="<<a<<endl;
	//输出 7 行内容：
	//a=4
	//In f, a=4
	//In f, a turns to 5
	//a=5
	//In g, a=5
	//In g, a turns to 6
	//a=6
	return 0;
}
```

· 空指针 void* ：可以定义指向任何类型数据的地址，不可引用，操作时必须指定类型，*不推荐使用*

· <font color="#ffc000">程序 1 - 22</font> ：void* 的定义与操作
```C++
#include<iostream>
using namespace std;

int main()
{
	int i=99;
	void* vp=&i;    // void 指针 vp 指向 i 的地址
	*((int*)vp)=3;    //重新赋值等操作时必须指定这个指针的类型，此处指定为整型指针（int*）
	return 0;
}
```

###### · 作用域：
· 变量的作用域由它“最近”的一组大括号定义
· 变量只能在其作用域内使用

· <font color="#ffc000">程序 1 - 23</font> ：不同作用域下的变量
```C++
#include<iostream>
using namespace std;

int main()
{
	int scp1=1;
	{
		int scp2=2;
		{
			int scp3=3;
			// scp3 只存在于这一层大括号中
			cout<<scp3<<endl;
		}
		// scp2 存在于这一层大括号中
		cout<<scp2<<endl;
	}
	// scp1 存在于整个主函数中
	cout<<scp1<<endl;
	return 0;
}
```

###### · 指定存储分配：

1. 全局变量（global variables）：不受作用域的影响，在整个程序内都可以使用

· <font color="#ffc000">程序 1 - 24</font> ：全局变量的作用范围
```C++
#include<iostream>
using namespace std;

int globe;
int f(int x)
{
	return x+globe;
}

int main()
{
	int x;
	cin>>x;
	x*=globe;
	cout<<f(x)<<endl;
	return 0;
}
```

2. 局部变量（Local variables）：在某一作用域内存在，又称自动变量，在作用域结束后自动消失
（寄存器变量（Register variables）也是一种局部变量，用于提高编译器访问变量速度）

3. 静态变量（Static variables）：存在于程序的整个生命周期，只在固定的作用域起作用

· <font color="#ffc000">程序 1 - 25</font> ：静态变量的全局存在性
```C++
#include<iostream>
using namespace std;

void func()
{
	static int i=0;    //定义静态整型变量 i=0
	cout<<"i="<<++i<<endl;
}

int main()
{
	for(int x=0; x<10; x++) func();
	//程序会输出 1~10 的递增序列
	//如果 func() 函数中的 “i” 不使用静态变量定义，则输出的 10 个数字将均为 1
	return 0;
}
```

4. 外部变量（Extern）：Extern 变量可以在更广阔的区域内作用，甚至其他程序文件（依靠链接 Linkage 实现）

5. 常数（Constants）：常数和变量相似，但不可修改，常数有两种常见定义方式：
	1. 预处理：#define Pi 3.14159（作用域在 # define 和 # undef 之间）
	2. 常数变量声明：const double Pi=3.1415926;
（注：常数的定义必须初始化，除非是作为函数的形参）
```C++
int f(int &x)
{
	return ++x;    //正确
}

int g(const int &x)
{
	return ++x;    //错误
}
```

###### · 几类特殊运算符：

· **移位运算符**：
“<<”：左移位操作符会将一个数的二进制所有位向左移动指定的位数，空出的低位补 0，左移位相当于对原数乘 2 的 n 次方
“>>”：右移位操作符会将一个数的二进制所有位向右移动指定的位数，对于无符号整数，空出的高位补 0，左移位相当于对原数除以 2 的 n 次方

· <font color="#ffc000">程序 1 - 26</font> ：移位操作符的使用
```C++
#include<ostream>
using namespace std;

int main()
{
	unsigned int a=1;
	cout<<a<<',';
	unsigned int b=a<<4;    // a “左移” 4 位
	cout<<b<<','<<a<<',' ;
	a=b>>1;
	cout<<a<<endl;
	//输出结果为 1 行：
	//1,16,1,8
	return 0;
}
```

· **三元（三目）运算符**：a ? b : c;    //如果 a 成立则 b，若不成立则 c
```C++
int a= --b? b: (b=-99);
// b 自减后为 0 吗？如果 b 非零，则将 b 赋值给 a；如果 b=0，则将 b 赋值为 99，再将 b=99 赋值给 a
```

· **字节统计符**：sizeof() 可以反馈数据类型或容器的内存占用，返回值的单位为字节

· <font color="#ffc000">程序 1 - 27</font> ：不同数据类型的内存占用
```C++
#include<iostream>
using namespace std;

int main()
{
	cout<<"bool:"<<sizeof(bool)<<endl;
	cout<<"char:"<<sizeof(char)<<endl;
	cout<<"int:"<<sizeof(int)<<endl;
	cout<<"float:"<<sizeof(float)<<endl;
	cout<<"double"<<sizeof(float)<<endl;
	cout<<"long double"<<sizeof(long double)<<endl;
	//输出：
	//bool:1
	//char:1
	//int:4
	//float:4
	//double:8
	//long double:8
	//不同计算机、不同操作系统、不同编译器的输出结果也会有异
	return 0;
}
```

###### · 复合类型创建：
· C++ 提供的工具支持从基本数据类型组合更复杂的数据类型
· 最重要的复合类型是结构 struct，它是 C++ 中类的基础
· 类型名复杂时，可以通过 typedef 将其更换为另一个名称

· <font color="#ffc000">程序 1 - 28</font> ：结构体的创建和 typedef 更名
```C++
#include<iostream>
using namespace std;

struct LongTypeName
{
	int x;
	int y;
}

int main()
{
	typedef struct LongTypeName ShortName;    //将结构体类型更名为 ShortName
	ShortName point;
	point.x=5;
	point.y=10;
	cout<<point.x<<point.y<<endl;
	return 0;
}
```

###### · 枚举：
· 枚举（enumeration）是一种可以保存用户指定的一组值的类型
· 默认情况下，枚举数的值从 0 开始递增
· 枚举数可以通过整数类型的常量表达式初始化
例：
```C++
enum Weekday
{
	Monday,
	Tuesday,
	Wednesday,
	Thursday,
	Friday,
	Saturday,
	Sunday
};
在这里，默认从头到尾赋值为 0 ~ 6
```
· 枚举数可以更加灵活地定义：
```C++
enum Weekday
{
	Monday=2,
	Tuesday=5,
	Wednesday,
	Thursday,
	Friday,
	Saturday,
	Sunday
};
未指定值的枚举常量将会在上一个指定值的基础上递增，Wednesday=6，一直到 Sunday=10
```
· 枚举值可以重复：
```C++
enum Weekday
{
	Monday=5,
	Tuesday=2,
	Wednesday,
	Thursday,
	Friday,
	Saturday,
	Sunday
};
此时 Monday 和 Friday 都是 5
```

· <font color="#ffc000">程序 1 - 29</font> ：枚举的赋值与使用
```C++
#include<iostream>
using namespace std;

enum Weekday
{
	Monday=1,
	Tuesday,
	Wednesday,
	Thursday,
	Friday,
	Saturday,
	Sunday
};

void Print(Weekday day)
{
	cout<<day<<endl;
}

void Print_2(int day)
{
	cout<<day<<endl;
}

int main()
{
	Weekday today=Tuesday;
	Print(today);    //可以枚举类型传参
	Print_2(today);    //可以作为 int 型传参
	//输出两个 “2”
	return 0;
}
```

###### · 数组和指针：
· 数组的名称可以作为指向其初始元素的指针
· 访问数组既可以通过指向数组的指针加上索引，也可以通过指向元素的指针来实现
· 在C++中，数组没有内置的范围检查机制，编译器不会自动检查数组索引是否在有效范围内：
~~~
	尝试访问数组索引范围之外的元素，默认情况下不会有编译时或运行时错误，访问数组边界之外的元素会导致未定义行为，可能表现为崩溃、错误的结果或其他意外行为
~~~

· <font color="#ffc000">程序 1 - 30</font> ：使用指针访问数组
```C++
#include<iostream>
using namespace std;

int main()
{
	int arr[]={0,1,2,3,4,5,6,7,8,9};
	cout<<arr<<endl;    //相当于输出 arr[0]
	int* ptr=arr;
	cout<<ptr+3<,endl;    //相当于输出 arr[3]
	for(int i=0; i<10; i++) cout<<ptr+i<<endl;    //遍历输出数组
	return 0;
}
```

###### · 利用宏将变量以字符串输出：
· 标准 C 包含了字符串化符号“#”，在预处理器宏中的参数前加上“#”，预处理器会将参数转化为字符串
· 这个方法常用于使调试（Debug）更方便

· <font color="#ffc000">程序 1 - 31</font> ：利用宏将变量以字符串输出
```C++
#include<iostream>
using namespace std;
#define PR(x) cout<<#x<<"="<<x<<endl;    //定义宏函数 PR(x)，用于输出 x 表达式本身和求值结果 

int main()
{
	int a=1, b=2, c=3;
	PR(a+b);    //输出：a+b=3
	PR((c-a)/b);    //输出：(c-a)/b=1
	PR((a+b)*(b+c)*(a+c-b));    //输出：(a+b)*(b+c)*(a+c-b)=30
	return 0;
}
```

###### · 断言函数 assert() ：
· assert() 函数用于在程序中进行断言（Assertion）：断言是一种用于检查程序中某些条件是否为真的机制，如果条件为假，就会导致程序*终止*并*输出错误信息*
· 对于 C 语言，assert() 函数的原型定义在 **< assert.h >** 头文件中：（ C++ 可以调用 **< cassert >** ）
~~~
void assert(int expression);
~~~
· 断言函数接受一个表达式作为参数，如果表达式为真（即非零），则什么都不会发生；但是如果表达式为假（即零），assert() 函数会输出一条错误消息，并且终止程序的执行
· 这个方法常用于使调试（Debug）更方便

· <font color="#ffc000">程序 1 - 32</font> ：用 assert() 函数调试程序
```C++
#include<iostream>
#include<cassert>
using namespace std;

int main()
{
	int x=10;
	assert(x==10);
	cout<<"x="<<x<<endl;
	assert(x/3==3);
	cout<<"x/3="<<x/3<<endl;
	assert(x+1==12);
	cout<<"x+1="<<x+1<<endl;
	return 0;
}
```

###### · 函数的地址：
· 一旦一个函数被编译并加载到计算机中待执行，它就会占用一块内存，并有一个地址
· 可以像使用变量地址一样，将函数地址与指针一起使用

· <font color="#ffc000">程序 1 - 33</font>：函数指针的调用
```C++
#include<iostream>
using namespace std;

void func(int x)
{
	cout<<x<<endl;
}

int main()
{
	void(*funcPtr)(int)=&func;    //定义函数指针（需要给出函数返回类型、函数名称、参数类型）
	//注：在这里可以不使用“&”符号
	void(*funcPtr_2)(int);
	funcPtr_2=func;    //写成“funPtr_2=&func”也可以
	int x;
	cin>>x;
	(*funcPtr)(x);    //通过指针调用函数
	(*funcPtr_2)(x);    //通过另一个指针调用同一个函数
	return 0;
}
```

· <font color="#ffc000">程序 1 - 34</font> ：加载动态链接库，调用函数
```C++
#include<iostream>
#include<tchar.h>
#include<windows.h>
using namespace std;

typedef int (*CallFunction)(int a, int b);
//该函数指针可以指向一个返回类型为 int，接受两个 int 类型参数的函数
//把这样的函数指针重命名为 CallFunction

int main(void) {
    HINSTANCE hDLL;    //句柄
    CallFunction JIA;    //定义 JIA，其类型为：int f(int a, int b) 型函数指针

    hDLL=LoadLibrary(_T("MyDll.dll"));
    //加载名为“MyDll.dll”的 DLL 文件
	//如果加载成功，则返回 DLL 的句柄，否则返回 nullptr
    if (hDLL==nullptr) {
        cout<<"NULL"<<endl;
        return 0;
    }

    //加载动态链接库
    JIA = (CallFunction) GetProcAddress(hDLL, "Add");
    //将动态链接库（DLL）中的函数地址赋值给函数指针
    cout<<(*JIA)(10, 20)<<endl;    //通过“*JIA”调用函数，传入参数 10 和 20 

    FreeLibrary(hDLL);    //卸载动态链接库（DLL）并释放相关资源
    return 0;
}
```


### 叁  数据抽象

#### 述：
##### 帐中帷幄千里功，一室点灯万家明。
##### 随风越海传清曲，又惹多少共此情？

###### · 动态内存分配：
· **固定（静态）分配**：在编译时为对象分配内存
· **动态分配**：在运行时为对象分配内存
· 在程序运行之前，常常不知道将使用多少内存，因此需要动态地为程序分配内存
· 在 C 语言中，可以使用两个函数：malloc() 和 free()
· 在 C++ 中，有两个新的关键字可以使用：new 和 delete：
	1. new 用于动态分配内存
	2. delete 用于动态释放内存

· **悬挂指针（suspeded point）** 是指向一块已经释放的内存，或者指向未分配给用户使用的内存的指针
· 定义后未初始化的指针不是悬挂指针，它会随机指向一块区域
![[C++图/C++图1-1.png]]
（图一：关键字 new 的作用：悬挂指针开辟地址等待存放）

· <font color="#ffc000">程序 1 - 35</font> ：动态分配、释放内存测试
```C++
#include<iostream>
using namespace std;

int main()
{
	int *p;
	p=new int;
	*p=10;    //上面这三行等同于：int *p=new int(10);
	cout<<"Dynamically allocate memory: "<<p<<endl;
	delete p;    // p 指向的内存被释放，此时 p 成为了一个悬挂指针，这个内存不能再使用
	cout<<p<<endl;    // p 指向的内存被释放，不可使用，但是仍然还会有输出，输出地址同上
	return 0;
}
```

· <font color="#ffc000">程序 1 - 36</font> ：数组内存动态分配与释放
```C++
#include<iostream>
using namespace std;

int main()
{
	int* p=new int[5];    //开辟一个空间大小为 “5” 的整型数组
	for(int j=0, j<5; j++)
	{
		*(p+j)=10*j;    //将数组的五个位置按序填充：0，10，20，30，40
	}
	for(int j=0; j<5; j++)
	{
		cout<<"p["<<j<<"]="<<p[j]<<endl;    //按序打印数组
	}
	delete[] p;    //释放数组内存
	return 0;
}
```
· 注意，这里使用了 `delete[] p` 来释放整个数组的内存，如果单纯使用 `delete p` 只能删去数组的首个元素空间，容易导致其余元素所占用的内存泄漏，还会导致释放数组内存时的未定义行为

· 数组动态分配内存初始化方法：
```C++
int* p=new int[5] {1,2,3,4,5};
```

###### · 处理内存耗尽：
· 当没有足够的可用内存来满足 new 操作符对动态内存的请求时，就会发生*内存耗尽*
· 内存耗尽可以通过 new 的返回值进行测试

· <font color="#ffc000">程序 1 - 37</font> ：内存耗尽的检测
```C++
#include<iostream>
using namespace std;

int main()
{
	int* p=new int[50];
	if(p==nullptr)
	{
		cout<<"Exhaustion!"<<endl;    //如果内存耗尽，则输出“Exhaustion!”，程序终止
		return 0;
	}
	/*其他代码*/
	delete[] p;
	return 0;
}
```

###### · 类（Class）：
· 在 C 语言中，当开始处理一组特征时，将它们聚集到一个结构体中是非常方便的
· C++ 的函数可以放到结构体中，作为“成员函数”：
```C++
struct Stash {    //存储空间操作函数
    int size;    //每个存储空间的大小
    int quantity;    //存储空间的数量
    int next;    //下一个空闲空间的索引
    unsigned char* storage;    //动态分配的存储空间

    //成员函数
    void initialize(int size);    //初始化 Stash 对象
    void cleanup();    //清理 Stash 对象
    int add(const void* element);    //向 Stash 添加元素
    void* fetch(int index);    //从 Stash 获取元素
    int count();    //返回 Stash 中元素的数量
    void inflate(int increase);    //增加存储空间
};
```
· 注：C++ 不要求创建 typedef，C++ 可以自动将结构体名称转换为程序中的一个数据类型：
```C++
Stash A,B,C;
```

· 类是 C++ 中一个基本的面向对象编程（OOP）概念
· 类在各方面都与 struct 关键字相同，除了一点：class 默认为 *private*，而 struct 默认为 *public*
```C++
class Stash
{
	private:
	int size;
	int quantity;
	int next;
	unsigned char* storage;

	public:
	void initialize(int size);
	void cleanup();
	int add(const void* element);
	void* fetch(int index);
	int count();
	void inflate(int increase);
};
```
· 类的声明：
```C++
class 类名
{
	public:  公有成员（外部接口）
	private:  私有成员（只允许本类中的函数访问，而类外部的任何函数都不能访问）
	【class 中的成员会默认私有！（struct 中成员默认公有）】
	protected:  保护成员（与 private 类似，差别表现在继往与派生时）
};
```

· 成员函数：类内的成员函数必须在类中声明，但是可以在外部给出具体的执行程序

· <font color="#ffc000">程序 1 - 38</font> ：类的成员函数的调用
```C++
#include<iostream>
using namespace std;

class Test
{
	public:
	int x_;
	void init(int x, int y, int z)
	void display()    //类内成员函数
	{
		cout<<x_<<endl;
	}

	private:
	int y_;

	protected:
	int z_;
};

void Test::init(int x, int y, int z)    //类外成员函数
{
	x_=x;    //访问类 Test 中的变量
	y_=y;
	z_=z;
}

int main()
{
	Test t;    //创建一个对象 t，其类型为类 Test
	t.init(1,2,3);    //调用 t 内的函数，将 1、2、3 传给类中的 x_、y_、z_
	t.display();    //将 x_ 输出，最终输出结果为 1
	return 0;
}
```

###### · 抽象数据类型（Abstract Data Type，ADT）：
· 用函数打包数据的能力支持创建新的数据类型，例如上面程序 1 - 38 的 “Test”，这通常被称为封装
· 程序 1 - 38 的 “Test” 是用户定义的数据类型，这称为“抽象数据类型”
· “对象.成员函数”的写法：`object.memberfunction(arglist)` 表示调用对象的成员函数，在面向对象的术语中，这也被称为“向对象发送消息”
· ADT 通常由数据和对该数据执行的操作组成
· ADT 将数据和操作分离开，使得用户可以通过操作来访问和操作数据，而不必关心数据的内部实现细节
· 常见的抽象数据类型包括栈、队列、树、图等
· 使用抽象数据类型创建的变量称为该类型的**对象**或**实例**

###### · 嵌套结构：

· <font color="#ffc000">程序 1 - 39</font> ：嵌套结构的定义
```C++
#include<iostream>
using namespace std;

//外部结构声明
struct Address
{
	string city;
	int zipCode;
};

//内部结构声明
struct Person
{
	string name;
	int age;
	Address address;    //嵌套的 Address 结构作为成员
};

int main()
{
	//创建 Person 对象
	Person person;

	//设置 Person 对象的属性
	person.name="Zhang_San";
	person.age=18;
	person.address.city="Fushun_Liaoning";
	person.address.zipCode=113000;

	//输出 Person 对象的属性
	cout<<"Name: "<<person.name<<endl;
	cout<<"Age: "<<person.age<<endl;
	cout<<"Address: "<<person.address.city<<", "<<person.address.zipCode<<endl;
	return 0;
}
```

· <font color="#ffc000">程序 1 - 40</font> ：嵌套结构的应用
```C++
#include<iostream>
#include<string>
#include<vector>
using namespace std;

//课程成绩的嵌套结构
struct Course
{
	string name;
	double grade;
};

//学生的嵌套结构
struct Student
{
	string name;
	int id;
	vector <Course> courses;    //存储学生的课程信息
};

int main()
{
	//创建学生对象
	Student student1;
	student.name="Zhang_San";
	student.id=202201;

	//添加学生的课程信息
	Course course1={"Math", 90.0};
	Course course2={"Chinese", 95.5};
	student1.course.push_back(course1);
	student1.course.push_back(course2);

	//输出学生信息和课程成绩
	cout<<"Student Name: "<<student1.name<<endl;
	cout<<"Student ID: "<<student.id<<endl;
	cout<<"Course Grades: "<<endl;
	for(const Course& course : student1.courses)
	{
		cout<<"- "<<course.name<<": "<<course.grade<<endl;
	}
	return 0;
}
```

###### · 全局范围解析操作符（::）：
· 全局范围解析操作符（::）在 C++ 中被用来访问全局作用域中的变量、函数、类等，它可以用来指示编译器一个标识符应该在全局作用域中查找，而不是当前作用域

· <font color="#ffc000">程序 1 - 41</font> ：访问全局变量
```C++
#include<iostream>
using namespace std;

int x=2;
int main()
{
	int x=1;
	cout<<"Local variable x: "<<x<<endl;    //访问局部变量
	cout<<"Global variable x: "<<::x<<endl;    //用 “::x” 形式访问全局变量
	//输出结果：
	//Local variable x: 1
	//Global variable x: 2
	return 0;
}
```
· 在 C++ 中，两个 “x” 存在于不同的作用域中，一个是全局变量，一个是局部变量，同名并不冲突

· <font color="#ffc000">程序 1 - 42</font> ：访问全局函数
```C++
#include<iostream>
using namespace std;

void foo()
{
	cout<<"Global function foo()"<<endl;
}

int main()
{
	foo();    //调用全局函数 foo()
	::foo();    //使用全局范围解析操作符调用全局函数 foo()
	return 0;
}
```

· <font color="#ffc000">程序 1 - 43</font> ：访问全局命名空间
```C++
#include<iostream>
using namespace std;

namespace ns
{
	int x=10;
}

int x=20;

int main()
{
    std::cout<<"Global namespace variable x: "<<::x<<endl;    //输出全局命名空间中的 x
    std::cout<<"Namespace variable x: "<<ns::x<<std::endl;    //输出命名空间 ns 中的 x
    return 0;
}
```

· <font color="#ffc000">程序 1 - 44</font> ：类内成员函数外部定义
```C++
#include <iostream>
using namespace std;

int a;    //全局变量
void f()    //全局函数 f()
{
	cout<<"Hello!"<<endl;
}

class S
{
	public:
    int a;    //类 S 内成员变量
    void f();    //类 S 内成员函数()
};

void S::f()    //对类 S 内成员函数 f() 进行操作定义
{
    ::f();    //调用全局函数 f()
    ::a++;    //访问全局变量 a
    a--;    //访问 S 类的成员变量 a
}

int main()
{
    S s;
    s.f();    //调用类 S 内函数 f()
    f();    //调用全局函数 f()
    return 0;
}
```


### 肆  访问控制

#### 述：
#####
#####

###### · 访问控制：
· 控制成员的访问（私有和公共）有两个原因：
1. 防止客户程序员触及它们不应该触及的函数，这意味着类的设计者可以选择隐藏一些实现细节，只暴露给客户程序员应该使用的函数和数据，从而减少了客户程序员误操作的可能性，提高了代码的健壮性和稳定性
2. 允许库设计者在不担心如何影响客户程序员的情况下更改类的内部工作方式，这意味着库设计者可以自由地修改类的内部实现细节，而不必担心会破坏已有的客户代码；通过仅暴露必要的公共接口，库设计者可以在不影响客户代码的情况下进行修改，从而提高了代码的灵活性和可维护性

· <font color="#ffc000">程序 1 - 45</font> ：public 成员和 private 成员的选取
```C++
#include<iostream>
using namespace std;

class Point
{
	public:
	double GetX();
	double GetY();
	void SetX(double valX) {x=valX;}
	void SetY(double valY) {y=valY;}

	private:
	double x,y;
};    //不要忘记分号！

double Point::GetX() {return x;}
double Point::GetY() {return y;}

int main()
{
	Point p,p2;
	p.SetX(300);
	p2=p;
	cout<<"x="<<p2.GetX()<<endl;
	//输出：
	return 0;
}
```

· 类对象包含类中定义的数据的副本：
	1. 函数是共享的
	2. 数据是属于类对象自己的
![[C++图/C++图1-2.png]]
（图二：类中定义的数据的存储方式）

· **public** 的部分构成了类对象的公共接口，如果函数 f() 是类 Cla 的公共成员函数，你可以这样写：
```C++
Cla p;
p.f();
```
· **private** 的部分只能由成员函数使用，如果 f() 是类的私有成员函数，则不能像上述那样写

· 关于定义类的注意事项：
1. 数据成员应该是私有（private）的，公共数据成员违反封装原则
2. 一些函数成员服务于类外，它可以是公共（public）的

###### · 友元：
· 友元函数是可以获得类的私有成员的函数，但它不属于这个类（非成员函数）
· 亦即友元函数只是获得了访问并修改类中私有成员的权限，但并不是类的一部分，不过需要在类中声明

· <font color="#ffc000">程序 1 - 46</font> ：全局函数作为友元
```C++
#include<iostream>
using namespace std;

class Time
{
	int hours, minutes;    //默认私有
	public:
	void SetTime(int nhours, int nminutes)
	{
		hours=nhours;
		minutes=nminutes;
	}
	friend void show(const Time&);    //友元函数
};

void show(const Time& showTime)    //注意：这里没有“friend”前缀
{
	//访问私有成员
	cout<<showTime.hours<<":"<<showTime.minutes<<endl;
}

int main()
{
	Time time;
	time.SetTime(20, 30);

	//调用友元函数
	show(time);
	return 0;
}
```

· <font color="#ffc000">程序 1 - 47</font> ：全局函数同时作为两个类的友元
```C++
#include<iostream>
using namespace std;

class Boat;    //提前声明
class Car
{
	public:
	Car(int i)
	{
		weight=i;
	}
	friend int totalWeight(Car &c, Boat &b);

	private:
	int weight;
};

class Boat
{
	public:
	Boat(int i)
	{
		weight=i;
	}
	friend int totalWeight(Car &c, Boat &b);

	private:
	int weight;
};

int totalWeight(Car &c, Boat &b)
{
	return c.weight+b.weight;
}

int main()
{
	Car c(10);
	Boat b(8);
	cout<<"The Total Weight is "<<totalWeight(c,b)<<endl;
	//输出：The Total Weight is 18
	return 0;
}
```


### 伍  初始化与清理

#### 述：
#####
#####

###### · 使用构造函数进行初始化：

· <font color="#ffc000">程序 1 - 48</font> ：用自定义函数 Init 对变量初始化
```C++
#include<iostream>
using namespace std;

class Point
{
	public:
	void Init(double a, double b)
	{
		coordX=a;
		coordY=b;
	}
	double GetX() {return coordX;}
	double GetY() {return coordY;}

	private:
	double coordX, coordY;
}

int main()
{
	Point p;
	p.Init(1, 2);
	cout<<"x coordinate: "<<p.GetX()<<endl;
	return 0;
}
```
· 程序员希望对象在创建时能够自动初始化

· 在 C++ 中，初始化十分重要，不能留给客户端程序员
· 编译器在创建对象时自动调用构造函数

· <font color="#ffc000">程序 1 - 49</font> ：构造函数的初始化作用
```C++
#include<iostream>
using namespace std;

class Point
{
	public:
	Point()
	{
		coordX=0;
		coordY=0;
	}
	void SetPoint(double x, double y)
	{
		coordX=x;
		coordY=y;
	}
	double GetX() {return coordX;}

	private:
	double coordX, coordY;
}

int main()
{
	Point p;
	p.SetPoint(1,2);
	cout<<"x coordinate: "<<p.GetX()<<endl;
	return 0;
}
```
· **构造函数**通过与类本身具有相同的名称来识别
· 构造函数由 C++ 自动调用，用来创建对象
· 如果不定义构造函数，C++ 提供默认构造函数，没有参数，没有实现
· 注意：<font color="#ffff00">不能在类中的 private 中直接赋值初始化，私有成员变量只能在类的内部访问</font>，而类的声明是外部可见的，无法访问私有成员变量
· 构造函数没有返回类型
· 构造函数在创建对象时自动调用
· 构造函数不能被对象调用
· 一个类中可能有许多构造函数，构造函数的重载可以根据需要提供不同的初始化方式

· <font color="#ffc000">程序 1 - 50</font> ：构造函数的重载
```C++
#include <iostream>
using namespace std;

class Point
{
	public:
    double x, y, z;

    // 无参构造函数，初始化坐标为 (0, 0, 0)
    Point()
    {
        x=0;
        y=0;
        z=0;
    }

    // 构造函数重载，接受两个参数
    Point(double xVal, double yVal)
    {
        x=xVal;
        y=yVal;
        z=0;
    }

    // 构造函数重载，接受三个参数
    Point(double xVal, double yVal, double zVal)
    {
        x=xVal;
        y=yVal;
        z=zVal;
    }
};

int main()
{
    //使用不同的构造函数创建对象
    Point p1;    //使用无参构造函数，注意没有括号
    Point p2(1, 2);    //使用接受两个参数的构造函数
    Point p3(3, 4, 5);    //使用接受三个参数的构造函数

    //输出各个对象的坐标
    cout<<"p1 coordinates: ("<<p1.x<<", "<<p1.y<<", "<<p1.z<<")"<<endl;
    cout<<"p2 coordinates: ("<<p2.x<<", "<<p2.y<<", "<<p2.z<<")"<<endl;
    cout<<"p3 coordinates: ("<<p3.x<<", "<<p3.y<<", "<<p3.z<<")"<<endl;
    return 0;
}
```

###### · 用析构函数进行清理：
· 在 C++ 中，清理和初始化一样重要，析构函数用于清理并释放资源
· 析构函数通过与类本身具有相同的名称，并带有补体符号（~）来识别
· 析构函数没有任何参数

· <font color="#ffc000">程序 1 - 51</font> ：析构函数的定义与自动调用
```C++
#include<iostream>
using namespace std;

class Point
{
	public:
	Point(double x, double y)
	{
		coordX=x;
		coordY=y;
	}
	~Point()    //析构函数的设置
	{
		cout<<"This is destructor of Point class."<<endl;
	}
	void Print()
	{
		cout<<"("<<coordX<<", "<<coordY<<")"<<endl;
	}

	private:
	double coordX, coordY;
};

int main()
{
	Point p(1, 1);
	p.Print();
	//输出：
	//(1, 1)
	//This is destructor of Point class.
	return 0;    //析构函数会在程序结束，对象销毁时自动调用
}
```

· 注意：
1. 析构函数没有返回类型，也没有参数
2. 析构函数在对象被销毁时自动调用
3. 一个类中只有一个析构函数
4. *析构函数的调用顺序与构造函数相反*

· <font color="#ffc000">程序 1 - 52</font> ：析构函数的调用顺序与构造函数相反
```C++
#include<iostream>
using namespace std;

class Point
{
	public:
	Point(double x, double y)
	{
		coordX=x;
		coordY=y;
	}
	~Point()    //析构函数的设置
	{
		cout<<"("<<coordX<<", "<<coordY<<")"<<endl;
	}

	private:
	double coordX, coordY;
};

int main()
{
	Point p1(1, 1);
	Point p2(3, 5);
	Point p3(7, 9);    //析构函数的调用顺序与构造函数相反
	//输出：
	//(7, 9)
	//(3, 5)
	//(1, 1)
	return 0;
}
```

· 如果客户端程序员需要显式调用析构函数，则必须定义类的指针，并与操作符 new 和 delete 一起使用

· <font color="#ffc000">程序 1 - 53</font> ：用 delete 显式实现析构
```C++
#include<iostream>
using namespace std;

class Point
{
	public:
	Point(double x, double y)
	{
		coordX=x;
		coordY=y;
	}
	~Point()    //析构函数
	{
		cout<<"Destructor"<<endl;
	}

	private:
	double coordX, coordY;
};

int main()
{
	Point *p;
	p=new Point(1,1);    //调用构造函数
	delete p;    //调用析构函数
	//输出：
	//Destructor
	return 0;
}
```

· <font color="#ffc000">程序 1 - 54</font> ：用创建对象数组方式多次调用构造与析构函数
```C++
#include<iostream>
using namespace std;

class Point
{
	public:
	Point(): coordX(1), coordY(1) {};    //默认构造函数
	Point(double x, double y)
	{
		coordX=x;
		coordY=y;
	}
	~Point()    //析构函数
	{
		cout<<"Destructor"<<endl;
	}

	private:
	double coordX, coordY;
};

int main()
{
	Point *p;
	p=new Point[5];    //调用构造函数 5 次
	delete[] p;    //调用析构函数 5 次
	//输出：
	//Destructor
	//Destructor
	//Destructor
	//Destructor
	//Destructor
	return 0;
}
```

· 构造函数与析构函数：

| 序号  | 构造函数               | 析构函数                   |
| --- | ------------------ | ---------------------- |
| 1   | 构造函数初始化对象并构造给定类型的值 | 析构函数清理并释放资源            |
| 2   | 构造函数依靠与类相同的名称被识别   | 析构函数与类名相同，依靠前缀“~”符号被识别 |
| 3   | 构造函数可以被重载          | 析构函数没有正式参数，不能被重载       |
| 4   | 构造函数没有返回值          | 析构函数没有返回值              |
| 5   | 构造函数在创建对象时被调用      | 析构函数在对象被销毁时被调用         |

· <font color="#ffc000">程序 1 - 55</font> ：具有动态内存的构造函数和析构函数
```C++
#include<iostream>
using namespace std;

class CMyString
{
	public:
	CMyString() {str=new char[50];}
	void Copy(char*);
	~CMyString()
	{
		if(str!=nullptr) delete str[];
	}

	private:
	char* str;
};

void CMyString::Copy(char* ch)
{
	int i=0;
	while(ch[i]!='\0')
	{
		str[i]=ch[i];
		i++;
	}
	str[i]=ch[i];  //'\0'
	cout<<str<<endl;
}

int main()
{
	CMyString my;
	my.Copy("hello!");
	return 0;
}
```

###### · 聚合初始化：
· 数组的几种常见初始化方式：
```C++
1. int a[5]={1,2,3,4,5};
2. int b[5]={2};    //后面默认补四个零
3. int c[]={1,2,3,4};    //默认这个数组的长度就是 4，其内容为 1，2，3，4
```
· 对象数组的初始化：
```C++
1. Point p[3]={Point(1,2), Point(3,4), Point(5,6)};
2. Point p[3];
	p[0]=Point(1,2);
	p[1]=Point(3,4);
	p[2]=Point(5,6);
```

· <font color="#ffc000">程序 1 - 56</font> ：对对象进行聚合初始化
```C++
#include<iostream>
using namespace std;

class DATE
{
	private:
	int year, month, day;

	public:
	DATE()
	{
		year=month=day=0;
		cout<<"Default constructor called."<<endl;
	}
	DATE(int y, int m, int d)
	{
		year=y, month=m, day=d;
		cout<<"Constructor called."<<day<<endl;
	}
	~DATE()
	{
		cout<<"Destructor called."<<day<<endl;
	}
	void Print()
	{
		cout<<year<<": "<<month<<": "<<day<<endl;
	}
};

int main()
{
	DATE date[3]={DATE(2024,3,10), DATE(2024,3,11)};
	date[0].Print();
	date[1].Print();
	date[2].Print();
	//九行输出：
	//Constructor called.10    //重载构造函数调用
	//Constructor called.11    //重载构造函数调用
	//Default constructor called.    //默认构造函数调用
	//2024: 3: 10    //输出给定值
	//2024: 3: 11    //输出给定值
	//0: 0: 0    //输出默认值
	//Destructor called.0    //析构输出默认值
	//Destructor called.11    //析构输出给定值
	//Destructor called.10    //析构输出默认值
	return 0;
}
```

