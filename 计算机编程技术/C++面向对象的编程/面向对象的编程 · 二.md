### 壹  函数重载与默认参数

#### 述：
#####
#####

###### · 函数名装饰：
· 当某些函数对不同类型的对象执行相同的任务时，给它们起相同的名字会更方便
· 对不同类型的操作使用相同的名称称为**重载**
· 调用时具体“传唤”的是哪一个？——调用与参数最匹配的函数（包括参数的个数和参数的类型）

· <font color="#22d050">程序 2 - 1</font> ：math.h 头文件中的绝对值函数
```C++
#include<iostream>
#include<math.h>
using namespace std;

int main()
{
	int a=-1;
	double b=-1.0;
	long c=-1;
	cout<<abs(a)<<endl;    //整型绝对值
	cout<<fabs(b)<<endl;    //浮点型绝对值
	cout<<labs(c)<<endl;    //长整数绝对值
	//输出：
	//1
	//1
	//1
	return 0;
}
```

· <font color="#22d050">程序 2 - 2</font> ：参数个数不同实现函数重载
```C++
#include<iostream>
using namespace std;

int min(int a, int b)
{
	return a<b? a: b;
}

int min(int a, int b, int c)
{
	int t=min(a,b);
	return min(t,c);
}

int main()
{
	cout<<min(-2,8,0)<<endl;    //自动选择函数 min(int, int, int)
	cout<<min(0,8)<<endl;    //自动选择函数 min(int, int)
	//输出：
	//-2
	//0
	return 0;
}
```

· <font color="#22d050">程序 2 - 3</font> ：参数类型不同实现函数重载
```C++
#include<iostream>
using namespace std;

int min(int a, int b)
{
	return a<b? a: b;
}

double min(double a, double b)
{
	return a<b? a: b;
}

int main()
{
	cout<<min(23, 87)<<endl;
	cout<<min(0.538, 8.72)<<endl;
	//输出：
	//23
	//0.538
	return 0;
}
```

· <font color="#22d050">程序 2 - 4</font> ：构造函数的重载
```C++
#include<iostream>
using namespace std;

class Stash
{
	int size;    //每个空间的大小
	int quantity;    //存储空间的数量
	int next;    //下一个空的空间
	unsigned char* storage;    //动态分配的字节数组
	void inflate(int increase);

	public:
	Stash(int size) {cout<<size<<endl;}
	Stash(int size, int initQuantity) {cout<<size<<endl<<initQuantity<<endl;}
	int add(void* element);
	void* fetch(int index);
	int count();
};

int main()
{
	Stash s1(1,1);
	Stash s2(3);
	//输出：
	//1
	//1
	//3
	return 0;
}
```

· 注意：无法重载按返回类型区分的函数，如下面两个函数不可以同时设置：
```C++
int func() {return 1;}
double func() {return 1;}
```

###### · 默认参数：
· 参数可以被赋予默认值
· 当在函数调用中没有为参数指定实际参数时，参数将采用其默认值

· <font color="#22d050">程序 2 - 5</font> ：函数默认参数的使用
```C++
#include<iostream>
using namespace std;

void Register(int age)
{
	cout<<age<<" is OK."<<endl;
}

bool Enroll(int age=18)
{
	if(age<15||age>35) return false;
	Register(age);
	return true;
}

int main()
{
	int y=Enroll(23);
	int z=Enroll();    //此处采用了默认值
	cout<<y<<endl<<z<<endl;
	//输出：
	//23 is OK.
	//18 is OK.
	//1
	//1
	return 0;
}
```
· 注意：*默认参数*在某些情况下会与*函数重载*发生冲突
· 函数重载是一种用于多个同名函数的机制，它是对多态性的反映
· 在 C++ 中，函数不仅由名称标识，还由数字、形参类型和关键字标识，const 作为类的成员函数，这些被称为签名

· <font color="#22d050">程序 2 - 6</font> ：用默认参数优化构造函数重载代码
```C++
#include<iostream>
using namespace std;

class Point
{
	public:

	//改善前代码：
	//Point()
	//{coordX=0, coordY=0;}
	//Point(double x, double y)
	//{coordX=x, coordY=y;}

	//改善后代码：
	Point(double x=0, double y=0)
	{
		coordX=x, coordY=y;
	}

	private:
	double coordX, coordY;
};

int main()
{
	Point p;
	return 0;
}
```

· <font color="#22d050">程序 2 - 7</font> ：求一个数值范围内数字的和
```C++
#include<iostream>
using namespace std;

int sum(int lower, int upper, int inc=1)    // inc 表示增量
{
	int sum=0;
	for(int k=lower; k<=upper; k+=inc) sum+=k;
	return sum;
}

int main()
{
	int result=sum(1,100);
	cout<<"The sum from 1 to 100 step 1 is "<<result<<endl;
	result=sum(1,100,2);
	cout<<"The sum from 1 to 100 step 1 is "<<result<<endl;
	//输出：
	//The sum from 1 to 100 step 1 is 5050
	//The sum from 1 to 100 step 1 is 2500
}
```

· 默认参数可以是常量或表达式：
```C++
int Now();
void delay(int k, int time=Now());
```
· 默认参数只能在同一作用域内初始化一次：
```C++
class Sample
{
	public:
	void f(int a=0);
};

void Sample::f(int a=0) {/*代码*/}    错误：重新进行默认参数的定义，即使再定义的是同一个值也不可
```

· 默认参数的一个特别重要的用途是：当开始使用带有一组参数的函数时，如果已经使用了一段时间却发现需要添加参数，通过默认所有新参数，可以确保使用先前接口的所有客户机代码都不会受到干扰


### 贰  常量

#### 述：
#####
#####

###### · 数值常量：
· 常量（用 const 关键字表示）是为了让程序员能够在变化和不变之间划清“界限”，这为 C++ 编程项目提供了安全和控制
· 常量被用在指针、函数参数、返回类型、类对象和成员函数上
· 定义常量时，在 C 中使用宏定义：#define，但在 C++ 中可以使用关键字：const
```C++
· #define PI 3.14 ==> const double PI=3.14;
```
· 这样便于程序员知道 “PI” 是哪种类型的数据；在宏定义中，PI 只是一个符号，表示 3.14，而非 double

· 常量必须初始化，而且不能被再度赋值
· 常量可以这样赋值：
```C++
1. const int x=10;    //正确
2. int const x=10;    //正确
```

###### · 指针常量：
· 可以定义指针常量：
```C++
int const *var;
const int *var;
```
*【在这个定义中，var 指向的值 * var 是常量，但 var 本身是一个变量！】*
![[C++图/C++图2-1.png]]
（图一：int const * p 的定义下，指针所指向的值是常量，但指针本身是一个变量）
```C++
int* const var;
```
*【在这个定义中，var 指向的值 * var 是变量，但 var 本身是一个常量】*
![[C++图/C++图2-2.png]]
（图二：int* const p 的定义下，指针所指向的值是变量，但指针本身是一个常量）

· <font color="#22d050">程序 2 - 8</font> ：int const * p 定义下，指针常量本身的修改
```C++
#include<iostream>
using namespace std;

int main()
{
	int x=10, y=100;
	const int *p=&x;    //定义指针常量
	//注意：如果此时再写：*p=50; 这样的赋值语句，修改指针常量指向的值，是错误的
	p=&y;    //这样只修改指针，而不修改指针指向的内容，是可以的
	return 0;
}
```

· <font color="#22d050">程序 2 - 9</font> ：参数指针使用 const int * p 形式定义
```C++
#include<iostream>
using namespace std;

double Avg(const int *p, int num)
{
	int sum=0;
	for(int i=0; i<num; i++) sum+=p[i];
	return sum/num;
}

int main()
{
	int a[]={78, 82, 90, 86, 92};
	cout<<Avg(a,5)<<endl;
	//输出：85
	return 0;
}
```
· const 的作用：在函数内部，不能通过指针 p 来修改数组 a 中的元素值，这对于一些不需要修改数组内容的函数非常有用，因为它可以避免意外的数据修改

· <font color="#22d050">程序 2 - 10</font> ：int* const p 定义下，指针常量所指向内容的修改
```C++
#include<iostream>
using namespace std;

int main()
{
	int x=10, y=100;
	int* const p=&x;
	*p=50;
	//注意：不可使用 p=&y; 语句，因为指针常量本身不可被修改
	return 0;
}
```

· <font color="#22d050">程序 2 - 11</font> ：int* const arr 定义下，修改数组的赋值
```C++
#include<iostream>
using namespace std;

int main()
{
	int* const arr=new int[10];
	for(int i=0; i<10; i++)
	{
		arr[i]=i*2;
		cout<<arr[i]<<endl;
		//注意：这里不可使用语句 arr++; 因为这种定义下 arr 是常量
	}
	return 0;
}
```

###### · 数组常量：
· 数组常量可以这样定义：
```C++
int const arr[10];
const int arr[10];
两种定义形式等效
```
*【在数组常量的定义下，数组的每一个元素都是常量】*

· <font color="#22d050">程序 2 - 12</font> ：数组常量中元素的访问
```C++
#include<iostream>
using namespace std;

int main()
{
	const int a[7]={1,2,3,4,5,6,7};
	//注意：a[2]=100; 这样的语句是错误的，因为数组常量定义下，数组中每一个元素值都是不可改变的常量
	for(int i=0; i<7; i++)
	{
		cout<<*(a+i)<<endl;
	}
	return 0;
}
```

###### · 静态数据成员：
· 类中的数据成员的声明前面加上 static 关键字，该数据成员就成为了该类的静态数据成员
· 静态数据成员实际上是类域中的全局变量，故静态数据成员的定义（初始化）不应该放在头文件中，而应该放在相应的 cpp 文件中
· 静态数据成员的几点注意事项：
1. 静态数据成员必须初始化
2. 当在类外初始化时，没有 static 关键字，由类名限定
```C++
class Myclass
{
	static int num;    //静态数据成员
};

int Myclass::num=8;    //类外初始化
```

· 对于静态数据成员，所有类对象只存在一个副本
· 对于非静态数据成员，每个类对象都有自己的副本

· <font color="#22d050">程序 2 - 13</font> ：静态数据成员的类对象间共享性
```C++
#include<iostream>
using namespace std;

class Sample
{
	public:
	static void f(Sample& s)
	{
		x=100;
		s.y=100;
	}
	static int x;

	private:
	int y;
};

int Sample::x=0;    //初始化

int main()
{
	Sample obj, sub;
	obj.f(sub);
	Sample::f(sub);
	cout<<obj.x<<endl;
	obj.x=10;
	cout<<obj.x<<endl;    //对于静态数据成员，所有类对象只存在一个副本
	// Sample::x=10; 这句代码是错误的：static 本质上还是局部变量，不可在类外直接访问
	cout<<obj.x<<endl;
	//输出：
	//100
	//10
	//10
	return 0;
}
```

· 注意：<font color="#ffff00">static 变量不可以在构造函数的初始化列表中初始化</font>

###### · 常量数据成员：
· Const 数据成员不可被修改
· Const 数据成员最好在构造函数的成员初始化列表中初始化
· 包含 const 或 reference（引用）成员的类必须定义构造函数，在构造函数的成员初始化列表中赋值（不能在构造函数的内部用语句赋值）

· <font color="#22d050">程序 2 - 14</font> ：构造函数为常量和引用赋值
```C++
#include<iostream>
using namespace std;

class A
{
	public:
		A(int i);
		void Print();
	private:
		const int a;
		const int& r;    //注意：r 是 a 的一个“替身”，所以 a 是 const 的则 r 必须是 const 的
		int m;
};

A::A(int i):a(i),r(a)    //在构造函数的成员初始化列表中为常量赋值
{
	m=1;
}

void A::Print()
{
	cout<<"a="<<a<<", r="<<r<<", m="<<m<<endl;
	return;
}

int main()
{
	A a(7);
	a.Print();
	//输出：a=7, r=7, m=1
	return 0;
}
```

· 注意：改成下面这个构造函数将是错误的：
```C++
A::A(int i)
{
	a=i;
	m=1;
	r=a;
}    //错误：不能在构造函数的内部对 const 和 reference 初始化
```

###### · 常量函数成员：

· <font color="#22d050">程序 2 - 15</font> ：常量成员函数对于修改类内数据的限制
```C++
#include<iostream>
using namespace std;

class Date
{
	public:
	Date(int i, int j, int k) {y=i, m=j, d=k;}
	int year() const;
	int month() const {return m;};
	int day() {return d;}
	
	private:
	int y,m,d;
};

// const 成员函数不修改数据成员：
int Date::year() const
//当 const 成员函数在其类之外定义时，需要使用 “const” 后缀
{
	return y;    //注意：如果写成 “return ++y;” 则是错误的，常量成员函数不能修改数据成员
}

int main()
{
	Date date(2024, 3, 18);
	cout<<date.year()<<'.'<<date.month()<<'.'<<date.day()<<endl;
	//输出：2024.3.18
	return 0;
}
```

###### · 可变成员变量 mutable：
· 通常情况下，常量成员函数是不能修改类的成员变量的，因为它们被视为不会改变对象的状态
· 但是有时候可能有一些情况，即使在常量成员函数中，也需要修改某些成员变量的值
· 可以使用 “mutable” 关键字声明类的成员变量，使得在常量成员函数中，这个成员变量也可以被修改

· <font color="#22d050">程序 2 - 16</font> ：mutable 在常量成员函数修改数据的作用
```C++
#include<iostream>
using namespace std;

class Date
{
	public:
	Date(int i, int j, int k) {y=i, m=j, d=k;}
	int year() const {return y;}
	int month() const {return m;}
	int day() const {d++; return d;}
	
	private:
	int y,m;
	mutable int d;    // mutable 关键字下，d 可以被 const 成员函数所修改
};

int main()
{
	Date date(2024, 3, 18);
	cout<<date.year()<<'.'<<date.month()<<'.'<<date.day()<<endl;
	//输出：2024.3.19
	cout<<date.day();
	//输出：20
	return 0;
}
```

· 小结：
1. const 关键字支持将对象、函数参数、返回值和成员函数定义为常量
2. 预处理器 `#define` 由于声明数据类型不明，可能会导致一些问题，const 的定义可以避免这一情况，这在编程中提供了一种重要的附加形式的类型检查和安全性


### 叁  内联函数

####
#####
#####

###### · 提高效率的探寻：
· “如何提高程序运行的效率”，在编程上始终是一个重要的值得研究的问题
· 在 C 语言中，保持效率的方法之一是使用预处理器宏，预处理器直接用宏代码替换所有宏调用
· 在 C++ 中，预处理器宏有两个问题：
1. 宏会隐藏难以发现的 “bug”
2. 预处理器宏不能用作类成员函数
· 为了保持预处理器宏的效率，同时又添加真实函数的安全性和类作用域，C++ 有**内联函数**

· <font color="#22d050">程序 2 - 17</font> ：预处理程序缺陷的试验
```C++
#include<iostream>
using namespace std;

#define f(x) x*x

int main()
{
	int x(2);
	cout<<f(x)<<endl;
	cout<<f(x+1)<<endl;
	//输出：
	//4
	//5
	return 0;
}

//原因：
//对于 f(x)，其运算方式为：2*2
//对于 f(x)，其运算方式为：2+1*2+1，得到的结果为 5，因为 x*x 默认没有期望的括号
```
· 改进：
```C++
#define f(x) (x)*(x)
//此时运算方式为：(2+1)*(2+1)，这样得到的就是期望的结果：9
```

· 预处理器仅仅是进行**文本替换**，并没有考虑到表达式的语义
· 在使用预处理器宏时需要格外小心，尤其是在处理带有运算符的表达式时

· 当一个函数有几行代码，但可能经常被调用时，可以使用内联来节省时间和提高效率
· 内联函数是一个真正的函数，它像预处理器宏一样在适当的位置展开，因此消除了函数调用的开销
· 使用内联函数来代替宏，常常是一个好的选择

###### · 内联函数：
· 内联函数定义必须在调用之前出现
· 内联函数体不包括异常处理
· 内联函数体不是递归的

· 在类定义中定义的任何函数都自动成为内联函数，因此 “inline” 关键字在类定义中是不必要的

· <font color="#22d050">程序 2 - 18</font> ：字符串默认传参的测试
```C++
#include<iostream>
#include<string>
using namespace std;

class Point
{
	int i,j,k;
	public:
	Point():i(0),j(0),k(0) {}
	Point(int ii, int jj, int kk):i(ii),j(jj),k(kk) {}
	void print(const string& msg="abcde") const    //如果不传参，则默认传入字符串“abcde”
	{
		if(msg.size()!=0) cout<<msg<<endl;
		cout<<i<<","<<j<<","<<k<<endl;
	}
};    //类内函数默认为是内联函数

int main()
{
	Point p(1,2,3);
	p.print();
	//输出：
	//abcde
	//1,2,3
	p.print("");
	//输出：
	//1,2,3
	p.print("12345");
	//输出：
	//12345
	//1,2,3
	return 0;
}
```

· 使用 inline 关键字将内联的定义放在类的外部，以保持接口整洁

· <font color="#22d050">程序 2 - 19</font> ：类的外部定义内联函数
```C++
#include<iostream>
#include<string>
using namespace std;

class Point
{
	int i,j,k;
	public:
	Point();
	Point(int ii, int jj, int kk);
	void print(const string& msg="abcde") const;
};

inline Point::Point():i(0),j(0),k(0) {};
inline Point::Point(int ii, int jj, int kk):i(ii),j(jj),k(kk) {}
inline void Point::print(const string& msg) const
{
	if(msg.size()!=0) cout<<msg<<endl;
	cout<<i<<","<<j<<","<<k<<endl;
}

int main()
{
	Point p;
	p.print("aaa");
	//输出：
	//aaa
	//0,0,0
	return 0;
}
```

###### · 构造函数和析构函数中的隐藏活动：

· <font color="#22d050">程序 2 - 20</font> ：构造函数和析构函数的内部机制
```C++
#include<iostream>
using namespace std;

class Member
{
	int i;
	public:
	Member(int x=0):i(x) {}
	~Member() {cout<<"~Member, i="<<i<<endl;}
};

class WithMembers
{
	Member q,r,s;
	int j;
	public:
	WithMembers(int a, int b):q(a),r(b) {j=a;}
	~WithMembers() {cout<<"~WithMembers, j="<<j<<endl;}
};

int main()
{
	WithMembers w(2,5);
	//输出：
	//~WithMembers, j=2
	//~Member, i=0
	//~Member, i=5
	//~Member, i=2
	return 0;

	//1.调用 WithMembers 后，创建 q、r、s
	//2. q 中的 i 传值 2，r 中的 i 传值 5，s 中的 i 默认值为 0
	//3. WithMembers 中的 j 传值为 2
	//4.销毁时先调用“最外层” WithMembers 的析构函数，输出：“~WithMembers, j=2”
	//5.倒序调用 q、r、s 的析构函数，输出三行 “~Member”，i 的值也倒序输出：0，5，2
}
```


### 肆  名称控制

#### 述：
#####
#####

###### · 命名空间：
· 虽然名称可以嵌套在类中，但全局函数、全局变量和类的名称仍然在一个全局名称空间中
· 在大型项目中，缺乏对全局名称空间的控制可能会导致问题
· 可以使用 C++ 的名称空间（namespace）特性将全局名称空间细分为更易于管理的部分

· **创建命名空间**：
· *命名空间与类的不同*：
1. 命名空间只能出现在全局作用域中，或者嵌套在另一个命名空间中
2. 命名空间在结束大括号之后不需要用 “;” 结尾
3. 定义的名称可以在多个头文件中使用
4. 命名空间本身不是一个可以实例化的实体，它不具有状态或行为，也不能被创建成对象

· **范围解析**：

· <font color="#22d050">程序 2 - 21</font> ：命名空间的创建与使用
```C++
#include<iostream>
using namespace std;

namespace DB
{
	class SQL
	{
		static int i;    //在命名空间外初始化
		public:
		void Value(int) {cout<<i<<endl;}
	};
	class EXCEL;
	void GetDBType();
}

int DB::SQL::i=9;    //类外初始化必须声明类型

class DB::EXCEL
{
	int u,v,w;
	public:
	EXCEL(int i);
	int Value();
};

DB::EXCEL::EXCEL(int i) {u=v=w=i;}
int DB::EXCEL::Value() {return w;}
void DB::GetDBType()
{
	DB::SQL obj;
	obj.Value(1);
}

int main()
{
	DB::GetDBType();
	//输出：9
	return 0;
}
```

###### · 使用指令（using directive）：

· <font color="#22d050">程序 2 - 22</font> ：使用指令调用命名空间
```C++
#include<iostream>
using namespace std;

namespace calculator
{
	double Add(double x, double y) {return x+y;}
	void Print(double x) {cout<<x<<endl;}
	class Shape{};
}

calculator::Shape S1;    //用命名空间定义对象
using namespace calculator;    //使用指令

int main()
{
	Shape S2;    //由于使用指令，这里不需要再写成：“calculator::shape S2;”
	double a,b;
	cin>>a>>b;
	cout<<Add(a,b)<<endl;    //返回 a+b 的值
	return 0;
}
```

###### · 在 “. Net Framework” 中的命名空间：

1. **基础命名空间**：

| 名称                  | 说明                                     |
| ------------------- | -------------------------------------- |
| System .Collections | 包含了一些与集合相关的类型，比如列表、队列、位数组、哈希表和字典等      |
| System .IO          | 包含了一些数据流类型并提供了文件和目录同步异步读写              |
| System .Text        | 包含了一些表示字符编码的类型并提供了字符串的操作和格式化           |
| System .Reflection  | 包含了一些提供加载类型、方法和字段的托管视图以及动态创建和调用类型功能的类型 |
| System .Threading   | 提供启用多线程的类和接口                           |

2. **图形命名空间**：

| 名称                        | 说明                                                               |
| ------------------------- | ---------------------------------------------------------------- |
| System .Drawing           | 这个主要的 GDI + 命名空间定义了许多类型，实现基本的绘图类型（字体、钢笔、基本画笔等）和无所不能的 Graphics 对象 |
| System .Drawing2D         | 这个命名空间提供高级的二维和矢量图像功能                                             |
| System .Drawing .Imaging  | 这个命名空间定义了一些类型实现图形图像的操作                                           |
| System .Drawing .Text     | 这个命名空间提供了操作字体集合的功能                                               |
| System .Drawing .Printing | 这个命名空间定义了一些类型实现在打印纸上的绘制图像，和打印机交互以及格式化某个打印任务的总体外观等功能              |

3. **数据命名空间**：

| 名称                         | 说明                                                                                       |
| -------------------------- | ---------------------------------------------------------------------------------------- |
| System .Data               | 包含了数据访问使用的一些主要类型                                                                         |
| System .Data .Common       | 包含了各种数据库访问共享的一些类型                                                                        |
| System .XML                | 包含了根据标准来支持 XML 处理的类                                                                      |
| System .Data .OleDb        | 包含了一些操作 OLEDB 数据源的类型                                                                     |
| System .Data .Sql          | 能使枚举安装在当前本地网络的 SQL Server 实例                                                             |
| System .Data .SqlClient    | 包含了一些操作 MS SQL Server 数据库的类型，提供了和 System .Data .OleDb 相似的功能，但是针对 SQL 做了优化（优化后的 SQL 操作类库） |
| System .Data .SqlTypes     | 提供了一些表示 SQL 数据类型的类                                                                       |
| System .Data .Odbc         | 包含了操作 Odbc 数据库的类型                                                                        |
| System .Data .OracleClient | 包含了操作 Odbc 数据库的类型                                                                        |
| System .Transactions       | 这个命名空间提供了编写事务性应用程序和资源管理器的一些类                                                             |


### 伍  引用和拷贝构造函数

#### 述：
#####
#####

###### · 函数中的引用：
· 引用（reference，&）通常用于函数参数列表和函数返回值
· 当引用被用作函数参数时，对函数内部引用的任何修改都会导致函数外部参数的更改
· 如果从函数返回一个引用，必须像从函数返回一个指针一样小心，避免引用未知内存

· <font color="#22d050">程序 2 - 23</font> ：函数中的引用
```C++
#include<iostream>
using namespace std;

int* f(int* x)
{
	(*x)++;
	return x;
}

int& g(int& x)
{
	x++;
	return x;
}

int main()
{
	int a=0;
	int *p;
	p=f(&a);    //麻烦，但是一目了然
	int& b=g(a);    //简洁，但是“晦涩”难懂
	cout<<*p<<','<<' '<<b<<endl;
	//输出：2，2
	//因为函数 f 和 g 被分别调用了一次，所以 a 自加了两次
	*p=3;
	cout<<a<<endl;
	//输出：3
	//地址内容被修改，a 随之被修改
	b=4;
	cout<<a<<endl;
	//输出：4
	// b 与 a 建立引用关系
	a=7;
	cout<<b<<endl;
	//输出：7
	return 0;
}
```

###### · 局部变量引用：

· <font color="#22d050">程序 2 - 24</font> ：局部变量引用
```C++
#include<iostream>
using namespace std;

int& h()
{
	int p=10;
	int& q=p;    //局部变量引用
	return q;
}

int main()
{
	int& a=h();
	a++;
	cout<<a<<endl;
	//输出：11
	return 0;
}
```

###### · 用相同类的其他对象为自身初始化：

· <font color="#22d050">程序 2 - 25</font> ：用同类型数据为自身初始化
```C++
#include<iostream>
using namespace std;

int main()
{
	int x=10;
	int y(x);    // 将 x 的值赋值给 y
	int z{y};    // 将 y 的值赋值给 z
	cout<<x<<' '<<y<<' '<<z<<endl;
	return 0;
}
```

· <font color="#22d050">程序 2 - 26</font> ：利用相同类的其他对象为自身初始化
```C++
#include<iostream>
using namespace std;

class Sample
{
	public:
	Sample(int p) {x=p;}
	void Pri() {cout<<x<<endl;}

	private:
	int x;
};

int main()
{
	Sample S1(2);
	Sample S2(S1);
	Sample S3{S2};    // C++ 11 引入的初始化列表语法
	Sample S4=S3;    //复制初始化方法
	S4.Pri();
	return 0;
}
```

· 复制构造函数的执行语义是初始化对象成员数据

· <font color="#22d050">程序 2 - 27</font> ：拷贝构造函数的遗传形式
```C++
#include<iostream>
using namespace std;

class Sample
{
	public:
	Sample(const Sample &p);    //拷贝构造函数，使用 “&” 以防止不必要的对象复制
	Sample(int p) {x=p;}
	void Pri() {cout<<x<<endl;}

	private:
	int x;
};

int main()
{
	Sample S1(3);
	Sample S2(S1);    //拷贝构造函数的调用
	S2.Pri();
	return 0;
}
```

· 如果不显式定义拷贝构造函数，C++ 会自动生成一个默认的拷贝构造函数，这个默认的拷贝构造函数会执行 *浅拷贝（shallow copy）* 操作
· 浅拷贝简单地复制成员变量的值，如果类中的成员变量包含指针或其他动态分配的资源，这样的浅拷贝可能会导致问题

· <font color="#22d050">程序 2 - 28</font> ：浅拷贝在指针复制上的问题
```C++
#include<iostream>
using namespace std;

class Sample
{
	public:
	int *ptr;
	
	Sample()    //默认构造函数
	{
		ptr=new int;
		*ptr=10;
	}

	//显式定义的拷贝构造函数
	// Sample(const Sample& other)
	// {
	//     ptr=new int;
	//     *ptr=*(other.ptr);
	// }
};

int main()
{
	Sample S1;
	Sample S2(S1);    //使用拷贝构造函数初始化 S2

	cout<<"S1.ptr: "<<*(S1.ptr)<<endl;
	cout<<"S2.ptr: "<<*(S2.ptr)<<endl;
	delete S1.ptr;    //释放 s1.ptr 指向的内存
	cout<<"S2.ptr: "<<*(S2.ptr)<<endl;
	return 0;
}
```

· 在 程序 2 - 28 中，使用默认的浅拷贝方式将 S1 赋值给 S2，这样会导致类中的变量 int* ptr 只是简单地将指针赋值成相同的值，即两个指针指向同一个地址，导致 delete S1.ptr 的做法将指针指向的内存释放后 S2.ptr 悬挂（第三次输出有可能仍然是正常的 “10”，但并不代表没有问题）

· <font color="#22d050">程序 2 - 29</font> ：拷贝构造函数会默认生成，执行浅拷贝操作
```C++
#include<iostream>
using namespace std;

class Point
{
	public:
	Point(int xx=0, int yy=0) {X=xx, Y=yy;}
	Point(const Point &p);    //拷贝构造函数（可删，在这里允许浅拷贝）
	int GetX() {return X;}
	int GetY() {return Y;}

	private:
	int X,Y;
};

Point::Point(const Point &p)
{
	X=p.X;    //非特殊变量（如指针和动态内存有关变量等）可以不显式赋值，默认对应赋值也会得到同样效果
	Y=p.Y;
	cout<<"Copy-constructor called."<<endl; 
}

int main()
{
	Point A(1,2);
	Point B(A);    //调用拷贝构造函数
	cout<<"B:("<<B.GetX()<<", ";
	cout<<B.GetY()<<')'<<endl
	//输出：
	// Copy-constructor called.
	// B:(1, 2)
	return 0;
}
```

· <font color="#ffff00">当实参是对象时，也将调用拷贝构造函数</font>

· <font color="#22d050">程序 2 - 30</font> ：函数实参是对象时，调用拷贝构造函数
```C++
#include<iostream>
using namespace std;

class Point
{
	public:
	Point(int xx=0, int yy=0) {X=xx, Y=yy;}
	Point(const Point &p);
	~Point() {cout<<'('<<X<<", "<<Y<<") Object destroyed."<<endl;}
	int GetX() {return X;}
	int GetY() {return Y;}

	private:
	int X,Y;
};

Point::Point(const Point &p)    //拷贝构造函数
{
	X=p.X, Y=p.Y;
	cout<<"Copy-constructor called."<<endl;
}

void f(Point p)
{
	cout<<"Function:("<<p.GetX()<<", "<<p.GetY()<<')'<<endl;
}

int main()
{
	Point A(1,2);
	f(A);
	//输出：
	// Copy-constructor called.
	// Function:(1, 2)
	// (1, 2) Object destroyed.
	// (1, 2) Object destroyed.
	return 0;
}
```

· <font color="#ffff00">当函数的返回类型为类时，也将调用拷贝构造函数</font>（新版编译器不会）

· <font color="#22d050">程序 2 - 31</font> ：当函数返回一个类时，调用拷贝构造函数（新版编译器不会）
```C++
#include<iostream>
using namespace std;

class Point
{
	public:
	Point(int xx=0, int yy=0)
	{
		X=xx, Y=yy;
		cout<<"Object constructed."<<endl;
	}
	Point(const Point &p);
	~Point() {cout<<'('<<X<<", "<<Y<<')'<<" Object destroyed."<<endl;}
	int GetX() {return X;}
	int GetY() {return Y;}

	private:
	int X,Y;
};

Point::Point(const Point &p)
{
	X=p.X, Y=p.Y;
	cout<<"Copy-constructor called."<<endl;
}

Point g()
{
	Point A(1,2);
	return A;
}

int main()
{
	Point B;
	B=g();

	//旧版编译器的输出：
	// Object constructed.
	// Object constructed.
	// Copy_constructor call.
	// 1,2 Object destroyed
	// 1,2 Object destroyed.
	// 1,2 Object destroyed.

	//新版编译器的输出：
	// Object constructed.
	// Object constructed.
	// 1,2 Object destroyed.
	// 1,2 Object destroyed.

	return 0;
}
```

###### · C++ 11 版引入的右值引用：
· 右值引用是 C++ 11 引入的特性，它支持将右值（暂时对象或者可以被移动的对象）绑定到引用上，并且在移动语义中非常有用
· 右值引用用 “&&” 符号表示
· 右值引用下的函数，如果返回类型是一个类对象，不会调用拷贝构造函数
· 在 C++ 11 之后，编译器对于返回临时对象的优化已经变得更加普遍，因此即使没有明确使用右值引用，编译器也会尝试使用移动语义来提高效率，这也是为什么即使去掉 “&&”，代码可能仍然不会调用拷贝构造函数的原因之一

· <font color="#22d050">程序 2 - 32</font> ：右值引用
```C++
#include<iostream>
using namespace std;

class Point
{
	public:
	Point(int xx=0, int yy=0)
	{
		X=xx;
		Y=yy;
	}
	Point(const Point &p);
	Point&& MoveCopy(int offset);    //右值引用，以避免不必要的拷贝构造调用
	
	private:
	int X,Y;
};

Point::Point(const Point &p)
{
	X=p.X;
	Y=p.Y;
	cout<<"Copy-constructor is called."<<endl;
}

Point&& Point::MoveCopy(int offset)
{
	cout<<"\"operator+\" is called."<<endl;
	int posX=X+offset;
	int posY=Y+offset;
	return Point(posX, posY);
}

int main()
{
	Point A(1,2);
	Point B=A;
	B=A.MoveCopy(5);
	//输出：
	// Copy-constructor is called.
	// "operator+" is called.
	return 0;
}
```

· **拷贝构造函数小结**：
· 通过对象传递参数时调用拷贝构造函数
· 当通过引用或指针传递参数时，不会调用拷贝构造函数，因为没有创建新对象
· 当函数返回一个对象时，调用拷贝构造函数

